// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `enum AboriginalStatus {
  ABORIGINAL_NOT_TORRES
  TORRES_NOT_ABORIGINAL
  BOTH
  NEITHER
  NOT_STATED
}

type Address {
  id: ID!
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
}

input AddressCreateManyInput {
  create: [AddressCreateInput!]
  connect: [AddressWhereUniqueInput!]
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  street_ASC
  street_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  country_ASC
  country_DESC
  postCode_ASC
  postCode_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AddressPreviousValues {
  id: ID!
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AddressScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  latitude: String
  latitude_not: String
  latitude_in: [String!]
  latitude_not_in: [String!]
  latitude_lt: String
  latitude_lte: String
  latitude_gt: String
  latitude_gte: String
  latitude_contains: String
  latitude_not_contains: String
  latitude_starts_with: String
  latitude_not_starts_with: String
  latitude_ends_with: String
  latitude_not_ends_with: String
  longitude: String
  longitude_not: String
  longitude_in: [String!]
  longitude_not_in: [String!]
  longitude_lt: String
  longitude_lte: String
  longitude_gt: String
  longitude_gte: String
  longitude_contains: String
  longitude_not_contains: String
  longitude_starts_with: String
  longitude_not_starts_with: String
  longitude_ends_with: String
  longitude_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressScalarWhereInput!]
  OR: [AddressScalarWhereInput!]
  NOT: [AddressScalarWhereInput!]
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
}

input AddressUpdateInput {
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
}

input AddressUpdateManyDataInput {
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
}

input AddressUpdateManyInput {
  create: [AddressCreateInput!]
  update: [AddressUpdateWithWhereUniqueNestedInput!]
  upsert: [AddressUpsertWithWhereUniqueNestedInput!]
  delete: [AddressWhereUniqueInput!]
  connect: [AddressWhereUniqueInput!]
  set: [AddressWhereUniqueInput!]
  disconnect: [AddressWhereUniqueInput!]
  deleteMany: [AddressScalarWhereInput!]
  updateMany: [AddressUpdateManyWithWhereNestedInput!]
}

input AddressUpdateManyMutationInput {
  street: String
  city: String
  state: String
  country: String
  postCode: String
  latitude: String
  longitude: String
}

input AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput!
  data: AddressUpdateManyDataInput!
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AddressWhereUniqueInput
}

input AddressUpdateWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput!
  data: AddressUpdateDataInput!
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressUpsertWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput!
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  latitude: String
  latitude_not: String
  latitude_in: [String!]
  latitude_not_in: [String!]
  latitude_lt: String
  latitude_lte: String
  latitude_gt: String
  latitude_gte: String
  latitude_contains: String
  latitude_not_contains: String
  latitude_starts_with: String
  latitude_not_starts_with: String
  latitude_ends_with: String
  latitude_not_ends_with: String
  longitude: String
  longitude_not: String
  longitude_in: [String!]
  longitude_not_in: [String!]
  longitude_lt: String
  longitude_lte: String
  longitude_gt: String
  longitude_gte: String
  longitude_contains: String
  longitude_not_contains: String
  longitude_starts_with: String
  longitude_not_starts_with: String
  longitude_ends_with: String
  longitude_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateApInvoice {
  count: Int!
}

type AggregateAsset {
  count: Int!
}

type AggregateAssetGroup {
  count: Int!
}

type AggregateAttachment {
  count: Int!
}

type AggregateBank {
  count: Int!
}

type AggregateBankTransaction {
  count: Int!
}

type AggregateBasicDailyFee {
  count: Int!
}

type AggregateCompany {
  count: Int!
}

type AggregateCompanyMember {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateDisease {
  count: Int!
}

type AggregateHealthcareProvider {
  count: Int!
}

type AggregateHILog {
  count: Int!
}

type AggregateImmunisationSchedule {
  count: Int!
}

type AggregateIntegration {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateInventoryOnHand {
  count: Int!
}

type AggregateInvoice {
  count: Int!
}

type AggregateInvoiceItemEntry {
  count: Int!
}

type AggregateLedgerJournal {
  count: Int!
}

type AggregateLedgerPosting {
  count: Int!
}

type AggregateLedgerTransaction {
  count: Int!
}

type AggregateMainAccount {
  count: Int!
}

type AggregateMeansTestedFee {
  count: Int!
}

type AggregateMeansTestLimits {
  count: Int!
}

type AggregateMedicareService {
  count: Int!
}

type AggregateName {
  count: Int!
}

type AggregatePatient {
  count: Int!
}

type AggregatePbsOrganisation {
  count: Int!
}

type AggregatePbsTPP {
  count: Int!
}

type AggregatePlan {
  count: Int!
}

type AggregatePoReceipt {
  count: Int!
}

type AggregatePredictedSalesQuantityOfItemsByCompany {
  count: Int!
}

type AggregatePredictedSalesValueByCompany {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateProjectService {
  count: Int!
}

type AggregateProjectServiceRule {
  count: Int!
}

type AggregatePurchaseOrder {
  count: Int!
}

type AggregatePurchaseOrderLine {
  count: Int!
}

type AggregateSalesOrder {
  count: Int!
}

type AggregateSalesOrderLine {
  count: Int!
}

type AggregateService {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateSupplier {
  count: Int!
}

type AggregateTimeSheet {
  count: Int!
}

type AggregateTimeSheetEntry {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVaccineBrand {
  count: Int!
}

type AggregateWareHouse {
  count: Int!
}

type ApInvoice {
  id: ID!
  status: ApInvoiceStatus
  invoiceNumber: String
  purchaseOrder: PurchaseOrder
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ApInvoiceConnection {
  pageInfo: PageInfo!
  edges: [ApInvoiceEdge]!
  aggregate: AggregateApInvoice!
}

input ApInvoiceCreateInput {
  id: ID
  status: ApInvoiceStatus
  invoiceNumber: String
  purchaseOrder: PurchaseOrderCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type ApInvoiceEdge {
  node: ApInvoice!
  cursor: String!
}

enum ApInvoiceOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  invoiceNumber_ASC
  invoiceNumber_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ApInvoicePreviousValues {
  id: ID!
  status: ApInvoiceStatus
  invoiceNumber: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ApInvoiceStatus {
  OPEN
  PAID
}

type ApInvoiceSubscriptionPayload {
  mutation: MutationType!
  node: ApInvoice
  updatedFields: [String!]
  previousValues: ApInvoicePreviousValues
}

input ApInvoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ApInvoiceWhereInput
  AND: [ApInvoiceSubscriptionWhereInput!]
  OR: [ApInvoiceSubscriptionWhereInput!]
  NOT: [ApInvoiceSubscriptionWhereInput!]
}

input ApInvoiceUpdateInput {
  status: ApInvoiceStatus
  invoiceNumber: String
  purchaseOrder: PurchaseOrderUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input ApInvoiceUpdateManyMutationInput {
  status: ApInvoiceStatus
  invoiceNumber: String
  isArchived: Boolean
  isDeleted: Boolean
}

input ApInvoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ApInvoiceStatus
  status_not: ApInvoiceStatus
  status_in: [ApInvoiceStatus!]
  status_not_in: [ApInvoiceStatus!]
  invoiceNumber: String
  invoiceNumber_not: String
  invoiceNumber_in: [String!]
  invoiceNumber_not_in: [String!]
  invoiceNumber_lt: String
  invoiceNumber_lte: String
  invoiceNumber_gt: String
  invoiceNumber_gte: String
  invoiceNumber_contains: String
  invoiceNumber_not_contains: String
  invoiceNumber_starts_with: String
  invoiceNumber_not_starts_with: String
  invoiceNumber_ends_with: String
  invoiceNumber_not_ends_with: String
  purchaseOrder: PurchaseOrderWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ApInvoiceWhereInput!]
  OR: [ApInvoiceWhereInput!]
  NOT: [ApInvoiceWhereInput!]
}

input ApInvoiceWhereUniqueInput {
  id: ID
}

type Asset {
  id: ID!
  name: String
  assetGroup: AssetGroup
  dateOfAquisition: DateTime
  aquisitionPrice: Float
  netBookValue: Float
  depreciation: Float
  salvageValue: Float
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetConnection {
  pageInfo: PageInfo!
  edges: [AssetEdge]!
  aggregate: AggregateAsset!
}

input AssetCreateInput {
  id: ID
  name: String
  assetGroup: AssetGroupCreateOneInput
  dateOfAquisition: DateTime
  aquisitionPrice: Float
  netBookValue: Float
  depreciation: Float
  salvageValue: Float
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type AssetEdge {
  node: Asset!
  cursor: String!
}

type AssetGroup {
  id: ID!
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  deprMainAccount: MainAccount
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetGroupConnection {
  pageInfo: PageInfo!
  edges: [AssetGroupEdge]!
  aggregate: AggregateAssetGroup!
}

input AssetGroupCreateInput {
  id: ID
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  deprMainAccount: MainAccountCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetGroupCreateOneInput {
  create: AssetGroupCreateInput
  connect: AssetGroupWhereUniqueInput
}

enum AssetGroupDepreciationType {
  STRAIGHT_LINE
  REDUCING_BALANCE
}

type AssetGroupEdge {
  node: AssetGroup!
  cursor: String!
}

enum AssetGroupOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  depreciationType_ASC
  depreciationType_DESC
  usefulLife_ASC
  usefulLife_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AssetGroupPreviousValues {
  id: ID!
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetGroupSubscriptionPayload {
  mutation: MutationType!
  node: AssetGroup
  updatedFields: [String!]
  previousValues: AssetGroupPreviousValues
}

input AssetGroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssetGroupWhereInput
  AND: [AssetGroupSubscriptionWhereInput!]
  OR: [AssetGroupSubscriptionWhereInput!]
  NOT: [AssetGroupSubscriptionWhereInput!]
}

input AssetGroupUpdateDataInput {
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  deprMainAccount: MainAccountUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetGroupUpdateInput {
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  deprMainAccount: MainAccountUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetGroupUpdateManyMutationInput {
  name: String
  depreciationType: AssetGroupDepreciationType
  usefulLife: Int
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetGroupUpdateOneInput {
  create: AssetGroupCreateInput
  update: AssetGroupUpdateDataInput
  upsert: AssetGroupUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AssetGroupWhereUniqueInput
}

input AssetGroupUpsertNestedInput {
  update: AssetGroupUpdateDataInput!
  create: AssetGroupCreateInput!
}

input AssetGroupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  depreciationType: AssetGroupDepreciationType
  depreciationType_not: AssetGroupDepreciationType
  depreciationType_in: [AssetGroupDepreciationType!]
  depreciationType_not_in: [AssetGroupDepreciationType!]
  usefulLife: Int
  usefulLife_not: Int
  usefulLife_in: [Int!]
  usefulLife_not_in: [Int!]
  usefulLife_lt: Int
  usefulLife_lte: Int
  usefulLife_gt: Int
  usefulLife_gte: Int
  deprMainAccount: MainAccountWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetGroupWhereInput!]
  OR: [AssetGroupWhereInput!]
  NOT: [AssetGroupWhereInput!]
}

input AssetGroupWhereUniqueInput {
  id: ID
}

enum AssetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  dateOfAquisition_ASC
  dateOfAquisition_DESC
  aquisitionPrice_ASC
  aquisitionPrice_DESC
  netBookValue_ASC
  netBookValue_DESC
  depreciation_ASC
  depreciation_DESC
  salvageValue_ASC
  salvageValue_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AssetPreviousValues {
  id: ID!
  name: String
  dateOfAquisition: DateTime
  aquisitionPrice: Float
  netBookValue: Float
  depreciation: Float
  salvageValue: Float
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AssetSubscriptionPayload {
  mutation: MutationType!
  node: Asset
  updatedFields: [String!]
  previousValues: AssetPreviousValues
}

input AssetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AssetWhereInput
  AND: [AssetSubscriptionWhereInput!]
  OR: [AssetSubscriptionWhereInput!]
  NOT: [AssetSubscriptionWhereInput!]
}

input AssetUpdateInput {
  name: String
  assetGroup: AssetGroupUpdateOneInput
  dateOfAquisition: DateTime
  aquisitionPrice: Float
  netBookValue: Float
  depreciation: Float
  salvageValue: Float
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetUpdateManyMutationInput {
  name: String
  dateOfAquisition: DateTime
  aquisitionPrice: Float
  netBookValue: Float
  depreciation: Float
  salvageValue: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input AssetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  assetGroup: AssetGroupWhereInput
  dateOfAquisition: DateTime
  dateOfAquisition_not: DateTime
  dateOfAquisition_in: [DateTime!]
  dateOfAquisition_not_in: [DateTime!]
  dateOfAquisition_lt: DateTime
  dateOfAquisition_lte: DateTime
  dateOfAquisition_gt: DateTime
  dateOfAquisition_gte: DateTime
  aquisitionPrice: Float
  aquisitionPrice_not: Float
  aquisitionPrice_in: [Float!]
  aquisitionPrice_not_in: [Float!]
  aquisitionPrice_lt: Float
  aquisitionPrice_lte: Float
  aquisitionPrice_gt: Float
  aquisitionPrice_gte: Float
  netBookValue: Float
  netBookValue_not: Float
  netBookValue_in: [Float!]
  netBookValue_not_in: [Float!]
  netBookValue_lt: Float
  netBookValue_lte: Float
  netBookValue_gt: Float
  netBookValue_gte: Float
  depreciation: Float
  depreciation_not: Float
  depreciation_in: [Float!]
  depreciation_not_in: [Float!]
  depreciation_lt: Float
  depreciation_lte: Float
  depreciation_gt: Float
  depreciation_gte: Float
  salvageValue: Float
  salvageValue_not: Float
  salvageValue_in: [Float!]
  salvageValue_not_in: [Float!]
  salvageValue_lt: Float
  salvageValue_lte: Float
  salvageValue_gt: Float
  salvageValue_gte: Float
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  NOT: [AssetWhereInput!]
}

input AssetWhereUniqueInput {
  id: ID
}

type Attachment {
  id: ID!
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AttachmentConnection {
  pageInfo: PageInfo!
  edges: [AttachmentEdge]!
  aggregate: AggregateAttachment!
}

input AttachmentCreateInput {
  id: ID
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
}

input AttachmentCreateManyInput {
  create: [AttachmentCreateInput!]
  connect: [AttachmentWhereUniqueInput!]
}

input AttachmentCreateOneInput {
  create: AttachmentCreateInput
  connect: AttachmentWhereUniqueInput
}

type AttachmentEdge {
  node: Attachment!
  cursor: String!
}

enum AttachmentOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  fileName_ASC
  fileName_DESC
  label_ASC
  label_DESC
  url_ASC
  url_DESC
  s3Bucket_ASC
  s3Bucket_DESC
  s3Key_ASC
  s3Key_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AttachmentPreviousValues {
  id: ID!
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AttachmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  fileName: String
  fileName_not: String
  fileName_in: [String!]
  fileName_not_in: [String!]
  fileName_lt: String
  fileName_lte: String
  fileName_gt: String
  fileName_gte: String
  fileName_contains: String
  fileName_not_contains: String
  fileName_starts_with: String
  fileName_not_starts_with: String
  fileName_ends_with: String
  fileName_not_ends_with: String
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  s3Bucket: String
  s3Bucket_not: String
  s3Bucket_in: [String!]
  s3Bucket_not_in: [String!]
  s3Bucket_lt: String
  s3Bucket_lte: String
  s3Bucket_gt: String
  s3Bucket_gte: String
  s3Bucket_contains: String
  s3Bucket_not_contains: String
  s3Bucket_starts_with: String
  s3Bucket_not_starts_with: String
  s3Bucket_ends_with: String
  s3Bucket_not_ends_with: String
  s3Key: String
  s3Key_not: String
  s3Key_in: [String!]
  s3Key_not_in: [String!]
  s3Key_lt: String
  s3Key_lte: String
  s3Key_gt: String
  s3Key_gte: String
  s3Key_contains: String
  s3Key_not_contains: String
  s3Key_starts_with: String
  s3Key_not_starts_with: String
  s3Key_ends_with: String
  s3Key_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AttachmentScalarWhereInput!]
  OR: [AttachmentScalarWhereInput!]
  NOT: [AttachmentScalarWhereInput!]
}

type AttachmentSubscriptionPayload {
  mutation: MutationType!
  node: Attachment
  updatedFields: [String!]
  previousValues: AttachmentPreviousValues
}

input AttachmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttachmentWhereInput
  AND: [AttachmentSubscriptionWhereInput!]
  OR: [AttachmentSubscriptionWhereInput!]
  NOT: [AttachmentSubscriptionWhereInput!]
}

input AttachmentUpdateDataInput {
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
}

input AttachmentUpdateInput {
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
}

input AttachmentUpdateManyDataInput {
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
}

input AttachmentUpdateManyInput {
  create: [AttachmentCreateInput!]
  update: [AttachmentUpdateWithWhereUniqueNestedInput!]
  upsert: [AttachmentUpsertWithWhereUniqueNestedInput!]
  delete: [AttachmentWhereUniqueInput!]
  connect: [AttachmentWhereUniqueInput!]
  set: [AttachmentWhereUniqueInput!]
  disconnect: [AttachmentWhereUniqueInput!]
  deleteMany: [AttachmentScalarWhereInput!]
  updateMany: [AttachmentUpdateManyWithWhereNestedInput!]
}

input AttachmentUpdateManyMutationInput {
  description: String
  fileName: String
  label: String
  url: String
  s3Bucket: String
  s3Key: String
}

input AttachmentUpdateManyWithWhereNestedInput {
  where: AttachmentScalarWhereInput!
  data: AttachmentUpdateManyDataInput!
}

input AttachmentUpdateOneInput {
  create: AttachmentCreateInput
  update: AttachmentUpdateDataInput
  upsert: AttachmentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AttachmentWhereUniqueInput
}

input AttachmentUpdateWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  data: AttachmentUpdateDataInput!
}

input AttachmentUpsertNestedInput {
  update: AttachmentUpdateDataInput!
  create: AttachmentCreateInput!
}

input AttachmentUpsertWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput!
  update: AttachmentUpdateDataInput!
  create: AttachmentCreateInput!
}

input AttachmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  fileName: String
  fileName_not: String
  fileName_in: [String!]
  fileName_not_in: [String!]
  fileName_lt: String
  fileName_lte: String
  fileName_gt: String
  fileName_gte: String
  fileName_contains: String
  fileName_not_contains: String
  fileName_starts_with: String
  fileName_not_starts_with: String
  fileName_ends_with: String
  fileName_not_ends_with: String
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  s3Bucket: String
  s3Bucket_not: String
  s3Bucket_in: [String!]
  s3Bucket_not_in: [String!]
  s3Bucket_lt: String
  s3Bucket_lte: String
  s3Bucket_gt: String
  s3Bucket_gte: String
  s3Bucket_contains: String
  s3Bucket_not_contains: String
  s3Bucket_starts_with: String
  s3Bucket_not_starts_with: String
  s3Bucket_ends_with: String
  s3Bucket_not_ends_with: String
  s3Key: String
  s3Key_not: String
  s3Key_in: [String!]
  s3Key_not_in: [String!]
  s3Key_lt: String
  s3Key_lte: String
  s3Key_gt: String
  s3Key_gte: String
  s3Key_contains: String
  s3Key_not_contains: String
  s3Key_starts_with: String
  s3Key_not_starts_with: String
  s3Key_ends_with: String
  s3Key_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AttachmentWhereInput!]
  OR: [AttachmentWhereInput!]
  NOT: [AttachmentWhereInput!]
}

input AttachmentWhereUniqueInput {
  id: ID
}

type Bank {
  id: ID!
  name: String
  institution: String
  bsb: String
  accountNumber: String
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankConnection {
  pageInfo: PageInfo!
  edges: [BankEdge]!
  aggregate: AggregateBank!
}

input BankCreateInput {
  id: ID
  name: String
  institution: String
  bsb: String
  accountNumber: String
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type BankEdge {
  node: Bank!
  cursor: String!
}

enum BankOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  institution_ASC
  institution_DESC
  bsb_ASC
  bsb_DESC
  accountNumber_ASC
  accountNumber_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BankPreviousValues {
  id: ID!
  name: String
  institution: String
  bsb: String
  accountNumber: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankSubscriptionPayload {
  mutation: MutationType!
  node: Bank
  updatedFields: [String!]
  previousValues: BankPreviousValues
}

input BankSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BankWhereInput
  AND: [BankSubscriptionWhereInput!]
  OR: [BankSubscriptionWhereInput!]
  NOT: [BankSubscriptionWhereInput!]
}

type BankTransaction {
  id: ID!
  transactionDate: DateTime!
  amount: Float!
  description: String
  posted: Boolean!
  ledgerJournal: LedgerJournal
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankTransactionConnection {
  pageInfo: PageInfo!
  edges: [BankTransactionEdge]!
  aggregate: AggregateBankTransaction!
}

input BankTransactionCreateInput {
  id: ID
  transactionDate: DateTime!
  amount: Float!
  description: String
  posted: Boolean
  ledgerJournal: LedgerJournalCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type BankTransactionEdge {
  node: BankTransaction!
  cursor: String!
}

enum BankTransactionOrderByInput {
  id_ASC
  id_DESC
  transactionDate_ASC
  transactionDate_DESC
  amount_ASC
  amount_DESC
  description_ASC
  description_DESC
  posted_ASC
  posted_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BankTransactionPreviousValues {
  id: ID!
  transactionDate: DateTime!
  amount: Float!
  description: String
  posted: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankTransactionSubscriptionPayload {
  mutation: MutationType!
  node: BankTransaction
  updatedFields: [String!]
  previousValues: BankTransactionPreviousValues
}

input BankTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BankTransactionWhereInput
  AND: [BankTransactionSubscriptionWhereInput!]
  OR: [BankTransactionSubscriptionWhereInput!]
  NOT: [BankTransactionSubscriptionWhereInput!]
}

input BankTransactionUpdateInput {
  transactionDate: DateTime
  amount: Float
  description: String
  posted: Boolean
  ledgerJournal: LedgerJournalUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input BankTransactionUpdateManyMutationInput {
  transactionDate: DateTime
  amount: Float
  description: String
  posted: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input BankTransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  transactionDate: DateTime
  transactionDate_not: DateTime
  transactionDate_in: [DateTime!]
  transactionDate_not_in: [DateTime!]
  transactionDate_lt: DateTime
  transactionDate_lte: DateTime
  transactionDate_gt: DateTime
  transactionDate_gte: DateTime
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  posted: Boolean
  posted_not: Boolean
  ledgerJournal: LedgerJournalWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BankTransactionWhereInput!]
  OR: [BankTransactionWhereInput!]
  NOT: [BankTransactionWhereInput!]
}

input BankTransactionWhereUniqueInput {
  id: ID
}

input BankUpdateInput {
  name: String
  institution: String
  bsb: String
  accountNumber: String
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input BankUpdateManyMutationInput {
  name: String
  institution: String
  bsb: String
  accountNumber: String
  isArchived: Boolean
  isDeleted: Boolean
}

input BankWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  institution: String
  institution_not: String
  institution_in: [String!]
  institution_not_in: [String!]
  institution_lt: String
  institution_lte: String
  institution_gt: String
  institution_gte: String
  institution_contains: String
  institution_not_contains: String
  institution_starts_with: String
  institution_not_starts_with: String
  institution_ends_with: String
  institution_not_ends_with: String
  bsb: String
  bsb_not: String
  bsb_in: [String!]
  bsb_not_in: [String!]
  bsb_lt: String
  bsb_lte: String
  bsb_gt: String
  bsb_gte: String
  bsb_contains: String
  bsb_not_contains: String
  bsb_starts_with: String
  bsb_not_starts_with: String
  bsb_ends_with: String
  bsb_not_ends_with: String
  accountNumber: String
  accountNumber_not: String
  accountNumber_in: [String!]
  accountNumber_not_in: [String!]
  accountNumber_lt: String
  accountNumber_lte: String
  accountNumber_gt: String
  accountNumber_gte: String
  accountNumber_contains: String
  accountNumber_not_contains: String
  accountNumber_starts_with: String
  accountNumber_not_starts_with: String
  accountNumber_ends_with: String
  accountNumber_not_ends_with: String
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BankWhereInput!]
  OR: [BankWhereInput!]
  NOT: [BankWhereInput!]
}

input BankWhereUniqueInput {
  id: ID
}

type BasicDailyFee {
  id: ID!
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
  company: Company
}

type BasicDailyFeeConnection {
  pageInfo: PageInfo!
  edges: [BasicDailyFeeEdge]!
  aggregate: AggregateBasicDailyFee!
}

input BasicDailyFeeCreateInput {
  id: ID
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
  company: CompanyCreateOneInput
}

input BasicDailyFeeCreateManyInput {
  create: [BasicDailyFeeCreateInput!]
  connect: [BasicDailyFeeWhereUniqueInput!]
}

input BasicDailyFeeCreateOneInput {
  create: BasicDailyFeeCreateInput
  connect: BasicDailyFeeWhereUniqueInput
}

type BasicDailyFeeEdge {
  node: BasicDailyFee!
  cursor: String!
}

enum BasicDailyFeeOrderByInput {
  id_ASC
  id_DESC
  level_ASC
  level_DESC
  rate_ASC
  rate_DESC
  dateFrom_ASC
  dateFrom_DESC
  dateTo_ASC
  dateTo_DESC
  rechargeable_ASC
  rechargeable_DESC
}

type BasicDailyFeePreviousValues {
  id: ID!
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
}

input BasicDailyFeeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  level: LevelOfCare
  level_not: LevelOfCare
  level_in: [LevelOfCare!]
  level_not_in: [LevelOfCare!]
  rate: Float
  rate_not: Float
  rate_in: [Float!]
  rate_not_in: [Float!]
  rate_lt: Float
  rate_lte: Float
  rate_gt: Float
  rate_gte: Float
  dateFrom: DateTime
  dateFrom_not: DateTime
  dateFrom_in: [DateTime!]
  dateFrom_not_in: [DateTime!]
  dateFrom_lt: DateTime
  dateFrom_lte: DateTime
  dateFrom_gt: DateTime
  dateFrom_gte: DateTime
  dateTo: DateTime
  dateTo_not: DateTime
  dateTo_in: [DateTime!]
  dateTo_not_in: [DateTime!]
  dateTo_lt: DateTime
  dateTo_lte: DateTime
  dateTo_gt: DateTime
  dateTo_gte: DateTime
  rechargeable: Float
  rechargeable_not: Float
  rechargeable_in: [Float!]
  rechargeable_not_in: [Float!]
  rechargeable_lt: Float
  rechargeable_lte: Float
  rechargeable_gt: Float
  rechargeable_gte: Float
  AND: [BasicDailyFeeScalarWhereInput!]
  OR: [BasicDailyFeeScalarWhereInput!]
  NOT: [BasicDailyFeeScalarWhereInput!]
}

type BasicDailyFeeSubscriptionPayload {
  mutation: MutationType!
  node: BasicDailyFee
  updatedFields: [String!]
  previousValues: BasicDailyFeePreviousValues
}

input BasicDailyFeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BasicDailyFeeWhereInput
  AND: [BasicDailyFeeSubscriptionWhereInput!]
  OR: [BasicDailyFeeSubscriptionWhereInput!]
  NOT: [BasicDailyFeeSubscriptionWhereInput!]
}

input BasicDailyFeeUpdateDataInput {
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
  company: CompanyUpdateOneInput
}

input BasicDailyFeeUpdateInput {
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
  company: CompanyUpdateOneInput
}

input BasicDailyFeeUpdateManyDataInput {
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
}

input BasicDailyFeeUpdateManyInput {
  create: [BasicDailyFeeCreateInput!]
  update: [BasicDailyFeeUpdateWithWhereUniqueNestedInput!]
  upsert: [BasicDailyFeeUpsertWithWhereUniqueNestedInput!]
  delete: [BasicDailyFeeWhereUniqueInput!]
  connect: [BasicDailyFeeWhereUniqueInput!]
  set: [BasicDailyFeeWhereUniqueInput!]
  disconnect: [BasicDailyFeeWhereUniqueInput!]
  deleteMany: [BasicDailyFeeScalarWhereInput!]
  updateMany: [BasicDailyFeeUpdateManyWithWhereNestedInput!]
}

input BasicDailyFeeUpdateManyMutationInput {
  level: LevelOfCare
  rate: Float
  dateFrom: DateTime
  dateTo: DateTime
  rechargeable: Float
}

input BasicDailyFeeUpdateManyWithWhereNestedInput {
  where: BasicDailyFeeScalarWhereInput!
  data: BasicDailyFeeUpdateManyDataInput!
}

input BasicDailyFeeUpdateOneInput {
  create: BasicDailyFeeCreateInput
  update: BasicDailyFeeUpdateDataInput
  upsert: BasicDailyFeeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BasicDailyFeeWhereUniqueInput
}

input BasicDailyFeeUpdateWithWhereUniqueNestedInput {
  where: BasicDailyFeeWhereUniqueInput!
  data: BasicDailyFeeUpdateDataInput!
}

input BasicDailyFeeUpsertNestedInput {
  update: BasicDailyFeeUpdateDataInput!
  create: BasicDailyFeeCreateInput!
}

input BasicDailyFeeUpsertWithWhereUniqueNestedInput {
  where: BasicDailyFeeWhereUniqueInput!
  update: BasicDailyFeeUpdateDataInput!
  create: BasicDailyFeeCreateInput!
}

input BasicDailyFeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  level: LevelOfCare
  level_not: LevelOfCare
  level_in: [LevelOfCare!]
  level_not_in: [LevelOfCare!]
  rate: Float
  rate_not: Float
  rate_in: [Float!]
  rate_not_in: [Float!]
  rate_lt: Float
  rate_lte: Float
  rate_gt: Float
  rate_gte: Float
  dateFrom: DateTime
  dateFrom_not: DateTime
  dateFrom_in: [DateTime!]
  dateFrom_not_in: [DateTime!]
  dateFrom_lt: DateTime
  dateFrom_lte: DateTime
  dateFrom_gt: DateTime
  dateFrom_gte: DateTime
  dateTo: DateTime
  dateTo_not: DateTime
  dateTo_in: [DateTime!]
  dateTo_not_in: [DateTime!]
  dateTo_lt: DateTime
  dateTo_lte: DateTime
  dateTo_gt: DateTime
  dateTo_gte: DateTime
  rechargeable: Float
  rechargeable_not: Float
  rechargeable_in: [Float!]
  rechargeable_not_in: [Float!]
  rechargeable_lt: Float
  rechargeable_lte: Float
  rechargeable_gt: Float
  rechargeable_gte: Float
  company: CompanyWhereInput
  AND: [BasicDailyFeeWhereInput!]
  OR: [BasicDailyFeeWhereInput!]
  NOT: [BasicDailyFeeWhereInput!]
}

input BasicDailyFeeWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

enum BusinessType {
  HEALTH
  OTHER
}

type Company {
  id: ID!
  bankAccount: Json
  businessType: BusinessType
  country: Country!
  govNumber: String
  currency: Currency!
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String!
  logo: Attachment
  name: String!
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact!]
  companyMembers(where: CompanyMemberWhereInput, orderBy: CompanyMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CompanyMember!]
  activePlan: Plan
  stripeCustomerId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanyConnection {
  pageInfo: PageInfo!
  edges: [CompanyEdge]!
  aggregate: AggregateCompany!
}

input CompanyCreateInput {
  id: ID
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency!
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String!
  logo: AttachmentCreateOneInput
  name: String!
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressCreateManyInput
  contacts: ContactCreateManyInput
  companyMembers: CompanyMemberCreateManyWithoutCompanyInput
  activePlan: PlanCreateOneWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyCreateOneInput {
  create: CompanyCreateInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateOneWithoutActivePlanInput {
  create: CompanyCreateWithoutActivePlanInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateOneWithoutCompanyMembersInput {
  create: CompanyCreateWithoutCompanyMembersInput
  connect: CompanyWhereUniqueInput
}

input CompanyCreateWithoutActivePlanInput {
  id: ID
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency!
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String!
  logo: AttachmentCreateOneInput
  name: String!
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressCreateManyInput
  contacts: ContactCreateManyInput
  companyMembers: CompanyMemberCreateManyWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyCreateWithoutCompanyMembersInput {
  id: ID
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency!
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String!
  logo: AttachmentCreateOneInput
  name: String!
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressCreateManyInput
  contacts: ContactCreateManyInput
  activePlan: PlanCreateOneWithoutCompanyInput
  stripeCustomerId: String
}

type CompanyEdge {
  node: Company!
  cursor: String!
}

type CompanyMember {
  id: ID!
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  user: User
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanyMemberConnection {
  pageInfo: PageInfo!
  edges: [CompanyMemberEdge]!
  aggregate: AggregateCompanyMember!
}

input CompanyMemberCreateInput {
  id: ID
  company: CompanyCreateOneWithoutCompanyMembersInput!
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  user: UserCreateOneInput
}

input CompanyMemberCreateManyWithoutCompanyInput {
  create: [CompanyMemberCreateWithoutCompanyInput!]
  connect: [CompanyMemberWhereUniqueInput!]
}

input CompanyMemberCreateWithoutCompanyInput {
  id: ID
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  user: UserCreateOneInput
}

type CompanyMemberEdge {
  node: CompanyMember!
  cursor: String!
}

enum CompanyMemberOrderByInput {
  id_ASC
  id_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  role_ASC
  role_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CompanyMemberPreviousValues {
  id: ID!
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum CompanyMemberRole {
  ADMIN
  OWNER
  USER
}

input CompanyMemberScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  role: CompanyMemberRole
  role_not: CompanyMemberRole
  role_in: [CompanyMemberRole!]
  role_not_in: [CompanyMemberRole!]
  status: CompanyMemberStatus
  status_not: CompanyMemberStatus
  status_in: [CompanyMemberStatus!]
  status_not_in: [CompanyMemberStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CompanyMemberScalarWhereInput!]
  OR: [CompanyMemberScalarWhereInput!]
  NOT: [CompanyMemberScalarWhereInput!]
}

enum CompanyMemberStatus {
  ACTIVE
  PENDING
}

type CompanyMemberSubscriptionPayload {
  mutation: MutationType!
  node: CompanyMember
  updatedFields: [String!]
  previousValues: CompanyMemberPreviousValues
}

input CompanyMemberSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyMemberWhereInput
  AND: [CompanyMemberSubscriptionWhereInput!]
  OR: [CompanyMemberSubscriptionWhereInput!]
  NOT: [CompanyMemberSubscriptionWhereInput!]
}

input CompanyMemberUpdateInput {
  company: CompanyUpdateOneRequiredWithoutCompanyMembersInput
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  user: UserUpdateOneInput
}

input CompanyMemberUpdateManyDataInput {
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
}

input CompanyMemberUpdateManyMutationInput {
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
}

input CompanyMemberUpdateManyWithoutCompanyInput {
  create: [CompanyMemberCreateWithoutCompanyInput!]
  delete: [CompanyMemberWhereUniqueInput!]
  connect: [CompanyMemberWhereUniqueInput!]
  set: [CompanyMemberWhereUniqueInput!]
  disconnect: [CompanyMemberWhereUniqueInput!]
  update: [CompanyMemberUpdateWithWhereUniqueWithoutCompanyInput!]
  upsert: [CompanyMemberUpsertWithWhereUniqueWithoutCompanyInput!]
  deleteMany: [CompanyMemberScalarWhereInput!]
  updateMany: [CompanyMemberUpdateManyWithWhereNestedInput!]
}

input CompanyMemberUpdateManyWithWhereNestedInput {
  where: CompanyMemberScalarWhereInput!
  data: CompanyMemberUpdateManyDataInput!
}

input CompanyMemberUpdateWithoutCompanyDataInput {
  isArchived: Boolean
  isDeleted: Boolean
  role: CompanyMemberRole
  status: CompanyMemberStatus
  user: UserUpdateOneInput
}

input CompanyMemberUpdateWithWhereUniqueWithoutCompanyInput {
  where: CompanyMemberWhereUniqueInput!
  data: CompanyMemberUpdateWithoutCompanyDataInput!
}

input CompanyMemberUpsertWithWhereUniqueWithoutCompanyInput {
  where: CompanyMemberWhereUniqueInput!
  update: CompanyMemberUpdateWithoutCompanyDataInput!
  create: CompanyMemberCreateWithoutCompanyInput!
}

input CompanyMemberWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  role: CompanyMemberRole
  role_not: CompanyMemberRole
  role_in: [CompanyMemberRole!]
  role_not_in: [CompanyMemberRole!]
  status: CompanyMemberStatus
  status_not: CompanyMemberStatus
  status_in: [CompanyMemberStatus!]
  status_not_in: [CompanyMemberStatus!]
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CompanyMemberWhereInput!]
  OR: [CompanyMemberWhereInput!]
  NOT: [CompanyMemberWhereInput!]
}

input CompanyMemberWhereUniqueInput {
  id: ID
}

enum CompanyOrderByInput {
  id_ASC
  id_DESC
  bankAccount_ASC
  bankAccount_DESC
  businessType_ASC
  businessType_DESC
  country_ASC
  country_DESC
  govNumber_ASC
  govNumber_DESC
  currency_ASC
  currency_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  HPIO_ASC
  HPIO_DESC
  legalName_ASC
  legalName_DESC
  name_ASC
  name_DESC
  salesTax_ASC
  salesTax_DESC
  timeSheetSettings_ASC
  timeSheetSettings_DESC
  websiteURL_ASC
  websiteURL_DESC
  stripeCustomerId_ASC
  stripeCustomerId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CompanyPreviousValues {
  id: ID!
  bankAccount: Json
  businessType: BusinessType
  country: Country!
  govNumber: String
  currency: Currency!
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String!
  name: String!
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  stripeCustomerId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CompanySubscriptionPayload {
  mutation: MutationType!
  node: Company
  updatedFields: [String!]
  previousValues: CompanyPreviousValues
}

input CompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompanyWhereInput
  AND: [CompanySubscriptionWhereInput!]
  OR: [CompanySubscriptionWhereInput!]
  NOT: [CompanySubscriptionWhereInput!]
}

input CompanyUpdateDataInput {
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String
  logo: AttachmentUpdateOneInput
  name: String
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressUpdateManyInput
  contacts: ContactUpdateManyInput
  companyMembers: CompanyMemberUpdateManyWithoutCompanyInput
  activePlan: PlanUpdateOneWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyUpdateInput {
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String
  logo: AttachmentUpdateOneInput
  name: String
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressUpdateManyInput
  contacts: ContactUpdateManyInput
  companyMembers: CompanyMemberUpdateManyWithoutCompanyInput
  activePlan: PlanUpdateOneWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyUpdateManyMutationInput {
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String
  name: String
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  stripeCustomerId: String
}

input CompanyUpdateOneInput {
  create: CompanyCreateInput
  update: CompanyUpdateDataInput
  upsert: CompanyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateOneRequiredInput {
  create: CompanyCreateInput
  update: CompanyUpdateDataInput
  upsert: CompanyUpsertNestedInput
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateOneRequiredWithoutActivePlanInput {
  create: CompanyCreateWithoutActivePlanInput
  update: CompanyUpdateWithoutActivePlanDataInput
  upsert: CompanyUpsertWithoutActivePlanInput
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateOneRequiredWithoutCompanyMembersInput {
  create: CompanyCreateWithoutCompanyMembersInput
  update: CompanyUpdateWithoutCompanyMembersDataInput
  upsert: CompanyUpsertWithoutCompanyMembersInput
  connect: CompanyWhereUniqueInput
}

input CompanyUpdateWithoutActivePlanDataInput {
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String
  logo: AttachmentUpdateOneInput
  name: String
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressUpdateManyInput
  contacts: ContactUpdateManyInput
  companyMembers: CompanyMemberUpdateManyWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyUpdateWithoutCompanyMembersDataInput {
  bankAccount: Json
  businessType: BusinessType
  country: Country
  govNumber: String
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  HPIO: String
  legalName: String
  logo: AttachmentUpdateOneInput
  name: String
  salesTax: Boolean
  timeSheetSettings: Json
  websiteURL: String
  addresses: AddressUpdateManyInput
  contacts: ContactUpdateManyInput
  activePlan: PlanUpdateOneWithoutCompanyInput
  stripeCustomerId: String
}

input CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput!
  create: CompanyCreateInput!
}

input CompanyUpsertWithoutActivePlanInput {
  update: CompanyUpdateWithoutActivePlanDataInput!
  create: CompanyCreateWithoutActivePlanInput!
}

input CompanyUpsertWithoutCompanyMembersInput {
  update: CompanyUpdateWithoutCompanyMembersDataInput!
  create: CompanyCreateWithoutCompanyMembersInput!
}

input CompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  businessType: BusinessType
  businessType_not: BusinessType
  businessType_in: [BusinessType!]
  businessType_not_in: [BusinessType!]
  country: Country
  country_not: Country
  country_in: [Country!]
  country_not_in: [Country!]
  govNumber: String
  govNumber_not: String
  govNumber_in: [String!]
  govNumber_not_in: [String!]
  govNumber_lt: String
  govNumber_lte: String
  govNumber_gt: String
  govNumber_gte: String
  govNumber_contains: String
  govNumber_not_contains: String
  govNumber_starts_with: String
  govNumber_not_starts_with: String
  govNumber_ends_with: String
  govNumber_not_ends_with: String
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  HPIO: String
  HPIO_not: String
  HPIO_in: [String!]
  HPIO_not_in: [String!]
  HPIO_lt: String
  HPIO_lte: String
  HPIO_gt: String
  HPIO_gte: String
  HPIO_contains: String
  HPIO_not_contains: String
  HPIO_starts_with: String
  HPIO_not_starts_with: String
  HPIO_ends_with: String
  HPIO_not_ends_with: String
  legalName: String
  legalName_not: String
  legalName_in: [String!]
  legalName_not_in: [String!]
  legalName_lt: String
  legalName_lte: String
  legalName_gt: String
  legalName_gte: String
  legalName_contains: String
  legalName_not_contains: String
  legalName_starts_with: String
  legalName_not_starts_with: String
  legalName_ends_with: String
  legalName_not_ends_with: String
  logo: AttachmentWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  salesTax: Boolean
  salesTax_not: Boolean
  websiteURL: String
  websiteURL_not: String
  websiteURL_in: [String!]
  websiteURL_not_in: [String!]
  websiteURL_lt: String
  websiteURL_lte: String
  websiteURL_gt: String
  websiteURL_gte: String
  websiteURL_contains: String
  websiteURL_not_contains: String
  websiteURL_starts_with: String
  websiteURL_not_starts_with: String
  websiteURL_ends_with: String
  websiteURL_not_ends_with: String
  addresses_every: AddressWhereInput
  addresses_some: AddressWhereInput
  addresses_none: AddressWhereInput
  contacts_every: ContactWhereInput
  contacts_some: ContactWhereInput
  contacts_none: ContactWhereInput
  companyMembers_every: CompanyMemberWhereInput
  companyMembers_some: CompanyMemberWhereInput
  companyMembers_none: CompanyMemberWhereInput
  activePlan: PlanWhereInput
  stripeCustomerId: String
  stripeCustomerId_not: String
  stripeCustomerId_in: [String!]
  stripeCustomerId_not_in: [String!]
  stripeCustomerId_lt: String
  stripeCustomerId_lte: String
  stripeCustomerId_gt: String
  stripeCustomerId_gte: String
  stripeCustomerId_contains: String
  stripeCustomerId_not_contains: String
  stripeCustomerId_starts_with: String
  stripeCustomerId_not_starts_with: String
  stripeCustomerId_ends_with: String
  stripeCustomerId_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  NOT: [CompanyWhereInput!]
}

input CompanyWhereUniqueInput {
  id: ID
}

type Contact {
  id: ID!
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContactConnection {
  pageInfo: PageInfo!
  edges: [ContactEdge]!
  aggregate: AggregateContact!
}

input ContactCreateInput {
  id: ID
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
}

input ContactCreateManyInput {
  create: [ContactCreateInput!]
  connect: [ContactWhereUniqueInput!]
}

type ContactEdge {
  node: Contact!
  cursor: String!
}

enum ContactOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  surname_ASC
  surname_DESC
  email_ASC
  email_DESC
  mobileCode_ASC
  mobileCode_DESC
  mobileNumber_ASC
  mobileNumber_DESC
  landlineCode_ASC
  landlineCode_DESC
  landlineNumber_ASC
  landlineNumber_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContactPreviousValues {
  id: ID!
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContactScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  surname: String
  surname_not: String
  surname_in: [String!]
  surname_not_in: [String!]
  surname_lt: String
  surname_lte: String
  surname_gt: String
  surname_gte: String
  surname_contains: String
  surname_not_contains: String
  surname_starts_with: String
  surname_not_starts_with: String
  surname_ends_with: String
  surname_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobileCode: String
  mobileCode_not: String
  mobileCode_in: [String!]
  mobileCode_not_in: [String!]
  mobileCode_lt: String
  mobileCode_lte: String
  mobileCode_gt: String
  mobileCode_gte: String
  mobileCode_contains: String
  mobileCode_not_contains: String
  mobileCode_starts_with: String
  mobileCode_not_starts_with: String
  mobileCode_ends_with: String
  mobileCode_not_ends_with: String
  mobileNumber: String
  mobileNumber_not: String
  mobileNumber_in: [String!]
  mobileNumber_not_in: [String!]
  mobileNumber_lt: String
  mobileNumber_lte: String
  mobileNumber_gt: String
  mobileNumber_gte: String
  mobileNumber_contains: String
  mobileNumber_not_contains: String
  mobileNumber_starts_with: String
  mobileNumber_not_starts_with: String
  mobileNumber_ends_with: String
  mobileNumber_not_ends_with: String
  landlineCode: String
  landlineCode_not: String
  landlineCode_in: [String!]
  landlineCode_not_in: [String!]
  landlineCode_lt: String
  landlineCode_lte: String
  landlineCode_gt: String
  landlineCode_gte: String
  landlineCode_contains: String
  landlineCode_not_contains: String
  landlineCode_starts_with: String
  landlineCode_not_starts_with: String
  landlineCode_ends_with: String
  landlineCode_not_ends_with: String
  landlineNumber: String
  landlineNumber_not: String
  landlineNumber_in: [String!]
  landlineNumber_not_in: [String!]
  landlineNumber_lt: String
  landlineNumber_lte: String
  landlineNumber_gt: String
  landlineNumber_gte: String
  landlineNumber_contains: String
  landlineNumber_not_contains: String
  landlineNumber_starts_with: String
  landlineNumber_not_starts_with: String
  landlineNumber_ends_with: String
  landlineNumber_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContactScalarWhereInput!]
  OR: [ContactScalarWhereInput!]
  NOT: [ContactScalarWhereInput!]
}

type ContactSubscriptionPayload {
  mutation: MutationType!
  node: Contact
  updatedFields: [String!]
  previousValues: ContactPreviousValues
}

input ContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactWhereInput
  AND: [ContactSubscriptionWhereInput!]
  OR: [ContactSubscriptionWhereInput!]
  NOT: [ContactSubscriptionWhereInput!]
}

input ContactUpdateDataInput {
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
}

input ContactUpdateInput {
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
}

input ContactUpdateManyDataInput {
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
}

input ContactUpdateManyInput {
  create: [ContactCreateInput!]
  update: [ContactUpdateWithWhereUniqueNestedInput!]
  upsert: [ContactUpsertWithWhereUniqueNestedInput!]
  delete: [ContactWhereUniqueInput!]
  connect: [ContactWhereUniqueInput!]
  set: [ContactWhereUniqueInput!]
  disconnect: [ContactWhereUniqueInput!]
  deleteMany: [ContactScalarWhereInput!]
  updateMany: [ContactUpdateManyWithWhereNestedInput!]
}

input ContactUpdateManyMutationInput {
  name: String
  surname: String
  email: String
  mobileCode: String
  mobileNumber: String
  landlineCode: String
  landlineNumber: String
}

input ContactUpdateManyWithWhereNestedInput {
  where: ContactScalarWhereInput!
  data: ContactUpdateManyDataInput!
}

input ContactUpdateWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput!
  data: ContactUpdateDataInput!
}

input ContactUpsertWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput!
  update: ContactUpdateDataInput!
  create: ContactCreateInput!
}

input ContactWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  surname: String
  surname_not: String
  surname_in: [String!]
  surname_not_in: [String!]
  surname_lt: String
  surname_lte: String
  surname_gt: String
  surname_gte: String
  surname_contains: String
  surname_not_contains: String
  surname_starts_with: String
  surname_not_starts_with: String
  surname_ends_with: String
  surname_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  mobileCode: String
  mobileCode_not: String
  mobileCode_in: [String!]
  mobileCode_not_in: [String!]
  mobileCode_lt: String
  mobileCode_lte: String
  mobileCode_gt: String
  mobileCode_gte: String
  mobileCode_contains: String
  mobileCode_not_contains: String
  mobileCode_starts_with: String
  mobileCode_not_starts_with: String
  mobileCode_ends_with: String
  mobileCode_not_ends_with: String
  mobileNumber: String
  mobileNumber_not: String
  mobileNumber_in: [String!]
  mobileNumber_not_in: [String!]
  mobileNumber_lt: String
  mobileNumber_lte: String
  mobileNumber_gt: String
  mobileNumber_gte: String
  mobileNumber_contains: String
  mobileNumber_not_contains: String
  mobileNumber_starts_with: String
  mobileNumber_not_starts_with: String
  mobileNumber_ends_with: String
  mobileNumber_not_ends_with: String
  landlineCode: String
  landlineCode_not: String
  landlineCode_in: [String!]
  landlineCode_not_in: [String!]
  landlineCode_lt: String
  landlineCode_lte: String
  landlineCode_gt: String
  landlineCode_gte: String
  landlineCode_contains: String
  landlineCode_not_contains: String
  landlineCode_starts_with: String
  landlineCode_not_starts_with: String
  landlineCode_ends_with: String
  landlineCode_not_ends_with: String
  landlineNumber: String
  landlineNumber_not: String
  landlineNumber_in: [String!]
  landlineNumber_not_in: [String!]
  landlineNumber_lt: String
  landlineNumber_lte: String
  landlineNumber_gt: String
  landlineNumber_gte: String
  landlineNumber_contains: String
  landlineNumber_not_contains: String
  landlineNumber_starts_with: String
  landlineNumber_not_starts_with: String
  landlineNumber_ends_with: String
  landlineNumber_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
}

input ContactWhereUniqueInput {
  id: ID
}

enum Country {
  AD
  AE
  AF
  AG
  AI
  AL
  AM
  AO
  AR
  AS
  AT
  AU
  AW
  AX
  AZ
  BA
  BB
  BD
  BE
  BF
  BG
  BH
  BI
  BJ
  BL
  BM
  BN
  BO
  BQ
  BR
  BS
  BT
  BV
  BW
  BY
  BZ
  CA
  CC
  CD
  CF
  CG
  CH
  CI
  CK
  CL
  CM
  CN
  CO
  CR
  CU
  CV
  CW
  CX
  CY
  CZ
  DE
  DJ
  DK
  DM
  DO
  DZ
  EA
  EC
  EE
  EG
  EH
  ER
  ES
  ET
  FI
  FJ
  FK
  FM
  FO
  FR
  GA
  GB
  GD
  GE
  GF
  GG
  GH
  GI
  GL
  GM
  GN
  GP
  GQ
  GR
  GS
  GT
  GU
  GW
  GY
  HK
  HM
  HN
  HR
  HT
  HU
  IC
  ID
  IE
  IL
  IM
  IN
  IO
  IQ
  IR
  IS
  IT
  JE
  JM
  JO
  JP
  KE
  KG
  KH
  KI
  KM
  KN
  KP
  KR
  KW
  KY
  KZ
  LA
  LB
  LC
  LI
  LK
  LR
  LS
  LT
  LU
  LV
  LY
  MA
  MC
  MD
  ME
  MF
  MG
  MH
  MK
  ML
  MM
  MN
  MO
  MP
  MQ
  MR
  MS
  MT
  MU
  MV
  MW
  MX
  MY
  MZ
  NA
  NC
  NE
  NF
  NG
  NI
  NL
  NO
  NP
  NR
  NU
  NZ
  OM
  PA
  PE
  PF
  PG
  PH
  PK
  PL
  PM
  PN
  PR
  PS
  PT
  PW
  PY
  QA
  RE
  RO
  RS
  RU
  RW
  SA
  SB
  SC
  SD
  SE
  SG
  SH
  SI
  SJ
  SK
  SL
  SM
  SN
  SO
  SR
  SS
  ST
  SV
  SX
  SY
  SZ
  TC
  TD
  TF
  TG
  TH
  TJ
  TK
  TL
  TM
  TN
  TO
  TR
  TT
  TV
  TW
  TZ
  UA
  UG
  UM
  US
  UY
  UZ
  VA
  VC
  VE
  VG
  VI
  VN
  VU
  WF
  WS
  XK
  YE
  YT
  ZA
  ZM
  ZW
}

enum Currency {
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BRL
  BSD
  BTN
  BWP
  BYR
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GGP
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  IMP
  INR
  IQD
  IRR
  ISK
  JEP
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRO
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLL
  SOS
  SPL
  SRD
  STD
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TVD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UZS
  VEF
  VND
  VUV
  WST
  XAF
  XCD
  XDR
  XOF
  XPF
  YER
  ZAR
  ZMW
}

type Customer {
  id: ID!
  company: Company!
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
  meansTestedFee: MeansTestedFee
  basicDailyFee: BasicDailyFee
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact!]
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  company: CompanyCreateOneInput!
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
  meansTestedFee: MeansTestedFeeCreateOneInput
  basicDailyFee: BasicDailyFeeCreateOneInput
  contacts: ContactCreateManyInput
  addresses: AddressCreateManyInput
}

input CustomerCreateOneInput {
  create: CustomerCreateInput
  connect: CustomerWhereUniqueInput
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  govNumber_ASC
  govNumber_DESC
  salesTax_ASC
  salesTax_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  name_ASC
  name_DESC
  billingFrequency_ASC
  billingFrequency_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerPreviousValues {
  id: ID!
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateDataInput {
  company: CompanyUpdateOneRequiredInput
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
  meansTestedFee: MeansTestedFeeUpdateOneInput
  basicDailyFee: BasicDailyFeeUpdateOneInput
  contacts: ContactUpdateManyInput
  addresses: AddressUpdateManyInput
}

input CustomerUpdateInput {
  company: CompanyUpdateOneRequiredInput
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
  meansTestedFee: MeansTestedFeeUpdateOneInput
  basicDailyFee: BasicDailyFeeUpdateOneInput
  contacts: ContactUpdateManyInput
  addresses: AddressUpdateManyInput
}

input CustomerUpdateManyMutationInput {
  description: String
  govNumber: String
  salesTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  billingFrequency: SupplierTermsOfPayment
}

input CustomerUpdateOneInput {
  create: CustomerCreateInput
  update: CustomerUpdateDataInput
  upsert: CustomerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerWhereUniqueInput
}

input CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput!
  create: CustomerCreateInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  company: CompanyWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  govNumber: String
  govNumber_not: String
  govNumber_in: [String!]
  govNumber_not_in: [String!]
  govNumber_lt: String
  govNumber_lte: String
  govNumber_gt: String
  govNumber_gte: String
  govNumber_contains: String
  govNumber_not_contains: String
  govNumber_starts_with: String
  govNumber_not_starts_with: String
  govNumber_ends_with: String
  govNumber_not_ends_with: String
  salesTax: Boolean
  salesTax_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  billingFrequency: SupplierTermsOfPayment
  billingFrequency_not: SupplierTermsOfPayment
  billingFrequency_in: [SupplierTermsOfPayment!]
  billingFrequency_not_in: [SupplierTermsOfPayment!]
  meansTestedFee: MeansTestedFeeWhereInput
  basicDailyFee: BasicDailyFeeWhereInput
  contacts_every: ContactWhereInput
  contacts_some: ContactWhereInput
  contacts_none: ContactWhereInput
  addresses_every: AddressWhereInput
  addresses_some: AddressWhereInput
  addresses_none: AddressWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
}

scalar DateTime

type Disease {
  id: ID!
  name: String
}

type DiseaseConnection {
  pageInfo: PageInfo!
  edges: [DiseaseEdge]!
  aggregate: AggregateDisease!
}

input DiseaseCreateInput {
  id: ID
  name: String
}

input DiseaseCreateOneInput {
  create: DiseaseCreateInput
  connect: DiseaseWhereUniqueInput
}

type DiseaseEdge {
  node: Disease!
  cursor: String!
}

enum DiseaseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type DiseasePreviousValues {
  id: ID!
  name: String
}

type DiseaseSubscriptionPayload {
  mutation: MutationType!
  node: Disease
  updatedFields: [String!]
  previousValues: DiseasePreviousValues
}

input DiseaseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiseaseWhereInput
  AND: [DiseaseSubscriptionWhereInput!]
  OR: [DiseaseSubscriptionWhereInput!]
  NOT: [DiseaseSubscriptionWhereInput!]
}

input DiseaseUpdateDataInput {
  name: String
}

input DiseaseUpdateInput {
  name: String
}

input DiseaseUpdateManyMutationInput {
  name: String
}

input DiseaseUpdateOneInput {
  create: DiseaseCreateInput
  update: DiseaseUpdateDataInput
  upsert: DiseaseUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DiseaseWhereUniqueInput
}

input DiseaseUpsertNestedInput {
  update: DiseaseUpdateDataInput!
  create: DiseaseCreateInput!
}

input DiseaseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [DiseaseWhereInput!]
  OR: [DiseaseWhereInput!]
  NOT: [DiseaseWhereInput!]
}

input DiseaseWhereUniqueInput {
  id: ID
}

enum DrCr {
  DEBIT
  CREDIT
}

enum DVACardType {
  GOLD
  WHITE
  ORANGE
}

enum Gender {
  MALE
  FEMALE
  INTERSEX
  UNSPECIFIED
}

type HealthcareProvider {
  id: ID!
  occupation: String
  hpii: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  emailAddress: String
  gender: Gender
  address: Address
  company: Company
  ahpraNumber: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HealthcareProviderConnection {
  pageInfo: PageInfo!
  edges: [HealthcareProviderEdge]!
  aggregate: AggregateHealthcareProvider!
}

input HealthcareProviderCreateInput {
  id: ID
  occupation: String
  hpii: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  emailAddress: String
  gender: Gender
  address: AddressCreateOneInput
  company: CompanyCreateOneInput
  ahpraNumber: String
  isArchived: Boolean
  isDeleted: Boolean
}

type HealthcareProviderEdge {
  node: HealthcareProvider!
  cursor: String!
}

enum HealthcareProviderOrderByInput {
  id_ASC
  id_DESC
  occupation_ASC
  occupation_DESC
  hpii_ASC
  hpii_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  emailAddress_ASC
  emailAddress_DESC
  gender_ASC
  gender_DESC
  ahpraNumber_ASC
  ahpraNumber_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HealthcareProviderPreviousValues {
  id: ID!
  occupation: String
  hpii: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  emailAddress: String
  gender: Gender
  ahpraNumber: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HealthcareProviderSubscriptionPayload {
  mutation: MutationType!
  node: HealthcareProvider
  updatedFields: [String!]
  previousValues: HealthcareProviderPreviousValues
}

input HealthcareProviderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HealthcareProviderWhereInput
  AND: [HealthcareProviderSubscriptionWhereInput!]
  OR: [HealthcareProviderSubscriptionWhereInput!]
  NOT: [HealthcareProviderSubscriptionWhereInput!]
}

input HealthcareProviderUpdateInput {
  occupation: String
  hpii: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  emailAddress: String
  gender: Gender
  address: AddressUpdateOneInput
  company: CompanyUpdateOneInput
  ahpraNumber: String
  isArchived: Boolean
  isDeleted: Boolean
}

input HealthcareProviderUpdateManyMutationInput {
  occupation: String
  hpii: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  emailAddress: String
  gender: Gender
  ahpraNumber: String
  isArchived: Boolean
  isDeleted: Boolean
}

input HealthcareProviderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  occupation: String
  occupation_not: String
  occupation_in: [String!]
  occupation_not_in: [String!]
  occupation_lt: String
  occupation_lte: String
  occupation_gt: String
  occupation_gte: String
  occupation_contains: String
  occupation_not_contains: String
  occupation_starts_with: String
  occupation_not_starts_with: String
  occupation_ends_with: String
  occupation_not_ends_with: String
  hpii: String
  hpii_not: String
  hpii_in: [String!]
  hpii_not_in: [String!]
  hpii_lt: String
  hpii_lte: String
  hpii_gt: String
  hpii_gte: String
  hpii_contains: String
  hpii_not_contains: String
  hpii_starts_with: String
  hpii_not_starts_with: String
  hpii_ends_with: String
  hpii_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  emailAddress: String
  emailAddress_not: String
  emailAddress_in: [String!]
  emailAddress_not_in: [String!]
  emailAddress_lt: String
  emailAddress_lte: String
  emailAddress_gt: String
  emailAddress_gte: String
  emailAddress_contains: String
  emailAddress_not_contains: String
  emailAddress_starts_with: String
  emailAddress_not_starts_with: String
  emailAddress_ends_with: String
  emailAddress_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  address: AddressWhereInput
  company: CompanyWhereInput
  ahpraNumber: String
  ahpraNumber_not: String
  ahpraNumber_in: [String!]
  ahpraNumber_not_in: [String!]
  ahpraNumber_lt: String
  ahpraNumber_lte: String
  ahpraNumber_gt: String
  ahpraNumber_gte: String
  ahpraNumber_contains: String
  ahpraNumber_not_contains: String
  ahpraNumber_starts_with: String
  ahpraNumber_not_starts_with: String
  ahpraNumber_ends_with: String
  ahpraNumber_not_ends_with: String
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HealthcareProviderWhereInput!]
  OR: [HealthcareProviderWhereInput!]
  NOT: [HealthcareProviderWhereInput!]
}

input HealthcareProviderWhereUniqueInput {
  id: ID
}

type HILog {
  id: ID!
  hpio: String
  hpii: String
  ihi: String
  timeWaitedForSalus: Int
  csp: String
  hiWebServiceUsed: String
  hiWebServiceVersion: String
  hiNumberStatus: HINumberStatus
  recordStatus: String
  salusResponse: SalusResponse
  failureMessage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HILogConnection {
  pageInfo: PageInfo!
  edges: [HILogEdge]!
  aggregate: AggregateHILog!
}

input HILogCreateInput {
  id: ID
  hpio: String
  hpii: String
  ihi: String
  timeWaitedForSalus: Int
  csp: String
  hiWebServiceUsed: String
  hiWebServiceVersion: String
  hiNumberStatus: HINumberStatus
  recordStatus: String
  salusResponse: SalusResponse
  failureMessage: String
}

type HILogEdge {
  node: HILog!
  cursor: String!
}

enum HILogOrderByInput {
  id_ASC
  id_DESC
  hpio_ASC
  hpio_DESC
  hpii_ASC
  hpii_DESC
  ihi_ASC
  ihi_DESC
  timeWaitedForSalus_ASC
  timeWaitedForSalus_DESC
  csp_ASC
  csp_DESC
  hiWebServiceUsed_ASC
  hiWebServiceUsed_DESC
  hiWebServiceVersion_ASC
  hiWebServiceVersion_DESC
  hiNumberStatus_ASC
  hiNumberStatus_DESC
  recordStatus_ASC
  recordStatus_DESC
  salusResponse_ASC
  salusResponse_DESC
  failureMessage_ASC
  failureMessage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HILogPreviousValues {
  id: ID!
  hpio: String
  hpii: String
  ihi: String
  timeWaitedForSalus: Int
  csp: String
  hiWebServiceUsed: String
  hiWebServiceVersion: String
  hiNumberStatus: HINumberStatus
  recordStatus: String
  salusResponse: SalusResponse
  failureMessage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HILogSubscriptionPayload {
  mutation: MutationType!
  node: HILog
  updatedFields: [String!]
  previousValues: HILogPreviousValues
}

input HILogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HILogWhereInput
  AND: [HILogSubscriptionWhereInput!]
  OR: [HILogSubscriptionWhereInput!]
  NOT: [HILogSubscriptionWhereInput!]
}

input HILogUpdateInput {
  hpio: String
  hpii: String
  ihi: String
  timeWaitedForSalus: Int
  csp: String
  hiWebServiceUsed: String
  hiWebServiceVersion: String
  hiNumberStatus: HINumberStatus
  recordStatus: String
  salusResponse: SalusResponse
  failureMessage: String
}

input HILogUpdateManyMutationInput {
  hpio: String
  hpii: String
  ihi: String
  timeWaitedForSalus: Int
  csp: String
  hiWebServiceUsed: String
  hiWebServiceVersion: String
  hiNumberStatus: HINumberStatus
  recordStatus: String
  salusResponse: SalusResponse
  failureMessage: String
}

input HILogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  hpio: String
  hpio_not: String
  hpio_in: [String!]
  hpio_not_in: [String!]
  hpio_lt: String
  hpio_lte: String
  hpio_gt: String
  hpio_gte: String
  hpio_contains: String
  hpio_not_contains: String
  hpio_starts_with: String
  hpio_not_starts_with: String
  hpio_ends_with: String
  hpio_not_ends_with: String
  hpii: String
  hpii_not: String
  hpii_in: [String!]
  hpii_not_in: [String!]
  hpii_lt: String
  hpii_lte: String
  hpii_gt: String
  hpii_gte: String
  hpii_contains: String
  hpii_not_contains: String
  hpii_starts_with: String
  hpii_not_starts_with: String
  hpii_ends_with: String
  hpii_not_ends_with: String
  ihi: String
  ihi_not: String
  ihi_in: [String!]
  ihi_not_in: [String!]
  ihi_lt: String
  ihi_lte: String
  ihi_gt: String
  ihi_gte: String
  ihi_contains: String
  ihi_not_contains: String
  ihi_starts_with: String
  ihi_not_starts_with: String
  ihi_ends_with: String
  ihi_not_ends_with: String
  timeWaitedForSalus: Int
  timeWaitedForSalus_not: Int
  timeWaitedForSalus_in: [Int!]
  timeWaitedForSalus_not_in: [Int!]
  timeWaitedForSalus_lt: Int
  timeWaitedForSalus_lte: Int
  timeWaitedForSalus_gt: Int
  timeWaitedForSalus_gte: Int
  csp: String
  csp_not: String
  csp_in: [String!]
  csp_not_in: [String!]
  csp_lt: String
  csp_lte: String
  csp_gt: String
  csp_gte: String
  csp_contains: String
  csp_not_contains: String
  csp_starts_with: String
  csp_not_starts_with: String
  csp_ends_with: String
  csp_not_ends_with: String
  hiWebServiceUsed: String
  hiWebServiceUsed_not: String
  hiWebServiceUsed_in: [String!]
  hiWebServiceUsed_not_in: [String!]
  hiWebServiceUsed_lt: String
  hiWebServiceUsed_lte: String
  hiWebServiceUsed_gt: String
  hiWebServiceUsed_gte: String
  hiWebServiceUsed_contains: String
  hiWebServiceUsed_not_contains: String
  hiWebServiceUsed_starts_with: String
  hiWebServiceUsed_not_starts_with: String
  hiWebServiceUsed_ends_with: String
  hiWebServiceUsed_not_ends_with: String
  hiWebServiceVersion: String
  hiWebServiceVersion_not: String
  hiWebServiceVersion_in: [String!]
  hiWebServiceVersion_not_in: [String!]
  hiWebServiceVersion_lt: String
  hiWebServiceVersion_lte: String
  hiWebServiceVersion_gt: String
  hiWebServiceVersion_gte: String
  hiWebServiceVersion_contains: String
  hiWebServiceVersion_not_contains: String
  hiWebServiceVersion_starts_with: String
  hiWebServiceVersion_not_starts_with: String
  hiWebServiceVersion_ends_with: String
  hiWebServiceVersion_not_ends_with: String
  hiNumberStatus: HINumberStatus
  hiNumberStatus_not: HINumberStatus
  hiNumberStatus_in: [HINumberStatus!]
  hiNumberStatus_not_in: [HINumberStatus!]
  recordStatus: String
  recordStatus_not: String
  recordStatus_in: [String!]
  recordStatus_not_in: [String!]
  recordStatus_lt: String
  recordStatus_lte: String
  recordStatus_gt: String
  recordStatus_gte: String
  recordStatus_contains: String
  recordStatus_not_contains: String
  recordStatus_starts_with: String
  recordStatus_not_starts_with: String
  recordStatus_ends_with: String
  recordStatus_not_ends_with: String
  salusResponse: SalusResponse
  salusResponse_not: SalusResponse
  salusResponse_in: [SalusResponse!]
  salusResponse_not_in: [SalusResponse!]
  failureMessage: String
  failureMessage_not: String
  failureMessage_in: [String!]
  failureMessage_not_in: [String!]
  failureMessage_lt: String
  failureMessage_lte: String
  failureMessage_gt: String
  failureMessage_gte: String
  failureMessage_contains: String
  failureMessage_not_contains: String
  failureMessage_starts_with: String
  failureMessage_not_starts_with: String
  failureMessage_ends_with: String
  failureMessage_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HILogWhereInput!]
  OR: [HILogWhereInput!]
  NOT: [HILogWhereInput!]
}

input HILogWhereUniqueInput {
  id: ID
}

enum HINumberStatus {
  ACTIVE
  RETIRED
  RESOLVED
  DEACTIVATED
}

type ImmunisationSchedule {
  id: ID!
  ageNumber: Int
  agePeriod: PeriodUnit
  disease: Disease
  vaccineBrand: VaccineBrand
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImmunisationScheduleConnection {
  pageInfo: PageInfo!
  edges: [ImmunisationScheduleEdge]!
  aggregate: AggregateImmunisationSchedule!
}

input ImmunisationScheduleCreateInput {
  id: ID
  ageNumber: Int
  agePeriod: PeriodUnit
  disease: DiseaseCreateOneInput
  vaccineBrand: VaccineBrandCreateOneInput
}

type ImmunisationScheduleEdge {
  node: ImmunisationSchedule!
  cursor: String!
}

enum ImmunisationScheduleOrderByInput {
  id_ASC
  id_DESC
  ageNumber_ASC
  ageNumber_DESC
  agePeriod_ASC
  agePeriod_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ImmunisationSchedulePreviousValues {
  id: ID!
  ageNumber: Int
  agePeriod: PeriodUnit
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ImmunisationScheduleSubscriptionPayload {
  mutation: MutationType!
  node: ImmunisationSchedule
  updatedFields: [String!]
  previousValues: ImmunisationSchedulePreviousValues
}

input ImmunisationScheduleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImmunisationScheduleWhereInput
  AND: [ImmunisationScheduleSubscriptionWhereInput!]
  OR: [ImmunisationScheduleSubscriptionWhereInput!]
  NOT: [ImmunisationScheduleSubscriptionWhereInput!]
}

input ImmunisationScheduleUpdateInput {
  ageNumber: Int
  agePeriod: PeriodUnit
  disease: DiseaseUpdateOneInput
  vaccineBrand: VaccineBrandUpdateOneInput
}

input ImmunisationScheduleUpdateManyMutationInput {
  ageNumber: Int
  agePeriod: PeriodUnit
}

input ImmunisationScheduleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ageNumber: Int
  ageNumber_not: Int
  ageNumber_in: [Int!]
  ageNumber_not_in: [Int!]
  ageNumber_lt: Int
  ageNumber_lte: Int
  ageNumber_gt: Int
  ageNumber_gte: Int
  agePeriod: PeriodUnit
  agePeriod_not: PeriodUnit
  agePeriod_in: [PeriodUnit!]
  agePeriod_not_in: [PeriodUnit!]
  disease: DiseaseWhereInput
  vaccineBrand: VaccineBrandWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ImmunisationScheduleWhereInput!]
  OR: [ImmunisationScheduleWhereInput!]
  NOT: [ImmunisationScheduleWhereInput!]
}

input ImmunisationScheduleWhereUniqueInput {
  id: ID
}

type Integration {
  id: ID!
  company: Company!
  data: Json
  type: IntegrationType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IntegrationConnection {
  pageInfo: PageInfo!
  edges: [IntegrationEdge]!
  aggregate: AggregateIntegration!
}

input IntegrationCreateInput {
  id: ID
  company: CompanyCreateOneInput!
  data: Json
  type: IntegrationType
}

type IntegrationEdge {
  node: Integration!
  cursor: String!
}

enum IntegrationOrderByInput {
  id_ASC
  id_DESC
  data_ASC
  data_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type IntegrationPreviousValues {
  id: ID!
  data: Json
  type: IntegrationType
  createdAt: DateTime!
  updatedAt: DateTime!
}

type IntegrationSubscriptionPayload {
  mutation: MutationType!
  node: Integration
  updatedFields: [String!]
  previousValues: IntegrationPreviousValues
}

input IntegrationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IntegrationWhereInput
  AND: [IntegrationSubscriptionWhereInput!]
  OR: [IntegrationSubscriptionWhereInput!]
  NOT: [IntegrationSubscriptionWhereInput!]
}

enum IntegrationType {
  SLACK
}

input IntegrationUpdateInput {
  company: CompanyUpdateOneRequiredInput
  data: Json
  type: IntegrationType
}

input IntegrationUpdateManyMutationInput {
  data: Json
  type: IntegrationType
}

input IntegrationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  company: CompanyWhereInput
  type: IntegrationType
  type_not: IntegrationType
  type_in: [IntegrationType!]
  type_not_in: [IntegrationType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [IntegrationWhereInput!]
  OR: [IntegrationWhereInput!]
  NOT: [IntegrationWhereInput!]
}

input IntegrationWhereUniqueInput {
  id: ID
}

type Inventory {
  id: ID!
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryCreateOneInput {
  create: InventoryCreateInput
  connect: InventoryWhereUniqueInput
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryModel {
  FIFO
  LIFO
  WEIGHTED_AVERAGE
}

type InventoryOnHand {
  id: ID!
  date: DateTime
  item: Inventory
  pbsDrug: String
  onHandQty: Int
  purchaseOrder: PurchaseOrder
  warehouse: WareHouse
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryOnHandConnection {
  pageInfo: PageInfo!
  edges: [InventoryOnHandEdge]!
  aggregate: AggregateInventoryOnHand!
}

input InventoryOnHandCreateInput {
  id: ID
  date: DateTime
  item: InventoryCreateOneInput
  pbsDrug: String
  onHandQty: Int
  purchaseOrder: PurchaseOrderCreateOneInput
  warehouse: WareHouseCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type InventoryOnHandEdge {
  node: InventoryOnHand!
  cursor: String!
}

enum InventoryOnHandOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  pbsDrug_ASC
  pbsDrug_DESC
  onHandQty_ASC
  onHandQty_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryOnHandPreviousValues {
  id: ID!
  date: DateTime
  pbsDrug: String
  onHandQty: Int
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventoryOnHandSubscriptionPayload {
  mutation: MutationType!
  node: InventoryOnHand
  updatedFields: [String!]
  previousValues: InventoryOnHandPreviousValues
}

input InventoryOnHandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryOnHandWhereInput
  AND: [InventoryOnHandSubscriptionWhereInput!]
  OR: [InventoryOnHandSubscriptionWhereInput!]
  NOT: [InventoryOnHandSubscriptionWhereInput!]
}

input InventoryOnHandUpdateInput {
  date: DateTime
  item: InventoryUpdateOneInput
  pbsDrug: String
  onHandQty: Int
  purchaseOrder: PurchaseOrderUpdateOneInput
  warehouse: WareHouseUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryOnHandUpdateManyMutationInput {
  date: DateTime
  pbsDrug: String
  onHandQty: Int
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryOnHandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  item: InventoryWhereInput
  pbsDrug: String
  pbsDrug_not: String
  pbsDrug_in: [String!]
  pbsDrug_not_in: [String!]
  pbsDrug_lt: String
  pbsDrug_lte: String
  pbsDrug_gt: String
  pbsDrug_gte: String
  pbsDrug_contains: String
  pbsDrug_not_contains: String
  pbsDrug_starts_with: String
  pbsDrug_not_starts_with: String
  pbsDrug_ends_with: String
  pbsDrug_not_ends_with: String
  onHandQty: Int
  onHandQty_not: Int
  onHandQty_in: [Int!]
  onHandQty_not_in: [Int!]
  onHandQty_lt: Int
  onHandQty_lte: Int
  onHandQty_gt: Int
  onHandQty_gte: Int
  purchaseOrder: PurchaseOrderWhereInput
  warehouse: WareHouseWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryOnHandWhereInput!]
  OR: [InventoryOnHandWhereInput!]
  NOT: [InventoryOnHandWhereInput!]
}

input InventoryOnHandWhereUniqueInput {
  id: ID
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  inventoryModel_ASC
  inventoryModel_DESC
  uom_ASC
  uom_DESC
  price_ASC
  price_DESC
  SellingPrice_ASC
  SellingPrice_DESC
  Barcode_ASC
  Barcode_DESC
  Taxable_ASC
  Taxable_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryPreviousValues {
  id: ID!
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

input InventoryUpdateDataInput {
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryUpdateInput {
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryUpdateManyMutationInput {
  name: String
  inventoryModel: InventoryModel
  uom: UOM
  price: Float
  SellingPrice: Float
  Barcode: String
  Taxable: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input InventoryUpdateOneInput {
  create: InventoryCreateInput
  update: InventoryUpdateDataInput
  upsert: InventoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: InventoryWhereUniqueInput
}

input InventoryUpsertNestedInput {
  update: InventoryUpdateDataInput!
  create: InventoryCreateInput!
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  inventoryModel: InventoryModel
  inventoryModel_not: InventoryModel
  inventoryModel_in: [InventoryModel!]
  inventoryModel_not_in: [InventoryModel!]
  uom: UOM
  uom_not: UOM
  uom_in: [UOM!]
  uom_not_in: [UOM!]
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  SellingPrice: Float
  SellingPrice_not: Float
  SellingPrice_in: [Float!]
  SellingPrice_not_in: [Float!]
  SellingPrice_lt: Float
  SellingPrice_lte: Float
  SellingPrice_gt: Float
  SellingPrice_gte: Float
  Barcode: String
  Barcode_not: String
  Barcode_in: [String!]
  Barcode_not_in: [String!]
  Barcode_lt: String
  Barcode_lte: String
  Barcode_gt: String
  Barcode_gte: String
  Barcode_contains: String
  Barcode_not_contains: String
  Barcode_starts_with: String
  Barcode_not_starts_with: String
  Barcode_ends_with: String
  Barcode_not_ends_with: String
  Taxable: Boolean
  Taxable_not: Boolean
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

type Invoice {
  id: ID!
  title: String
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  buyer: Customer
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  preview: Attachment
  items(where: InvoiceItemEntryWhereInput, orderBy: InvoiceItemEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InvoiceItemEntry!]
  seller: Company!
  status: InvoiceStatus
  type: InvoiceType
  total: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InvoiceConnection {
  pageInfo: PageInfo!
  edges: [InvoiceEdge]!
  aggregate: AggregateInvoice!
}

input InvoiceCreateInput {
  id: ID
  title: String
  attachments: AttachmentCreateManyInput
  buyer: CustomerCreateOneInput
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  preview: AttachmentCreateOneInput
  items: InvoiceItemEntryCreateManyWithoutInvoiceInput
  seller: CompanyCreateOneInput!
  status: InvoiceStatus
  type: InvoiceType
  total: Float
}

input InvoiceCreateOneWithoutItemsInput {
  create: InvoiceCreateWithoutItemsInput
  connect: InvoiceWhereUniqueInput
}

input InvoiceCreateWithoutItemsInput {
  id: ID
  title: String
  attachments: AttachmentCreateManyInput
  buyer: CustomerCreateOneInput
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  preview: AttachmentCreateOneInput
  seller: CompanyCreateOneInput!
  status: InvoiceStatus
  type: InvoiceType
  total: Float
}

type InvoiceEdge {
  node: Invoice!
  cursor: String!
}

type InvoiceItemEntry {
  id: ID!
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  invoice: Invoice
  project: Project
  service: Service
  timeSheetEntry: TimeSheetEntry
  timeSheet: TimeSheet
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InvoiceItemEntryConnection {
  pageInfo: PageInfo!
  edges: [InvoiceItemEntryEdge]!
  aggregate: AggregateInvoiceItemEntry!
}

input InvoiceItemEntryCreateInput {
  id: ID
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  invoice: InvoiceCreateOneWithoutItemsInput
  project: ProjectCreateOneInput
  service: ServiceCreateOneInput
  timeSheetEntry: TimeSheetEntryCreateOneInput
  timeSheet: TimeSheetCreateOneInput
}

input InvoiceItemEntryCreateManyWithoutInvoiceInput {
  create: [InvoiceItemEntryCreateWithoutInvoiceInput!]
  connect: [InvoiceItemEntryWhereUniqueInput!]
}

input InvoiceItemEntryCreateWithoutInvoiceInput {
  id: ID
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  project: ProjectCreateOneInput
  service: ServiceCreateOneInput
  timeSheetEntry: TimeSheetEntryCreateOneInput
  timeSheet: TimeSheetCreateOneInput
}

type InvoiceItemEntryEdge {
  node: InvoiceItemEntry!
  cursor: String!
}

enum InvoiceItemEntryOrderByInput {
  id_ASC
  id_DESC
  order_ASC
  order_DESC
  description_ASC
  description_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  quantity_ASC
  quantity_DESC
  tax_ASC
  tax_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InvoiceItemEntryPreviousValues {
  id: ID!
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InvoiceItemEntryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  tax: Float
  tax_not: Float
  tax_in: [Float!]
  tax_not_in: [Float!]
  tax_lt: Float
  tax_lte: Float
  tax_gt: Float
  tax_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceItemEntryScalarWhereInput!]
  OR: [InvoiceItemEntryScalarWhereInput!]
  NOT: [InvoiceItemEntryScalarWhereInput!]
}

type InvoiceItemEntrySubscriptionPayload {
  mutation: MutationType!
  node: InvoiceItemEntry
  updatedFields: [String!]
  previousValues: InvoiceItemEntryPreviousValues
}

input InvoiceItemEntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvoiceItemEntryWhereInput
  AND: [InvoiceItemEntrySubscriptionWhereInput!]
  OR: [InvoiceItemEntrySubscriptionWhereInput!]
  NOT: [InvoiceItemEntrySubscriptionWhereInput!]
}

input InvoiceItemEntryUpdateInput {
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  invoice: InvoiceUpdateOneWithoutItemsInput
  project: ProjectUpdateOneInput
  service: ServiceUpdateOneInput
  timeSheetEntry: TimeSheetEntryUpdateOneInput
  timeSheet: TimeSheetUpdateOneInput
}

input InvoiceItemEntryUpdateManyDataInput {
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
}

input InvoiceItemEntryUpdateManyMutationInput {
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
}

input InvoiceItemEntryUpdateManyWithoutInvoiceInput {
  create: [InvoiceItemEntryCreateWithoutInvoiceInput!]
  delete: [InvoiceItemEntryWhereUniqueInput!]
  connect: [InvoiceItemEntryWhereUniqueInput!]
  set: [InvoiceItemEntryWhereUniqueInput!]
  disconnect: [InvoiceItemEntryWhereUniqueInput!]
  update: [InvoiceItemEntryUpdateWithWhereUniqueWithoutInvoiceInput!]
  upsert: [InvoiceItemEntryUpsertWithWhereUniqueWithoutInvoiceInput!]
  deleteMany: [InvoiceItemEntryScalarWhereInput!]
  updateMany: [InvoiceItemEntryUpdateManyWithWhereNestedInput!]
}

input InvoiceItemEntryUpdateManyWithWhereNestedInput {
  where: InvoiceItemEntryScalarWhereInput!
  data: InvoiceItemEntryUpdateManyDataInput!
}

input InvoiceItemEntryUpdateWithoutInvoiceDataInput {
  order: Int
  description: String
  name: String
  price: Float
  quantity: Float
  tax: Float
  project: ProjectUpdateOneInput
  service: ServiceUpdateOneInput
  timeSheetEntry: TimeSheetEntryUpdateOneInput
  timeSheet: TimeSheetUpdateOneInput
}

input InvoiceItemEntryUpdateWithWhereUniqueWithoutInvoiceInput {
  where: InvoiceItemEntryWhereUniqueInput!
  data: InvoiceItemEntryUpdateWithoutInvoiceDataInput!
}

input InvoiceItemEntryUpsertWithWhereUniqueWithoutInvoiceInput {
  where: InvoiceItemEntryWhereUniqueInput!
  update: InvoiceItemEntryUpdateWithoutInvoiceDataInput!
  create: InvoiceItemEntryCreateWithoutInvoiceInput!
}

input InvoiceItemEntryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  tax: Float
  tax_not: Float
  tax_in: [Float!]
  tax_not_in: [Float!]
  tax_lt: Float
  tax_lte: Float
  tax_gt: Float
  tax_gte: Float
  invoice: InvoiceWhereInput
  project: ProjectWhereInput
  service: ServiceWhereInput
  timeSheetEntry: TimeSheetEntryWhereInput
  timeSheet: TimeSheetWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceItemEntryWhereInput!]
  OR: [InvoiceItemEntryWhereInput!]
  NOT: [InvoiceItemEntryWhereInput!]
}

input InvoiceItemEntryWhereUniqueInput {
  id: ID
}

enum InvoiceOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  number_ASC
  number_DESC
  description_ASC
  description_DESC
  invoiceDate_ASC
  invoiceDate_DESC
  dueDate_ASC
  dueDate_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  total_ASC
  total_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InvoicePreviousValues {
  id: ID!
  title: String
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  status: InvoiceStatus
  type: InvoiceType
  total: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum InvoiceStatus {
  APPROVED
  ARCHIVED
  DRAFT
  FULLY_PAID
  PARTIALLY_PAID
  UNPAID
  PROPOSED
  REJECTED
}

type InvoiceSubscriptionPayload {
  mutation: MutationType!
  node: Invoice
  updatedFields: [String!]
  previousValues: InvoicePreviousValues
}

input InvoiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvoiceWhereInput
  AND: [InvoiceSubscriptionWhereInput!]
  OR: [InvoiceSubscriptionWhereInput!]
  NOT: [InvoiceSubscriptionWhereInput!]
}

enum InvoiceType {
  PROJECT
  TIMESHEET
  TIMESHEET_WITH_DETAILS
  FREE_TEXT
}

input InvoiceUpdateInput {
  title: String
  attachments: AttachmentUpdateManyInput
  buyer: CustomerUpdateOneInput
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  preview: AttachmentUpdateOneInput
  items: InvoiceItemEntryUpdateManyWithoutInvoiceInput
  seller: CompanyUpdateOneRequiredInput
  status: InvoiceStatus
  type: InvoiceType
  total: Float
}

input InvoiceUpdateManyMutationInput {
  title: String
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  status: InvoiceStatus
  type: InvoiceType
  total: Float
}

input InvoiceUpdateOneWithoutItemsInput {
  create: InvoiceCreateWithoutItemsInput
  update: InvoiceUpdateWithoutItemsDataInput
  upsert: InvoiceUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: InvoiceWhereUniqueInput
}

input InvoiceUpdateWithoutItemsDataInput {
  title: String
  attachments: AttachmentUpdateManyInput
  buyer: CustomerUpdateOneInput
  number: Int
  description: String
  invoiceDate: DateTime
  dueDate: DateTime
  preview: AttachmentUpdateOneInput
  seller: CompanyUpdateOneRequiredInput
  status: InvoiceStatus
  type: InvoiceType
  total: Float
}

input InvoiceUpsertWithoutItemsInput {
  update: InvoiceUpdateWithoutItemsDataInput!
  create: InvoiceCreateWithoutItemsInput!
}

input InvoiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  buyer: CustomerWhereInput
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  invoiceDate: DateTime
  invoiceDate_not: DateTime
  invoiceDate_in: [DateTime!]
  invoiceDate_not_in: [DateTime!]
  invoiceDate_lt: DateTime
  invoiceDate_lte: DateTime
  invoiceDate_gt: DateTime
  invoiceDate_gte: DateTime
  dueDate: DateTime
  dueDate_not: DateTime
  dueDate_in: [DateTime!]
  dueDate_not_in: [DateTime!]
  dueDate_lt: DateTime
  dueDate_lte: DateTime
  dueDate_gt: DateTime
  dueDate_gte: DateTime
  preview: AttachmentWhereInput
  items_every: InvoiceItemEntryWhereInput
  items_some: InvoiceItemEntryWhereInput
  items_none: InvoiceItemEntryWhereInput
  seller: CompanyWhereInput
  status: InvoiceStatus
  status_not: InvoiceStatus
  status_in: [InvoiceStatus!]
  status_not_in: [InvoiceStatus!]
  type: InvoiceType
  type_not: InvoiceType
  type_in: [InvoiceType!]
  type_not_in: [InvoiceType!]
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InvoiceWhereInput!]
  OR: [InvoiceWhereInput!]
  NOT: [InvoiceWhereInput!]
}

input InvoiceWhereUniqueInput {
  id: ID
}

scalar Json

type LedgerJournal {
  id: ID!
  total: Float
  description: String
  currency: Currency!
  includeConsTax: Boolean!
  posted: Boolean!
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerJournalConnection {
  pageInfo: PageInfo!
  edges: [LedgerJournalEdge]!
  aggregate: AggregateLedgerJournal!
}

input LedgerJournalCreateInput {
  id: ID
  total: Float
  description: String
  currency: Currency!
  includeConsTax: Boolean!
  posted: Boolean!
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerJournalCreateOneInput {
  create: LedgerJournalCreateInput
  connect: LedgerJournalWhereUniqueInput
}

type LedgerJournalEdge {
  node: LedgerJournal!
  cursor: String!
}

enum LedgerJournalOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  description_ASC
  description_DESC
  currency_ASC
  currency_DESC
  includeConsTax_ASC
  includeConsTax_DESC
  posted_ASC
  posted_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LedgerJournalPreviousValues {
  id: ID!
  total: Float
  description: String
  currency: Currency!
  includeConsTax: Boolean!
  posted: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerJournalSubscriptionPayload {
  mutation: MutationType!
  node: LedgerJournal
  updatedFields: [String!]
  previousValues: LedgerJournalPreviousValues
}

input LedgerJournalSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LedgerJournalWhereInput
  AND: [LedgerJournalSubscriptionWhereInput!]
  OR: [LedgerJournalSubscriptionWhereInput!]
  NOT: [LedgerJournalSubscriptionWhereInput!]
}

input LedgerJournalUpdateDataInput {
  total: Float
  description: String
  currency: Currency
  includeConsTax: Boolean
  posted: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerJournalUpdateInput {
  total: Float
  description: String
  currency: Currency
  includeConsTax: Boolean
  posted: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerJournalUpdateManyMutationInput {
  total: Float
  description: String
  currency: Currency
  includeConsTax: Boolean
  posted: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerJournalUpdateOneInput {
  create: LedgerJournalCreateInput
  update: LedgerJournalUpdateDataInput
  upsert: LedgerJournalUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LedgerJournalWhereUniqueInput
}

input LedgerJournalUpdateOneRequiredInput {
  create: LedgerJournalCreateInput
  update: LedgerJournalUpdateDataInput
  upsert: LedgerJournalUpsertNestedInput
  connect: LedgerJournalWhereUniqueInput
}

input LedgerJournalUpsertNestedInput {
  update: LedgerJournalUpdateDataInput!
  create: LedgerJournalCreateInput!
}

input LedgerJournalWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  includeConsTax: Boolean
  includeConsTax_not: Boolean
  posted: Boolean
  posted_not: Boolean
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LedgerJournalWhereInput!]
  OR: [LedgerJournalWhereInput!]
  NOT: [LedgerJournalWhereInput!]
}

input LedgerJournalWhereUniqueInput {
  id: ID
}

type LedgerPosting {
  id: ID!
  postingType: PostingType
  mainAccount: MainAccount
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerPostingConnection {
  pageInfo: PageInfo!
  edges: [LedgerPostingEdge]!
  aggregate: AggregateLedgerPosting!
}

input LedgerPostingCreateInput {
  id: ID
  postingType: PostingType
  mainAccount: MainAccountCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type LedgerPostingEdge {
  node: LedgerPosting!
  cursor: String!
}

enum LedgerPostingOrderByInput {
  id_ASC
  id_DESC
  postingType_ASC
  postingType_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LedgerPostingPreviousValues {
  id: ID!
  postingType: PostingType
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerPostingSubscriptionPayload {
  mutation: MutationType!
  node: LedgerPosting
  updatedFields: [String!]
  previousValues: LedgerPostingPreviousValues
}

input LedgerPostingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LedgerPostingWhereInput
  AND: [LedgerPostingSubscriptionWhereInput!]
  OR: [LedgerPostingSubscriptionWhereInput!]
  NOT: [LedgerPostingSubscriptionWhereInput!]
}

input LedgerPostingUpdateInput {
  postingType: PostingType
  mainAccount: MainAccountUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerPostingUpdateManyMutationInput {
  postingType: PostingType
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerPostingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  postingType: PostingType
  postingType_not: PostingType
  postingType_in: [PostingType!]
  postingType_not_in: [PostingType!]
  mainAccount: MainAccountWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LedgerPostingWhereInput!]
  OR: [LedgerPostingWhereInput!]
  NOT: [LedgerPostingWhereInput!]
}

input LedgerPostingWhereUniqueInput {
  id: ID
}

type LedgerTransaction {
  id: ID!
  mainAccount: MainAccount!
  ledgerJournal: LedgerJournal!
  drcr: DrCr!
  amount: Float!
  currency: Currency!
  date: DateTime!
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerTransactionConnection {
  pageInfo: PageInfo!
  edges: [LedgerTransactionEdge]!
  aggregate: AggregateLedgerTransaction!
}

input LedgerTransactionCreateInput {
  id: ID
  mainAccount: MainAccountCreateOneInput!
  ledgerJournal: LedgerJournalCreateOneInput!
  drcr: DrCr!
  amount: Float!
  currency: Currency!
  date: DateTime!
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

type LedgerTransactionEdge {
  node: LedgerTransaction!
  cursor: String!
}

enum LedgerTransactionOrderByInput {
  id_ASC
  id_DESC
  drcr_ASC
  drcr_DESC
  amount_ASC
  amount_DESC
  currency_ASC
  currency_DESC
  date_ASC
  date_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LedgerTransactionPreviousValues {
  id: ID!
  drcr: DrCr!
  amount: Float!
  currency: Currency!
  date: DateTime!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LedgerTransactionSubscriptionPayload {
  mutation: MutationType!
  node: LedgerTransaction
  updatedFields: [String!]
  previousValues: LedgerTransactionPreviousValues
}

input LedgerTransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LedgerTransactionWhereInput
  AND: [LedgerTransactionSubscriptionWhereInput!]
  OR: [LedgerTransactionSubscriptionWhereInput!]
  NOT: [LedgerTransactionSubscriptionWhereInput!]
}

input LedgerTransactionUpdateInput {
  mainAccount: MainAccountUpdateOneRequiredInput
  ledgerJournal: LedgerJournalUpdateOneRequiredInput
  drcr: DrCr
  amount: Float
  currency: Currency
  date: DateTime
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerTransactionUpdateManyMutationInput {
  drcr: DrCr
  amount: Float
  currency: Currency
  date: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input LedgerTransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  mainAccount: MainAccountWhereInput
  ledgerJournal: LedgerJournalWhereInput
  drcr: DrCr
  drcr_not: DrCr
  drcr_in: [DrCr!]
  drcr_not_in: [DrCr!]
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LedgerTransactionWhereInput!]
  OR: [LedgerTransactionWhereInput!]
  NOT: [LedgerTransactionWhereInput!]
}

input LedgerTransactionWhereUniqueInput {
  id: ID
}

enum LevelOfCare {
  Level1
  Level2
  Level3
  Level4
}

scalar Long

type MainAccount {
  id: ID!
  code: String!
  name: String!
  description: String
  type: MainAccountType!
  ConsTaxFree: Boolean!
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MainAccountConnection {
  pageInfo: PageInfo!
  edges: [MainAccountEdge]!
  aggregate: AggregateMainAccount!
}

input MainAccountCreateInput {
  id: ID
  code: String!
  name: String!
  description: String
  type: MainAccountType!
  ConsTaxFree: Boolean
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input MainAccountCreateOneInput {
  create: MainAccountCreateInput
  connect: MainAccountWhereUniqueInput
}

type MainAccountEdge {
  node: MainAccount!
  cursor: String!
}

enum MainAccountOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  ConsTaxFree_ASC
  ConsTaxFree_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MainAccountPreviousValues {
  id: ID!
  code: String!
  name: String!
  description: String
  type: MainAccountType!
  ConsTaxFree: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MainAccountSubscriptionPayload {
  mutation: MutationType!
  node: MainAccount
  updatedFields: [String!]
  previousValues: MainAccountPreviousValues
}

input MainAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MainAccountWhereInput
  AND: [MainAccountSubscriptionWhereInput!]
  OR: [MainAccountSubscriptionWhereInput!]
  NOT: [MainAccountSubscriptionWhereInput!]
}

enum MainAccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

input MainAccountUpdateDataInput {
  code: String
  name: String
  description: String
  type: MainAccountType
  ConsTaxFree: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input MainAccountUpdateInput {
  code: String
  name: String
  description: String
  type: MainAccountType
  ConsTaxFree: Boolean
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input MainAccountUpdateManyMutationInput {
  code: String
  name: String
  description: String
  type: MainAccountType
  ConsTaxFree: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input MainAccountUpdateOneInput {
  create: MainAccountCreateInput
  update: MainAccountUpdateDataInput
  upsert: MainAccountUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MainAccountWhereUniqueInput
}

input MainAccountUpdateOneRequiredInput {
  create: MainAccountCreateInput
  update: MainAccountUpdateDataInput
  upsert: MainAccountUpsertNestedInput
  connect: MainAccountWhereUniqueInput
}

input MainAccountUpsertNestedInput {
  update: MainAccountUpdateDataInput!
  create: MainAccountCreateInput!
}

input MainAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: MainAccountType
  type_not: MainAccountType
  type_in: [MainAccountType!]
  type_not_in: [MainAccountType!]
  ConsTaxFree: Boolean
  ConsTaxFree_not: Boolean
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MainAccountWhereInput!]
  OR: [MainAccountWhereInput!]
  NOT: [MainAccountWhereInput!]
}

input MainAccountWhereUniqueInput {
  id: ID
}

type MeansTestedFee {
  id: ID!
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
  company: Company
}

type MeansTestedFeeConnection {
  pageInfo: PageInfo!
  edges: [MeansTestedFeeEdge]!
  aggregate: AggregateMeansTestedFee!
}

input MeansTestedFeeCreateInput {
  id: ID
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
  company: CompanyCreateOneInput
}

input MeansTestedFeeCreateOneInput {
  create: MeansTestedFeeCreateInput
  connect: MeansTestedFeeWhereUniqueInput
}

type MeansTestedFeeEdge {
  node: MeansTestedFee!
  cursor: String!
}

enum MeansTestedFeeOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  currency_ASC
  currency_DESC
  dateFrom_ASC
  dateFrom_DESC
  dateTo_ASC
  dateTo_DESC
}

type MeansTestedFeePreviousValues {
  id: ID!
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
}

type MeansTestedFeeSubscriptionPayload {
  mutation: MutationType!
  node: MeansTestedFee
  updatedFields: [String!]
  previousValues: MeansTestedFeePreviousValues
}

input MeansTestedFeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeansTestedFeeWhereInput
  AND: [MeansTestedFeeSubscriptionWhereInput!]
  OR: [MeansTestedFeeSubscriptionWhereInput!]
  NOT: [MeansTestedFeeSubscriptionWhereInput!]
}

input MeansTestedFeeUpdateDataInput {
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
  company: CompanyUpdateOneInput
}

input MeansTestedFeeUpdateInput {
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
  company: CompanyUpdateOneInput
}

input MeansTestedFeeUpdateManyMutationInput {
  amount: Float
  currency: Currency
  dateFrom: DateTime
  dateTo: DateTime
}

input MeansTestedFeeUpdateOneInput {
  create: MeansTestedFeeCreateInput
  update: MeansTestedFeeUpdateDataInput
  upsert: MeansTestedFeeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MeansTestedFeeWhereUniqueInput
}

input MeansTestedFeeUpsertNestedInput {
  update: MeansTestedFeeUpdateDataInput!
  create: MeansTestedFeeCreateInput!
}

input MeansTestedFeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  dateFrom: DateTime
  dateFrom_not: DateTime
  dateFrom_in: [DateTime!]
  dateFrom_not_in: [DateTime!]
  dateFrom_lt: DateTime
  dateFrom_lte: DateTime
  dateFrom_gt: DateTime
  dateFrom_gte: DateTime
  dateTo: DateTime
  dateTo_not: DateTime
  dateTo_in: [DateTime!]
  dateTo_not_in: [DateTime!]
  dateTo_lt: DateTime
  dateTo_lte: DateTime
  dateTo_gt: DateTime
  dateTo_gte: DateTime
  company: CompanyWhereInput
  AND: [MeansTestedFeeWhereInput!]
  OR: [MeansTestedFeeWhereInput!]
  NOT: [MeansTestedFeeWhereInput!]
}

input MeansTestedFeeWhereUniqueInput {
  id: ID
}

type MeansTestLimits {
  id: ID!
  annual: Float
  lifetime: Float
  dateFrom: DateTime
  dateTo: DateTime
}

type MeansTestLimitsConnection {
  pageInfo: PageInfo!
  edges: [MeansTestLimitsEdge]!
  aggregate: AggregateMeansTestLimits!
}

input MeansTestLimitsCreateInput {
  id: ID
  annual: Float
  lifetime: Float
  dateFrom: DateTime
  dateTo: DateTime
}

type MeansTestLimitsEdge {
  node: MeansTestLimits!
  cursor: String!
}

enum MeansTestLimitsOrderByInput {
  id_ASC
  id_DESC
  annual_ASC
  annual_DESC
  lifetime_ASC
  lifetime_DESC
  dateFrom_ASC
  dateFrom_DESC
  dateTo_ASC
  dateTo_DESC
}

type MeansTestLimitsPreviousValues {
  id: ID!
  annual: Float
  lifetime: Float
  dateFrom: DateTime
  dateTo: DateTime
}

type MeansTestLimitsSubscriptionPayload {
  mutation: MutationType!
  node: MeansTestLimits
  updatedFields: [String!]
  previousValues: MeansTestLimitsPreviousValues
}

input MeansTestLimitsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeansTestLimitsWhereInput
  AND: [MeansTestLimitsSubscriptionWhereInput!]
  OR: [MeansTestLimitsSubscriptionWhereInput!]
  NOT: [MeansTestLimitsSubscriptionWhereInput!]
}

input MeansTestLimitsUpdateInput {
  annual: Float
  lifetime: Float
  dateFrom: DateTime
  dateTo: DateTime
}

input MeansTestLimitsUpdateManyMutationInput {
  annual: Float
  lifetime: Float
  dateFrom: DateTime
  dateTo: DateTime
}

input MeansTestLimitsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  annual: Float
  annual_not: Float
  annual_in: [Float!]
  annual_not_in: [Float!]
  annual_lt: Float
  annual_lte: Float
  annual_gt: Float
  annual_gte: Float
  lifetime: Float
  lifetime_not: Float
  lifetime_in: [Float!]
  lifetime_not_in: [Float!]
  lifetime_lt: Float
  lifetime_lte: Float
  lifetime_gt: Float
  lifetime_gte: Float
  dateFrom: DateTime
  dateFrom_not: DateTime
  dateFrom_in: [DateTime!]
  dateFrom_not_in: [DateTime!]
  dateFrom_lt: DateTime
  dateFrom_lte: DateTime
  dateFrom_gt: DateTime
  dateFrom_gte: DateTime
  dateTo: DateTime
  dateTo_not: DateTime
  dateTo_in: [DateTime!]
  dateTo_not_in: [DateTime!]
  dateTo_lt: DateTime
  dateTo_lte: DateTime
  dateTo_gt: DateTime
  dateTo_gte: DateTime
  AND: [MeansTestLimitsWhereInput!]
  OR: [MeansTestLimitsWhereInput!]
  NOT: [MeansTestLimitsWhereInput!]
}

input MeansTestLimitsWhereUniqueInput {
  id: ID
}

type MedicareService {
  id: ID!
  MBSScheduleFee: Float
  description: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MedicareServiceConnection {
  pageInfo: PageInfo!
  edges: [MedicareServiceEdge]!
  aggregate: AggregateMedicareService!
}

input MedicareServiceCreateInput {
  id: ID
  MBSScheduleFee: Float
  description: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

type MedicareServiceEdge {
  node: MedicareService!
  cursor: String!
}

enum MedicareServiceOrderByInput {
  id_ASC
  id_DESC
  MBSScheduleFee_ASC
  MBSScheduleFee_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MedicareServicePreviousValues {
  id: ID!
  MBSScheduleFee: Float
  description: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MedicareServiceSubscriptionPayload {
  mutation: MutationType!
  node: MedicareService
  updatedFields: [String!]
  previousValues: MedicareServicePreviousValues
}

input MedicareServiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MedicareServiceWhereInput
  AND: [MedicareServiceSubscriptionWhereInput!]
  OR: [MedicareServiceSubscriptionWhereInput!]
  NOT: [MedicareServiceSubscriptionWhereInput!]
}

input MedicareServiceUpdateInput {
  MBSScheduleFee: Float
  description: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input MedicareServiceUpdateManyMutationInput {
  MBSScheduleFee: Float
  description: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input MedicareServiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  MBSScheduleFee: Float
  MBSScheduleFee_not: Float
  MBSScheduleFee_in: [Float!]
  MBSScheduleFee_not_in: [Float!]
  MBSScheduleFee_lt: Float
  MBSScheduleFee_lte: Float
  MBSScheduleFee_gt: Float
  MBSScheduleFee_gte: Float
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MedicareServiceWhereInput!]
  OR: [MedicareServiceWhereInput!]
  NOT: [MedicareServiceWhereInput!]
}

input MedicareServiceWhereUniqueInput {
  id: ID
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createApInvoice(data: ApInvoiceCreateInput!): ApInvoice!
  updateApInvoice(data: ApInvoiceUpdateInput!, where: ApInvoiceWhereUniqueInput!): ApInvoice
  updateManyApInvoices(data: ApInvoiceUpdateManyMutationInput!, where: ApInvoiceWhereInput): BatchPayload!
  upsertApInvoice(where: ApInvoiceWhereUniqueInput!, create: ApInvoiceCreateInput!, update: ApInvoiceUpdateInput!): ApInvoice!
  deleteApInvoice(where: ApInvoiceWhereUniqueInput!): ApInvoice
  deleteManyApInvoices(where: ApInvoiceWhereInput): BatchPayload!
  createAsset(data: AssetCreateInput!): Asset!
  updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
  updateManyAssets(data: AssetUpdateManyMutationInput!, where: AssetWhereInput): BatchPayload!
  upsertAsset(where: AssetWhereUniqueInput!, create: AssetCreateInput!, update: AssetUpdateInput!): Asset!
  deleteAsset(where: AssetWhereUniqueInput!): Asset
  deleteManyAssets(where: AssetWhereInput): BatchPayload!
  createAssetGroup(data: AssetGroupCreateInput!): AssetGroup!
  updateAssetGroup(data: AssetGroupUpdateInput!, where: AssetGroupWhereUniqueInput!): AssetGroup
  updateManyAssetGroups(data: AssetGroupUpdateManyMutationInput!, where: AssetGroupWhereInput): BatchPayload!
  upsertAssetGroup(where: AssetGroupWhereUniqueInput!, create: AssetGroupCreateInput!, update: AssetGroupUpdateInput!): AssetGroup!
  deleteAssetGroup(where: AssetGroupWhereUniqueInput!): AssetGroup
  deleteManyAssetGroups(where: AssetGroupWhereInput): BatchPayload!
  createAttachment(data: AttachmentCreateInput!): Attachment!
  updateAttachment(data: AttachmentUpdateInput!, where: AttachmentWhereUniqueInput!): Attachment
  updateManyAttachments(data: AttachmentUpdateManyMutationInput!, where: AttachmentWhereInput): BatchPayload!
  upsertAttachment(where: AttachmentWhereUniqueInput!, create: AttachmentCreateInput!, update: AttachmentUpdateInput!): Attachment!
  deleteAttachment(where: AttachmentWhereUniqueInput!): Attachment
  deleteManyAttachments(where: AttachmentWhereInput): BatchPayload!
  createBank(data: BankCreateInput!): Bank!
  updateBank(data: BankUpdateInput!, where: BankWhereUniqueInput!): Bank
  updateManyBanks(data: BankUpdateManyMutationInput!, where: BankWhereInput): BatchPayload!
  upsertBank(where: BankWhereUniqueInput!, create: BankCreateInput!, update: BankUpdateInput!): Bank!
  deleteBank(where: BankWhereUniqueInput!): Bank
  deleteManyBanks(where: BankWhereInput): BatchPayload!
  createBankTransaction(data: BankTransactionCreateInput!): BankTransaction!
  updateBankTransaction(data: BankTransactionUpdateInput!, where: BankTransactionWhereUniqueInput!): BankTransaction
  updateManyBankTransactions(data: BankTransactionUpdateManyMutationInput!, where: BankTransactionWhereInput): BatchPayload!
  upsertBankTransaction(where: BankTransactionWhereUniqueInput!, create: BankTransactionCreateInput!, update: BankTransactionUpdateInput!): BankTransaction!
  deleteBankTransaction(where: BankTransactionWhereUniqueInput!): BankTransaction
  deleteManyBankTransactions(where: BankTransactionWhereInput): BatchPayload!
  createBasicDailyFee(data: BasicDailyFeeCreateInput!): BasicDailyFee!
  updateBasicDailyFee(data: BasicDailyFeeUpdateInput!, where: BasicDailyFeeWhereUniqueInput!): BasicDailyFee
  updateManyBasicDailyFees(data: BasicDailyFeeUpdateManyMutationInput!, where: BasicDailyFeeWhereInput): BatchPayload!
  upsertBasicDailyFee(where: BasicDailyFeeWhereUniqueInput!, create: BasicDailyFeeCreateInput!, update: BasicDailyFeeUpdateInput!): BasicDailyFee!
  deleteBasicDailyFee(where: BasicDailyFeeWhereUniqueInput!): BasicDailyFee
  deleteManyBasicDailyFees(where: BasicDailyFeeWhereInput): BatchPayload!
  createCompany(data: CompanyCreateInput!): Company!
  updateCompany(data: CompanyUpdateInput!, where: CompanyWhereUniqueInput!): Company
  updateManyCompanies(data: CompanyUpdateManyMutationInput!, where: CompanyWhereInput): BatchPayload!
  upsertCompany(where: CompanyWhereUniqueInput!, create: CompanyCreateInput!, update: CompanyUpdateInput!): Company!
  deleteCompany(where: CompanyWhereUniqueInput!): Company
  deleteManyCompanies(where: CompanyWhereInput): BatchPayload!
  createCompanyMember(data: CompanyMemberCreateInput!): CompanyMember!
  updateCompanyMember(data: CompanyMemberUpdateInput!, where: CompanyMemberWhereUniqueInput!): CompanyMember
  updateManyCompanyMembers(data: CompanyMemberUpdateManyMutationInput!, where: CompanyMemberWhereInput): BatchPayload!
  upsertCompanyMember(where: CompanyMemberWhereUniqueInput!, create: CompanyMemberCreateInput!, update: CompanyMemberUpdateInput!): CompanyMember!
  deleteCompanyMember(where: CompanyMemberWhereUniqueInput!): CompanyMember
  deleteManyCompanyMembers(where: CompanyMemberWhereInput): BatchPayload!
  createContact(data: ContactCreateInput!): Contact!
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateManyContacts(data: ContactUpdateManyMutationInput!, where: ContactWhereInput): BatchPayload!
  upsertContact(where: ContactWhereUniqueInput!, create: ContactCreateInput!, update: ContactUpdateInput!): Contact!
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createDisease(data: DiseaseCreateInput!): Disease!
  updateDisease(data: DiseaseUpdateInput!, where: DiseaseWhereUniqueInput!): Disease
  updateManyDiseases(data: DiseaseUpdateManyMutationInput!, where: DiseaseWhereInput): BatchPayload!
  upsertDisease(where: DiseaseWhereUniqueInput!, create: DiseaseCreateInput!, update: DiseaseUpdateInput!): Disease!
  deleteDisease(where: DiseaseWhereUniqueInput!): Disease
  deleteManyDiseases(where: DiseaseWhereInput): BatchPayload!
  createHILog(data: HILogCreateInput!): HILog!
  updateHILog(data: HILogUpdateInput!, where: HILogWhereUniqueInput!): HILog
  updateManyHILogs(data: HILogUpdateManyMutationInput!, where: HILogWhereInput): BatchPayload!
  upsertHILog(where: HILogWhereUniqueInput!, create: HILogCreateInput!, update: HILogUpdateInput!): HILog!
  deleteHILog(where: HILogWhereUniqueInput!): HILog
  deleteManyHILogs(where: HILogWhereInput): BatchPayload!
  createHealthcareProvider(data: HealthcareProviderCreateInput!): HealthcareProvider!
  updateHealthcareProvider(data: HealthcareProviderUpdateInput!, where: HealthcareProviderWhereUniqueInput!): HealthcareProvider
  updateManyHealthcareProviders(data: HealthcareProviderUpdateManyMutationInput!, where: HealthcareProviderWhereInput): BatchPayload!
  upsertHealthcareProvider(where: HealthcareProviderWhereUniqueInput!, create: HealthcareProviderCreateInput!, update: HealthcareProviderUpdateInput!): HealthcareProvider!
  deleteHealthcareProvider(where: HealthcareProviderWhereUniqueInput!): HealthcareProvider
  deleteManyHealthcareProviders(where: HealthcareProviderWhereInput): BatchPayload!
  createImmunisationSchedule(data: ImmunisationScheduleCreateInput!): ImmunisationSchedule!
  updateImmunisationSchedule(data: ImmunisationScheduleUpdateInput!, where: ImmunisationScheduleWhereUniqueInput!): ImmunisationSchedule
  updateManyImmunisationSchedules(data: ImmunisationScheduleUpdateManyMutationInput!, where: ImmunisationScheduleWhereInput): BatchPayload!
  upsertImmunisationSchedule(where: ImmunisationScheduleWhereUniqueInput!, create: ImmunisationScheduleCreateInput!, update: ImmunisationScheduleUpdateInput!): ImmunisationSchedule!
  deleteImmunisationSchedule(where: ImmunisationScheduleWhereUniqueInput!): ImmunisationSchedule
  deleteManyImmunisationSchedules(where: ImmunisationScheduleWhereInput): BatchPayload!
  createIntegration(data: IntegrationCreateInput!): Integration!
  updateIntegration(data: IntegrationUpdateInput!, where: IntegrationWhereUniqueInput!): Integration
  updateManyIntegrations(data: IntegrationUpdateManyMutationInput!, where: IntegrationWhereInput): BatchPayload!
  upsertIntegration(where: IntegrationWhereUniqueInput!, create: IntegrationCreateInput!, update: IntegrationUpdateInput!): Integration!
  deleteIntegration(where: IntegrationWhereUniqueInput!): Integration
  deleteManyIntegrations(where: IntegrationWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateManyInventories(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): BatchPayload!
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createInventoryOnHand(data: InventoryOnHandCreateInput!): InventoryOnHand!
  updateInventoryOnHand(data: InventoryOnHandUpdateInput!, where: InventoryOnHandWhereUniqueInput!): InventoryOnHand
  updateManyInventoryOnHands(data: InventoryOnHandUpdateManyMutationInput!, where: InventoryOnHandWhereInput): BatchPayload!
  upsertInventoryOnHand(where: InventoryOnHandWhereUniqueInput!, create: InventoryOnHandCreateInput!, update: InventoryOnHandUpdateInput!): InventoryOnHand!
  deleteInventoryOnHand(where: InventoryOnHandWhereUniqueInput!): InventoryOnHand
  deleteManyInventoryOnHands(where: InventoryOnHandWhereInput): BatchPayload!
  createInvoice(data: InvoiceCreateInput!): Invoice!
  updateInvoice(data: InvoiceUpdateInput!, where: InvoiceWhereUniqueInput!): Invoice
  updateManyInvoices(data: InvoiceUpdateManyMutationInput!, where: InvoiceWhereInput): BatchPayload!
  upsertInvoice(where: InvoiceWhereUniqueInput!, create: InvoiceCreateInput!, update: InvoiceUpdateInput!): Invoice!
  deleteInvoice(where: InvoiceWhereUniqueInput!): Invoice
  deleteManyInvoices(where: InvoiceWhereInput): BatchPayload!
  createInvoiceItemEntry(data: InvoiceItemEntryCreateInput!): InvoiceItemEntry!
  updateInvoiceItemEntry(data: InvoiceItemEntryUpdateInput!, where: InvoiceItemEntryWhereUniqueInput!): InvoiceItemEntry
  updateManyInvoiceItemEntries(data: InvoiceItemEntryUpdateManyMutationInput!, where: InvoiceItemEntryWhereInput): BatchPayload!
  upsertInvoiceItemEntry(where: InvoiceItemEntryWhereUniqueInput!, create: InvoiceItemEntryCreateInput!, update: InvoiceItemEntryUpdateInput!): InvoiceItemEntry!
  deleteInvoiceItemEntry(where: InvoiceItemEntryWhereUniqueInput!): InvoiceItemEntry
  deleteManyInvoiceItemEntries(where: InvoiceItemEntryWhereInput): BatchPayload!
  createLedgerJournal(data: LedgerJournalCreateInput!): LedgerJournal!
  updateLedgerJournal(data: LedgerJournalUpdateInput!, where: LedgerJournalWhereUniqueInput!): LedgerJournal
  updateManyLedgerJournals(data: LedgerJournalUpdateManyMutationInput!, where: LedgerJournalWhereInput): BatchPayload!
  upsertLedgerJournal(where: LedgerJournalWhereUniqueInput!, create: LedgerJournalCreateInput!, update: LedgerJournalUpdateInput!): LedgerJournal!
  deleteLedgerJournal(where: LedgerJournalWhereUniqueInput!): LedgerJournal
  deleteManyLedgerJournals(where: LedgerJournalWhereInput): BatchPayload!
  createLedgerPosting(data: LedgerPostingCreateInput!): LedgerPosting!
  updateLedgerPosting(data: LedgerPostingUpdateInput!, where: LedgerPostingWhereUniqueInput!): LedgerPosting
  updateManyLedgerPostings(data: LedgerPostingUpdateManyMutationInput!, where: LedgerPostingWhereInput): BatchPayload!
  upsertLedgerPosting(where: LedgerPostingWhereUniqueInput!, create: LedgerPostingCreateInput!, update: LedgerPostingUpdateInput!): LedgerPosting!
  deleteLedgerPosting(where: LedgerPostingWhereUniqueInput!): LedgerPosting
  deleteManyLedgerPostings(where: LedgerPostingWhereInput): BatchPayload!
  createLedgerTransaction(data: LedgerTransactionCreateInput!): LedgerTransaction!
  updateLedgerTransaction(data: LedgerTransactionUpdateInput!, where: LedgerTransactionWhereUniqueInput!): LedgerTransaction
  updateManyLedgerTransactions(data: LedgerTransactionUpdateManyMutationInput!, where: LedgerTransactionWhereInput): BatchPayload!
  upsertLedgerTransaction(where: LedgerTransactionWhereUniqueInput!, create: LedgerTransactionCreateInput!, update: LedgerTransactionUpdateInput!): LedgerTransaction!
  deleteLedgerTransaction(where: LedgerTransactionWhereUniqueInput!): LedgerTransaction
  deleteManyLedgerTransactions(where: LedgerTransactionWhereInput): BatchPayload!
  createMainAccount(data: MainAccountCreateInput!): MainAccount!
  updateMainAccount(data: MainAccountUpdateInput!, where: MainAccountWhereUniqueInput!): MainAccount
  updateManyMainAccounts(data: MainAccountUpdateManyMutationInput!, where: MainAccountWhereInput): BatchPayload!
  upsertMainAccount(where: MainAccountWhereUniqueInput!, create: MainAccountCreateInput!, update: MainAccountUpdateInput!): MainAccount!
  deleteMainAccount(where: MainAccountWhereUniqueInput!): MainAccount
  deleteManyMainAccounts(where: MainAccountWhereInput): BatchPayload!
  createMeansTestLimits(data: MeansTestLimitsCreateInput!): MeansTestLimits!
  updateMeansTestLimits(data: MeansTestLimitsUpdateInput!, where: MeansTestLimitsWhereUniqueInput!): MeansTestLimits
  updateManyMeansTestLimitses(data: MeansTestLimitsUpdateManyMutationInput!, where: MeansTestLimitsWhereInput): BatchPayload!
  upsertMeansTestLimits(where: MeansTestLimitsWhereUniqueInput!, create: MeansTestLimitsCreateInput!, update: MeansTestLimitsUpdateInput!): MeansTestLimits!
  deleteMeansTestLimits(where: MeansTestLimitsWhereUniqueInput!): MeansTestLimits
  deleteManyMeansTestLimitses(where: MeansTestLimitsWhereInput): BatchPayload!
  createMeansTestedFee(data: MeansTestedFeeCreateInput!): MeansTestedFee!
  updateMeansTestedFee(data: MeansTestedFeeUpdateInput!, where: MeansTestedFeeWhereUniqueInput!): MeansTestedFee
  updateManyMeansTestedFees(data: MeansTestedFeeUpdateManyMutationInput!, where: MeansTestedFeeWhereInput): BatchPayload!
  upsertMeansTestedFee(where: MeansTestedFeeWhereUniqueInput!, create: MeansTestedFeeCreateInput!, update: MeansTestedFeeUpdateInput!): MeansTestedFee!
  deleteMeansTestedFee(where: MeansTestedFeeWhereUniqueInput!): MeansTestedFee
  deleteManyMeansTestedFees(where: MeansTestedFeeWhereInput): BatchPayload!
  createMedicareService(data: MedicareServiceCreateInput!): MedicareService!
  updateMedicareService(data: MedicareServiceUpdateInput!, where: MedicareServiceWhereUniqueInput!): MedicareService
  updateManyMedicareServices(data: MedicareServiceUpdateManyMutationInput!, where: MedicareServiceWhereInput): BatchPayload!
  upsertMedicareService(where: MedicareServiceWhereUniqueInput!, create: MedicareServiceCreateInput!, update: MedicareServiceUpdateInput!): MedicareService!
  deleteMedicareService(where: MedicareServiceWhereUniqueInput!): MedicareService
  deleteManyMedicareServices(where: MedicareServiceWhereInput): BatchPayload!
  createName(data: NameCreateInput!): Name!
  updateName(data: NameUpdateInput!, where: NameWhereUniqueInput!): Name
  updateManyNames(data: NameUpdateManyMutationInput!, where: NameWhereInput): BatchPayload!
  upsertName(where: NameWhereUniqueInput!, create: NameCreateInput!, update: NameUpdateInput!): Name!
  deleteName(where: NameWhereUniqueInput!): Name
  deleteManyNames(where: NameWhereInput): BatchPayload!
  createPatient(data: PatientCreateInput!): Patient!
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateManyPatients(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): BatchPayload!
  upsertPatient(where: PatientWhereUniqueInput!, create: PatientCreateInput!, update: PatientUpdateInput!): Patient!
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteManyPatients(where: PatientWhereInput): BatchPayload!
  createPbsOrganisation(data: PbsOrganisationCreateInput!): PbsOrganisation!
  updatePbsOrganisation(data: PbsOrganisationUpdateInput!, where: PbsOrganisationWhereUniqueInput!): PbsOrganisation
  updateManyPbsOrganisations(data: PbsOrganisationUpdateManyMutationInput!, where: PbsOrganisationWhereInput): BatchPayload!
  upsertPbsOrganisation(where: PbsOrganisationWhereUniqueInput!, create: PbsOrganisationCreateInput!, update: PbsOrganisationUpdateInput!): PbsOrganisation!
  deletePbsOrganisation(where: PbsOrganisationWhereUniqueInput!): PbsOrganisation
  deleteManyPbsOrganisations(where: PbsOrganisationWhereInput): BatchPayload!
  createPbsTPP(data: PbsTPPCreateInput!): PbsTPP!
  updatePbsTPP(data: PbsTPPUpdateInput!, where: PbsTPPWhereUniqueInput!): PbsTPP
  updateManyPbsTPPs(data: PbsTPPUpdateManyMutationInput!, where: PbsTPPWhereInput): BatchPayload!
  upsertPbsTPP(where: PbsTPPWhereUniqueInput!, create: PbsTPPCreateInput!, update: PbsTPPUpdateInput!): PbsTPP!
  deletePbsTPP(where: PbsTPPWhereUniqueInput!): PbsTPP
  deleteManyPbsTPPs(where: PbsTPPWhereInput): BatchPayload!
  createPlan(data: PlanCreateInput!): Plan!
  updatePlan(data: PlanUpdateInput!, where: PlanWhereUniqueInput!): Plan
  updateManyPlans(data: PlanUpdateManyMutationInput!, where: PlanWhereInput): BatchPayload!
  upsertPlan(where: PlanWhereUniqueInput!, create: PlanCreateInput!, update: PlanUpdateInput!): Plan!
  deletePlan(where: PlanWhereUniqueInput!): Plan
  deleteManyPlans(where: PlanWhereInput): BatchPayload!
  createPoReceipt(data: PoReceiptCreateInput!): PoReceipt!
  updatePoReceipt(data: PoReceiptUpdateInput!, where: PoReceiptWhereUniqueInput!): PoReceipt
  updateManyPoReceipts(data: PoReceiptUpdateManyMutationInput!, where: PoReceiptWhereInput): BatchPayload!
  upsertPoReceipt(where: PoReceiptWhereUniqueInput!, create: PoReceiptCreateInput!, update: PoReceiptUpdateInput!): PoReceipt!
  deletePoReceipt(where: PoReceiptWhereUniqueInput!): PoReceipt
  deleteManyPoReceipts(where: PoReceiptWhereInput): BatchPayload!
  createPredictedSalesQuantityOfItemsByCompany(data: PredictedSalesQuantityOfItemsByCompanyCreateInput!): PredictedSalesQuantityOfItemsByCompany!
  updatePredictedSalesQuantityOfItemsByCompany(data: PredictedSalesQuantityOfItemsByCompanyUpdateInput!, where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput!): PredictedSalesQuantityOfItemsByCompany
  updateManyPredictedSalesQuantityOfItemsByCompanies(data: PredictedSalesQuantityOfItemsByCompanyUpdateManyMutationInput!, where: PredictedSalesQuantityOfItemsByCompanyWhereInput): BatchPayload!
  upsertPredictedSalesQuantityOfItemsByCompany(where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput!, create: PredictedSalesQuantityOfItemsByCompanyCreateInput!, update: PredictedSalesQuantityOfItemsByCompanyUpdateInput!): PredictedSalesQuantityOfItemsByCompany!
  deletePredictedSalesQuantityOfItemsByCompany(where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput!): PredictedSalesQuantityOfItemsByCompany
  deleteManyPredictedSalesQuantityOfItemsByCompanies(where: PredictedSalesQuantityOfItemsByCompanyWhereInput): BatchPayload!
  createPredictedSalesValueByCompany(data: PredictedSalesValueByCompanyCreateInput!): PredictedSalesValueByCompany!
  updatePredictedSalesValueByCompany(data: PredictedSalesValueByCompanyUpdateInput!, where: PredictedSalesValueByCompanyWhereUniqueInput!): PredictedSalesValueByCompany
  updateManyPredictedSalesValueByCompanies(data: PredictedSalesValueByCompanyUpdateManyMutationInput!, where: PredictedSalesValueByCompanyWhereInput): BatchPayload!
  upsertPredictedSalesValueByCompany(where: PredictedSalesValueByCompanyWhereUniqueInput!, create: PredictedSalesValueByCompanyCreateInput!, update: PredictedSalesValueByCompanyUpdateInput!): PredictedSalesValueByCompany!
  deletePredictedSalesValueByCompany(where: PredictedSalesValueByCompanyWhereUniqueInput!): PredictedSalesValueByCompany
  deleteManyPredictedSalesValueByCompanies(where: PredictedSalesValueByCompanyWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createProjectService(data: ProjectServiceCreateInput!): ProjectService!
  updateProjectService(data: ProjectServiceUpdateInput!, where: ProjectServiceWhereUniqueInput!): ProjectService
  updateManyProjectServices(data: ProjectServiceUpdateManyMutationInput!, where: ProjectServiceWhereInput): BatchPayload!
  upsertProjectService(where: ProjectServiceWhereUniqueInput!, create: ProjectServiceCreateInput!, update: ProjectServiceUpdateInput!): ProjectService!
  deleteProjectService(where: ProjectServiceWhereUniqueInput!): ProjectService
  deleteManyProjectServices(where: ProjectServiceWhereInput): BatchPayload!
  createProjectServiceRule(data: ProjectServiceRuleCreateInput!): ProjectServiceRule!
  updateProjectServiceRule(data: ProjectServiceRuleUpdateInput!, where: ProjectServiceRuleWhereUniqueInput!): ProjectServiceRule
  updateManyProjectServiceRules(data: ProjectServiceRuleUpdateManyMutationInput!, where: ProjectServiceRuleWhereInput): BatchPayload!
  upsertProjectServiceRule(where: ProjectServiceRuleWhereUniqueInput!, create: ProjectServiceRuleCreateInput!, update: ProjectServiceRuleUpdateInput!): ProjectServiceRule!
  deleteProjectServiceRule(where: ProjectServiceRuleWhereUniqueInput!): ProjectServiceRule
  deleteManyProjectServiceRules(where: ProjectServiceRuleWhereInput): BatchPayload!
  createPurchaseOrder(data: PurchaseOrderCreateInput!): PurchaseOrder!
  updatePurchaseOrder(data: PurchaseOrderUpdateInput!, where: PurchaseOrderWhereUniqueInput!): PurchaseOrder
  updateManyPurchaseOrders(data: PurchaseOrderUpdateManyMutationInput!, where: PurchaseOrderWhereInput): BatchPayload!
  upsertPurchaseOrder(where: PurchaseOrderWhereUniqueInput!, create: PurchaseOrderCreateInput!, update: PurchaseOrderUpdateInput!): PurchaseOrder!
  deletePurchaseOrder(where: PurchaseOrderWhereUniqueInput!): PurchaseOrder
  deleteManyPurchaseOrders(where: PurchaseOrderWhereInput): BatchPayload!
  createPurchaseOrderLine(data: PurchaseOrderLineCreateInput!): PurchaseOrderLine!
  updatePurchaseOrderLine(data: PurchaseOrderLineUpdateInput!, where: PurchaseOrderLineWhereUniqueInput!): PurchaseOrderLine
  updateManyPurchaseOrderLines(data: PurchaseOrderLineUpdateManyMutationInput!, where: PurchaseOrderLineWhereInput): BatchPayload!
  upsertPurchaseOrderLine(where: PurchaseOrderLineWhereUniqueInput!, create: PurchaseOrderLineCreateInput!, update: PurchaseOrderLineUpdateInput!): PurchaseOrderLine!
  deletePurchaseOrderLine(where: PurchaseOrderLineWhereUniqueInput!): PurchaseOrderLine
  deleteManyPurchaseOrderLines(where: PurchaseOrderLineWhereInput): BatchPayload!
  createSalesOrder(data: SalesOrderCreateInput!): SalesOrder!
  updateSalesOrder(data: SalesOrderUpdateInput!, where: SalesOrderWhereUniqueInput!): SalesOrder
  updateManySalesOrders(data: SalesOrderUpdateManyMutationInput!, where: SalesOrderWhereInput): BatchPayload!
  upsertSalesOrder(where: SalesOrderWhereUniqueInput!, create: SalesOrderCreateInput!, update: SalesOrderUpdateInput!): SalesOrder!
  deleteSalesOrder(where: SalesOrderWhereUniqueInput!): SalesOrder
  deleteManySalesOrders(where: SalesOrderWhereInput): BatchPayload!
  createSalesOrderLine(data: SalesOrderLineCreateInput!): SalesOrderLine!
  updateSalesOrderLine(data: SalesOrderLineUpdateInput!, where: SalesOrderLineWhereUniqueInput!): SalesOrderLine
  updateManySalesOrderLines(data: SalesOrderLineUpdateManyMutationInput!, where: SalesOrderLineWhereInput): BatchPayload!
  upsertSalesOrderLine(where: SalesOrderLineWhereUniqueInput!, create: SalesOrderLineCreateInput!, update: SalesOrderLineUpdateInput!): SalesOrderLine!
  deleteSalesOrderLine(where: SalesOrderLineWhereUniqueInput!): SalesOrderLine
  deleteManySalesOrderLines(where: SalesOrderLineWhereInput): BatchPayload!
  createService(data: ServiceCreateInput!): Service!
  updateService(data: ServiceUpdateInput!, where: ServiceWhereUniqueInput!): Service
  updateManyServices(data: ServiceUpdateManyMutationInput!, where: ServiceWhereInput): BatchPayload!
  upsertService(where: ServiceWhereUniqueInput!, create: ServiceCreateInput!, update: ServiceUpdateInput!): Service!
  deleteService(where: ServiceWhereUniqueInput!): Service
  deleteManyServices(where: ServiceWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createSupplier(data: SupplierCreateInput!): Supplier!
  updateSupplier(data: SupplierUpdateInput!, where: SupplierWhereUniqueInput!): Supplier
  updateManySuppliers(data: SupplierUpdateManyMutationInput!, where: SupplierWhereInput): BatchPayload!
  upsertSupplier(where: SupplierWhereUniqueInput!, create: SupplierCreateInput!, update: SupplierUpdateInput!): Supplier!
  deleteSupplier(where: SupplierWhereUniqueInput!): Supplier
  deleteManySuppliers(where: SupplierWhereInput): BatchPayload!
  createTimeSheet(data: TimeSheetCreateInput!): TimeSheet!
  updateTimeSheet(data: TimeSheetUpdateInput!, where: TimeSheetWhereUniqueInput!): TimeSheet
  updateManyTimeSheets(data: TimeSheetUpdateManyMutationInput!, where: TimeSheetWhereInput): BatchPayload!
  upsertTimeSheet(where: TimeSheetWhereUniqueInput!, create: TimeSheetCreateInput!, update: TimeSheetUpdateInput!): TimeSheet!
  deleteTimeSheet(where: TimeSheetWhereUniqueInput!): TimeSheet
  deleteManyTimeSheets(where: TimeSheetWhereInput): BatchPayload!
  createTimeSheetEntry(data: TimeSheetEntryCreateInput!): TimeSheetEntry!
  updateTimeSheetEntry(data: TimeSheetEntryUpdateInput!, where: TimeSheetEntryWhereUniqueInput!): TimeSheetEntry
  updateManyTimeSheetEntries(data: TimeSheetEntryUpdateManyMutationInput!, where: TimeSheetEntryWhereInput): BatchPayload!
  upsertTimeSheetEntry(where: TimeSheetEntryWhereUniqueInput!, create: TimeSheetEntryCreateInput!, update: TimeSheetEntryUpdateInput!): TimeSheetEntry!
  deleteTimeSheetEntry(where: TimeSheetEntryWhereUniqueInput!): TimeSheetEntry
  deleteManyTimeSheetEntries(where: TimeSheetEntryWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVaccineBrand(data: VaccineBrandCreateInput!): VaccineBrand!
  updateVaccineBrand(data: VaccineBrandUpdateInput!, where: VaccineBrandWhereUniqueInput!): VaccineBrand
  updateManyVaccineBrands(data: VaccineBrandUpdateManyMutationInput!, where: VaccineBrandWhereInput): BatchPayload!
  upsertVaccineBrand(where: VaccineBrandWhereUniqueInput!, create: VaccineBrandCreateInput!, update: VaccineBrandUpdateInput!): VaccineBrand!
  deleteVaccineBrand(where: VaccineBrandWhereUniqueInput!): VaccineBrand
  deleteManyVaccineBrands(where: VaccineBrandWhereInput): BatchPayload!
  createWareHouse(data: WareHouseCreateInput!): WareHouse!
  updateWareHouse(data: WareHouseUpdateInput!, where: WareHouseWhereUniqueInput!): WareHouse
  updateManyWareHouses(data: WareHouseUpdateManyMutationInput!, where: WareHouseWhereInput): BatchPayload!
  upsertWareHouse(where: WareHouseWhereUniqueInput!, create: WareHouseCreateInput!, update: WareHouseUpdateInput!): WareHouse!
  deleteWareHouse(where: WareHouseWhereUniqueInput!): WareHouse
  deleteManyWareHouses(where: WareHouseWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Name {
  id: ID!
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type NameConnection {
  pageInfo: PageInfo!
  edges: [NameEdge]!
  aggregate: AggregateName!
}

input NameCreateInput {
  id: ID
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input NameCreateManyInput {
  create: [NameCreateInput!]
  connect: [NameWhereUniqueInput!]
}

type NameEdge {
  node: Name!
  cursor: String!
}

enum NameOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isPrimary_ASC
  isPrimary_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NamePreviousValues {
  id: ID!
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input NameScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isPrimary: Boolean
  isPrimary_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NameScalarWhereInput!]
  OR: [NameScalarWhereInput!]
  NOT: [NameScalarWhereInput!]
}

type NameSubscriptionPayload {
  mutation: MutationType!
  node: Name
  updatedFields: [String!]
  previousValues: NamePreviousValues
}

input NameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NameWhereInput
  AND: [NameSubscriptionWhereInput!]
  OR: [NameSubscriptionWhereInput!]
  NOT: [NameSubscriptionWhereInput!]
}

input NameUpdateDataInput {
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input NameUpdateInput {
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input NameUpdateManyDataInput {
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input NameUpdateManyInput {
  create: [NameCreateInput!]
  update: [NameUpdateWithWhereUniqueNestedInput!]
  upsert: [NameUpsertWithWhereUniqueNestedInput!]
  delete: [NameWhereUniqueInput!]
  connect: [NameWhereUniqueInput!]
  set: [NameWhereUniqueInput!]
  disconnect: [NameWhereUniqueInput!]
  deleteMany: [NameScalarWhereInput!]
  updateMany: [NameUpdateManyWithWhereNestedInput!]
}

input NameUpdateManyMutationInput {
  name: String
  isPrimary: Boolean
  isArchived: Boolean
  isDeleted: Boolean
}

input NameUpdateManyWithWhereNestedInput {
  where: NameScalarWhereInput!
  data: NameUpdateManyDataInput!
}

input NameUpdateWithWhereUniqueNestedInput {
  where: NameWhereUniqueInput!
  data: NameUpdateDataInput!
}

input NameUpsertWithWhereUniqueNestedInput {
  where: NameWhereUniqueInput!
  update: NameUpdateDataInput!
  create: NameCreateInput!
}

input NameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  isPrimary: Boolean
  isPrimary_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NameWhereInput!]
  OR: [NameWhereInput!]
  NOT: [NameWhereInput!]
}

input NameWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Patient {
  id: ID!
  title: String
  firstName: String
  lastName: String
  names(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Name!]
  address: Address
  birthAddress: Address
  dateOfBirth: DateTime
  customer: Customer
  gender: Gender
  dvaCardType: DVACardType
  aboriginalStatus: AboriginalStatus
  pensionerConcession: String
  commonwealthSeniors: String
  healthcareConcession: String
  safetyNetConcession: Float
  medicareNumber: String
  DVA: String
  potentialDuplicate: Boolean
  oneName: Boolean
  ihi: String
  ihiValidatedDate: DateTime
  noOfBirths: Int
  deceasedDate: DateTime
  basicDailyFee(where: BasicDailyFeeWhereInput, orderBy: BasicDailyFeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BasicDailyFee!]
  levelOfCare: LevelOfCare
  dateEnteredAgedCare: DateTime
  company: Company
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PatientConnection {
  pageInfo: PageInfo!
  edges: [PatientEdge]!
  aggregate: AggregatePatient!
}

input PatientCreateInput {
  id: ID
  title: String
  firstName: String
  lastName: String
  names: NameCreateManyInput
  address: AddressCreateOneInput
  birthAddress: AddressCreateOneInput
  dateOfBirth: DateTime
  customer: CustomerCreateOneInput
  gender: Gender
  dvaCardType: DVACardType
  aboriginalStatus: AboriginalStatus
  pensionerConcession: String
  commonwealthSeniors: String
  healthcareConcession: String
  safetyNetConcession: Float
  medicareNumber: String
  DVA: String
  potentialDuplicate: Boolean
  oneName: Boolean
  ihi: String
  ihiValidatedDate: DateTime
  noOfBirths: Int
  deceasedDate: DateTime
  basicDailyFee: BasicDailyFeeCreateManyInput
  levelOfCare: LevelOfCare
  dateEnteredAgedCare: DateTime
  company: CompanyCreateOneInput
  isArchived: Boolean
  isDeleted: Boolean
}

type PatientEdge {
  node: Patient!
  cursor: String!
}

enum PatientOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  gender_ASC
  gender_DESC
  dvaCardType_ASC
  dvaCardType_DESC
  aboriginalStatus_ASC
  aboriginalStatus_DESC
  pensionerConcession_ASC
  pensionerConcession_DESC
  commonwealthSeniors_ASC
  commonwealthSeniors_DESC
  healthcareConcession_ASC
  healthcareConcession_DESC
  safetyNetConcession_ASC
  safetyNetConcession_DESC
  medicareNumber_ASC
  medicareNumber_DESC
  DVA_ASC
  DVA_DESC
  potentialDuplicate_ASC
  potentialDuplicate_DESC
  oneName_ASC
  oneName_DESC
  ihi_ASC
  ihi_DESC
  ihiValidatedDate_ASC
  ihiValidatedDate_DESC
  noOfBirths_ASC
  noOfBirths_DESC
  deceasedDate_ASC
  deceasedDate_DESC
  levelOfCare_ASC
  levelOfCare_DESC
  dateEnteredAgedCare_ASC
  dateEnteredAgedCare_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PatientPreviousValues {
  id: ID!
  title: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  gender: Gender
  dvaCardType: DVACardType
  aboriginalStatus: AboriginalStatus
  pensionerConcession: String
  commonwealthSeniors: String
  healthcareConcession: String
  safetyNetConcession: Float
  medicareNumber: String
  DVA: String
  potentialDuplicate: Boolean
  oneName: Boolean
  ihi: String
  ihiValidatedDate: DateTime
  noOfBirths: Int
  deceasedDate: DateTime
  levelOfCare: LevelOfCare
  dateEnteredAgedCare: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PatientSubscriptionPayload {
  mutation: MutationType!
  node: Patient
  updatedFields: [String!]
  previousValues: PatientPreviousValues
}

input PatientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PatientWhereInput
  AND: [PatientSubscriptionWhereInput!]
  OR: [PatientSubscriptionWhereInput!]
  NOT: [PatientSubscriptionWhereInput!]
}

input PatientUpdateInput {
  title: String
  firstName: String
  lastName: String
  names: NameUpdateManyInput
  address: AddressUpdateOneInput
  birthAddress: AddressUpdateOneInput
  dateOfBirth: DateTime
  customer: CustomerUpdateOneInput
  gender: Gender
  dvaCardType: DVACardType
  aboriginalStatus: AboriginalStatus
  pensionerConcession: String
  commonwealthSeniors: String
  healthcareConcession: String
  safetyNetConcession: Float
  medicareNumber: String
  DVA: String
  potentialDuplicate: Boolean
  oneName: Boolean
  ihi: String
  ihiValidatedDate: DateTime
  noOfBirths: Int
  deceasedDate: DateTime
  basicDailyFee: BasicDailyFeeUpdateManyInput
  levelOfCare: LevelOfCare
  dateEnteredAgedCare: DateTime
  company: CompanyUpdateOneInput
  isArchived: Boolean
  isDeleted: Boolean
}

input PatientUpdateManyMutationInput {
  title: String
  firstName: String
  lastName: String
  dateOfBirth: DateTime
  gender: Gender
  dvaCardType: DVACardType
  aboriginalStatus: AboriginalStatus
  pensionerConcession: String
  commonwealthSeniors: String
  healthcareConcession: String
  safetyNetConcession: Float
  medicareNumber: String
  DVA: String
  potentialDuplicate: Boolean
  oneName: Boolean
  ihi: String
  ihiValidatedDate: DateTime
  noOfBirths: Int
  deceasedDate: DateTime
  levelOfCare: LevelOfCare
  dateEnteredAgedCare: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PatientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  names_every: NameWhereInput
  names_some: NameWhereInput
  names_none: NameWhereInput
  address: AddressWhereInput
  birthAddress: AddressWhereInput
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  customer: CustomerWhereInput
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  dvaCardType: DVACardType
  dvaCardType_not: DVACardType
  dvaCardType_in: [DVACardType!]
  dvaCardType_not_in: [DVACardType!]
  aboriginalStatus: AboriginalStatus
  aboriginalStatus_not: AboriginalStatus
  aboriginalStatus_in: [AboriginalStatus!]
  aboriginalStatus_not_in: [AboriginalStatus!]
  pensionerConcession: String
  pensionerConcession_not: String
  pensionerConcession_in: [String!]
  pensionerConcession_not_in: [String!]
  pensionerConcession_lt: String
  pensionerConcession_lte: String
  pensionerConcession_gt: String
  pensionerConcession_gte: String
  pensionerConcession_contains: String
  pensionerConcession_not_contains: String
  pensionerConcession_starts_with: String
  pensionerConcession_not_starts_with: String
  pensionerConcession_ends_with: String
  pensionerConcession_not_ends_with: String
  commonwealthSeniors: String
  commonwealthSeniors_not: String
  commonwealthSeniors_in: [String!]
  commonwealthSeniors_not_in: [String!]
  commonwealthSeniors_lt: String
  commonwealthSeniors_lte: String
  commonwealthSeniors_gt: String
  commonwealthSeniors_gte: String
  commonwealthSeniors_contains: String
  commonwealthSeniors_not_contains: String
  commonwealthSeniors_starts_with: String
  commonwealthSeniors_not_starts_with: String
  commonwealthSeniors_ends_with: String
  commonwealthSeniors_not_ends_with: String
  healthcareConcession: String
  healthcareConcession_not: String
  healthcareConcession_in: [String!]
  healthcareConcession_not_in: [String!]
  healthcareConcession_lt: String
  healthcareConcession_lte: String
  healthcareConcession_gt: String
  healthcareConcession_gte: String
  healthcareConcession_contains: String
  healthcareConcession_not_contains: String
  healthcareConcession_starts_with: String
  healthcareConcession_not_starts_with: String
  healthcareConcession_ends_with: String
  healthcareConcession_not_ends_with: String
  safetyNetConcession: Float
  safetyNetConcession_not: Float
  safetyNetConcession_in: [Float!]
  safetyNetConcession_not_in: [Float!]
  safetyNetConcession_lt: Float
  safetyNetConcession_lte: Float
  safetyNetConcession_gt: Float
  safetyNetConcession_gte: Float
  medicareNumber: String
  medicareNumber_not: String
  medicareNumber_in: [String!]
  medicareNumber_not_in: [String!]
  medicareNumber_lt: String
  medicareNumber_lte: String
  medicareNumber_gt: String
  medicareNumber_gte: String
  medicareNumber_contains: String
  medicareNumber_not_contains: String
  medicareNumber_starts_with: String
  medicareNumber_not_starts_with: String
  medicareNumber_ends_with: String
  medicareNumber_not_ends_with: String
  DVA: String
  DVA_not: String
  DVA_in: [String!]
  DVA_not_in: [String!]
  DVA_lt: String
  DVA_lte: String
  DVA_gt: String
  DVA_gte: String
  DVA_contains: String
  DVA_not_contains: String
  DVA_starts_with: String
  DVA_not_starts_with: String
  DVA_ends_with: String
  DVA_not_ends_with: String
  potentialDuplicate: Boolean
  potentialDuplicate_not: Boolean
  oneName: Boolean
  oneName_not: Boolean
  ihi: String
  ihi_not: String
  ihi_in: [String!]
  ihi_not_in: [String!]
  ihi_lt: String
  ihi_lte: String
  ihi_gt: String
  ihi_gte: String
  ihi_contains: String
  ihi_not_contains: String
  ihi_starts_with: String
  ihi_not_starts_with: String
  ihi_ends_with: String
  ihi_not_ends_with: String
  ihiValidatedDate: DateTime
  ihiValidatedDate_not: DateTime
  ihiValidatedDate_in: [DateTime!]
  ihiValidatedDate_not_in: [DateTime!]
  ihiValidatedDate_lt: DateTime
  ihiValidatedDate_lte: DateTime
  ihiValidatedDate_gt: DateTime
  ihiValidatedDate_gte: DateTime
  noOfBirths: Int
  noOfBirths_not: Int
  noOfBirths_in: [Int!]
  noOfBirths_not_in: [Int!]
  noOfBirths_lt: Int
  noOfBirths_lte: Int
  noOfBirths_gt: Int
  noOfBirths_gte: Int
  deceasedDate: DateTime
  deceasedDate_not: DateTime
  deceasedDate_in: [DateTime!]
  deceasedDate_not_in: [DateTime!]
  deceasedDate_lt: DateTime
  deceasedDate_lte: DateTime
  deceasedDate_gt: DateTime
  deceasedDate_gte: DateTime
  basicDailyFee_every: BasicDailyFeeWhereInput
  basicDailyFee_some: BasicDailyFeeWhereInput
  basicDailyFee_none: BasicDailyFeeWhereInput
  levelOfCare: LevelOfCare
  levelOfCare_not: LevelOfCare
  levelOfCare_in: [LevelOfCare!]
  levelOfCare_not_in: [LevelOfCare!]
  dateEnteredAgedCare: DateTime
  dateEnteredAgedCare_not: DateTime
  dateEnteredAgedCare_in: [DateTime!]
  dateEnteredAgedCare_not_in: [DateTime!]
  dateEnteredAgedCare_lt: DateTime
  dateEnteredAgedCare_lte: DateTime
  dateEnteredAgedCare_gt: DateTime
  dateEnteredAgedCare_gte: DateTime
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PatientWhereInput!]
  OR: [PatientWhereInput!]
  NOT: [PatientWhereInput!]
}

input PatientWhereUniqueInput {
  id: ID
}

type PbsOrganisation {
  id: ID!
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PbsOrganisationConnection {
  pageInfo: PageInfo!
  edges: [PbsOrganisationEdge]!
  aggregate: AggregatePbsOrganisation!
}

input PbsOrganisationCreateInput {
  id: ID
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsOrganisationCreateOneInput {
  create: PbsOrganisationCreateInput
  connect: PbsOrganisationWhereUniqueInput
}

type PbsOrganisationEdge {
  node: PbsOrganisation!
  cursor: String!
}

enum PbsOrganisationOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  title_ASC
  title_DESC
  street_ASC
  street_DESC
  city_ASC
  city_DESC
  stateAddress_ASC
  stateAddress_DESC
  postcode_ASC
  postcode_DESC
  phone_ASC
  phone_DESC
  effectiveFrom_ASC
  effectiveFrom_DESC
  effectiveTo_ASC
  effectiveTo_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PbsOrganisationPreviousValues {
  id: ID!
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PbsOrganisationSubscriptionPayload {
  mutation: MutationType!
  node: PbsOrganisation
  updatedFields: [String!]
  previousValues: PbsOrganisationPreviousValues
}

input PbsOrganisationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PbsOrganisationWhereInput
  AND: [PbsOrganisationSubscriptionWhereInput!]
  OR: [PbsOrganisationSubscriptionWhereInput!]
  NOT: [PbsOrganisationSubscriptionWhereInput!]
}

input PbsOrganisationUpdateDataInput {
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsOrganisationUpdateInput {
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsOrganisationUpdateManyMutationInput {
  code: String
  title: String
  street: String
  city: String
  stateAddress: String
  postcode: String
  phone: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsOrganisationUpdateOneInput {
  create: PbsOrganisationCreateInput
  update: PbsOrganisationUpdateDataInput
  upsert: PbsOrganisationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PbsOrganisationWhereUniqueInput
}

input PbsOrganisationUpsertNestedInput {
  update: PbsOrganisationUpdateDataInput!
  create: PbsOrganisationCreateInput!
}

input PbsOrganisationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  stateAddress: String
  stateAddress_not: String
  stateAddress_in: [String!]
  stateAddress_not_in: [String!]
  stateAddress_lt: String
  stateAddress_lte: String
  stateAddress_gt: String
  stateAddress_gte: String
  stateAddress_contains: String
  stateAddress_not_contains: String
  stateAddress_starts_with: String
  stateAddress_not_starts_with: String
  stateAddress_ends_with: String
  stateAddress_not_ends_with: String
  postcode: String
  postcode_not: String
  postcode_in: [String!]
  postcode_not_in: [String!]
  postcode_lt: String
  postcode_lte: String
  postcode_gt: String
  postcode_gte: String
  postcode_contains: String
  postcode_not_contains: String
  postcode_starts_with: String
  postcode_not_starts_with: String
  postcode_ends_with: String
  postcode_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  effectiveFrom: DateTime
  effectiveFrom_not: DateTime
  effectiveFrom_in: [DateTime!]
  effectiveFrom_not_in: [DateTime!]
  effectiveFrom_lt: DateTime
  effectiveFrom_lte: DateTime
  effectiveFrom_gt: DateTime
  effectiveFrom_gte: DateTime
  effectiveTo: DateTime
  effectiveTo_not: DateTime
  effectiveTo_in: [DateTime!]
  effectiveTo_not_in: [DateTime!]
  effectiveTo_lt: DateTime
  effectiveTo_lte: DateTime
  effectiveTo_gt: DateTime
  effectiveTo_gte: DateTime
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PbsOrganisationWhereInput!]
  OR: [PbsOrganisationWhereInput!]
  NOT: [PbsOrganisationWhereInput!]
}

input PbsOrganisationWhereUniqueInput {
  id: ID
}

enum PBSPricingModel {
  EX_MANUFACTURER
  AEMP
  PEMP
  PUEMP
  PREMP
  READY_PREPARED
  READY_PREPARED_NO_PREMIUM
  READY_PREPARED_NO_PREMIUM_NO_CHARGE
  INFUSIBLE
  EXTEMPORANEOUS
}

type PbsTPP {
  id: ID!
  snomedCode: String
  clinicalPreferredTerm: String
  packSize: Int
  brandName: String
  exManufacturerPrice: Float
  pricingModel: PBSPricingModel
  mpp_id: String
  organisation_id: PbsOrganisation
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PbsTPPConnection {
  pageInfo: PageInfo!
  edges: [PbsTPPEdge]!
  aggregate: AggregatePbsTPP!
}

input PbsTPPCreateInput {
  id: ID
  snomedCode: String
  clinicalPreferredTerm: String
  packSize: Int
  brandName: String
  exManufacturerPrice: Float
  pricingModel: PBSPricingModel
  mpp_id: String
  organisation_id: PbsOrganisationCreateOneInput
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

type PbsTPPEdge {
  node: PbsTPP!
  cursor: String!
}

enum PbsTPPOrderByInput {
  id_ASC
  id_DESC
  snomedCode_ASC
  snomedCode_DESC
  clinicalPreferredTerm_ASC
  clinicalPreferredTerm_DESC
  packSize_ASC
  packSize_DESC
  brandName_ASC
  brandName_DESC
  exManufacturerPrice_ASC
  exManufacturerPrice_DESC
  pricingModel_ASC
  pricingModel_DESC
  mpp_id_ASC
  mpp_id_DESC
  effectiveFrom_ASC
  effectiveFrom_DESC
  effectiveTo_ASC
  effectiveTo_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PbsTPPPreviousValues {
  id: ID!
  snomedCode: String
  clinicalPreferredTerm: String
  packSize: Int
  brandName: String
  exManufacturerPrice: Float
  pricingModel: PBSPricingModel
  mpp_id: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PbsTPPSubscriptionPayload {
  mutation: MutationType!
  node: PbsTPP
  updatedFields: [String!]
  previousValues: PbsTPPPreviousValues
}

input PbsTPPSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PbsTPPWhereInput
  AND: [PbsTPPSubscriptionWhereInput!]
  OR: [PbsTPPSubscriptionWhereInput!]
  NOT: [PbsTPPSubscriptionWhereInput!]
}

input PbsTPPUpdateInput {
  snomedCode: String
  clinicalPreferredTerm: String
  packSize: Int
  brandName: String
  exManufacturerPrice: Float
  pricingModel: PBSPricingModel
  mpp_id: String
  organisation_id: PbsOrganisationUpdateOneInput
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsTPPUpdateManyMutationInput {
  snomedCode: String
  clinicalPreferredTerm: String
  packSize: Int
  brandName: String
  exManufacturerPrice: Float
  pricingModel: PBSPricingModel
  mpp_id: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PbsTPPWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  snomedCode: String
  snomedCode_not: String
  snomedCode_in: [String!]
  snomedCode_not_in: [String!]
  snomedCode_lt: String
  snomedCode_lte: String
  snomedCode_gt: String
  snomedCode_gte: String
  snomedCode_contains: String
  snomedCode_not_contains: String
  snomedCode_starts_with: String
  snomedCode_not_starts_with: String
  snomedCode_ends_with: String
  snomedCode_not_ends_with: String
  clinicalPreferredTerm: String
  clinicalPreferredTerm_not: String
  clinicalPreferredTerm_in: [String!]
  clinicalPreferredTerm_not_in: [String!]
  clinicalPreferredTerm_lt: String
  clinicalPreferredTerm_lte: String
  clinicalPreferredTerm_gt: String
  clinicalPreferredTerm_gte: String
  clinicalPreferredTerm_contains: String
  clinicalPreferredTerm_not_contains: String
  clinicalPreferredTerm_starts_with: String
  clinicalPreferredTerm_not_starts_with: String
  clinicalPreferredTerm_ends_with: String
  clinicalPreferredTerm_not_ends_with: String
  packSize: Int
  packSize_not: Int
  packSize_in: [Int!]
  packSize_not_in: [Int!]
  packSize_lt: Int
  packSize_lte: Int
  packSize_gt: Int
  packSize_gte: Int
  brandName: String
  brandName_not: String
  brandName_in: [String!]
  brandName_not_in: [String!]
  brandName_lt: String
  brandName_lte: String
  brandName_gt: String
  brandName_gte: String
  brandName_contains: String
  brandName_not_contains: String
  brandName_starts_with: String
  brandName_not_starts_with: String
  brandName_ends_with: String
  brandName_not_ends_with: String
  exManufacturerPrice: Float
  exManufacturerPrice_not: Float
  exManufacturerPrice_in: [Float!]
  exManufacturerPrice_not_in: [Float!]
  exManufacturerPrice_lt: Float
  exManufacturerPrice_lte: Float
  exManufacturerPrice_gt: Float
  exManufacturerPrice_gte: Float
  pricingModel: PBSPricingModel
  pricingModel_not: PBSPricingModel
  pricingModel_in: [PBSPricingModel!]
  pricingModel_not_in: [PBSPricingModel!]
  mpp_id: String
  mpp_id_not: String
  mpp_id_in: [String!]
  mpp_id_not_in: [String!]
  mpp_id_lt: String
  mpp_id_lte: String
  mpp_id_gt: String
  mpp_id_gte: String
  mpp_id_contains: String
  mpp_id_not_contains: String
  mpp_id_starts_with: String
  mpp_id_not_starts_with: String
  mpp_id_ends_with: String
  mpp_id_not_ends_with: String
  organisation_id: PbsOrganisationWhereInput
  effectiveFrom: DateTime
  effectiveFrom_not: DateTime
  effectiveFrom_in: [DateTime!]
  effectiveFrom_not_in: [DateTime!]
  effectiveFrom_lt: DateTime
  effectiveFrom_lte: DateTime
  effectiveFrom_gt: DateTime
  effectiveFrom_gte: DateTime
  effectiveTo: DateTime
  effectiveTo_not: DateTime
  effectiveTo_in: [DateTime!]
  effectiveTo_not_in: [DateTime!]
  effectiveTo_lt: DateTime
  effectiveTo_lte: DateTime
  effectiveTo_gt: DateTime
  effectiveTo_gte: DateTime
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PbsTPPWhereInput!]
  OR: [PbsTPPWhereInput!]
  NOT: [PbsTPPWhereInput!]
}

input PbsTPPWhereUniqueInput {
  id: ID
}

enum PeriodUnit {
  WEEKS
  MONTHS
  YEARS
}

type Plan {
  id: ID!
  company: Company!
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlanConnection {
  pageInfo: PageInfo!
  edges: [PlanEdge]!
  aggregate: AggregatePlan!
}

input PlanCreateInput {
  id: ID
  company: CompanyCreateOneWithoutActivePlanInput!
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency!
}

input PlanCreateOneWithoutCompanyInput {
  create: PlanCreateWithoutCompanyInput
  connect: PlanWhereUniqueInput
}

input PlanCreateWithoutCompanyInput {
  id: ID
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency!
}

type PlanEdge {
  node: Plan!
  cursor: String!
}

enum PlanOrderByInput {
  id_ASC
  id_DESC
  isActive_ASC
  isActive_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  price_ASC
  price_DESC
  type_ASC
  type_DESC
  currency_ASC
  currency_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PlanPreviousValues {
  id: ID!
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlanSubscriptionPayload {
  mutation: MutationType!
  node: Plan
  updatedFields: [String!]
  previousValues: PlanPreviousValues
}

input PlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlanWhereInput
  AND: [PlanSubscriptionWhereInput!]
  OR: [PlanSubscriptionWhereInput!]
  NOT: [PlanSubscriptionWhereInput!]
}

enum PlanType {
  FREE
  PRO
  ENTERPRISE
}

input PlanUpdateInput {
  company: CompanyUpdateOneRequiredWithoutActivePlanInput
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency
}

input PlanUpdateManyMutationInput {
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency
}

input PlanUpdateOneWithoutCompanyInput {
  create: PlanCreateWithoutCompanyInput
  update: PlanUpdateWithoutCompanyDataInput
  upsert: PlanUpsertWithoutCompanyInput
  delete: Boolean
  disconnect: Boolean
  connect: PlanWhereUniqueInput
}

input PlanUpdateWithoutCompanyDataInput {
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  price: Float
  type: PlanType
  currency: Currency
}

input PlanUpsertWithoutCompanyInput {
  update: PlanUpdateWithoutCompanyDataInput!
  create: PlanCreateWithoutCompanyInput!
}

input PlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  company: CompanyWhereInput
  isActive: Boolean
  isActive_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  type: PlanType
  type_not: PlanType
  type_in: [PlanType!]
  type_not_in: [PlanType!]
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PlanWhereInput!]
  OR: [PlanWhereInput!]
  NOT: [PlanWhereInput!]
}

input PlanWhereUniqueInput {
  id: ID
}

type PoReceipt {
  id: ID!
  receiptNumber: String
  purchaseOrder: PurchaseOrder
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PoReceiptConnection {
  pageInfo: PageInfo!
  edges: [PoReceiptEdge]!
  aggregate: AggregatePoReceipt!
}

input PoReceiptCreateInput {
  id: ID
  receiptNumber: String
  purchaseOrder: PurchaseOrderCreateOneInput
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PoReceiptCreateOneInput {
  create: PoReceiptCreateInput
  connect: PoReceiptWhereUniqueInput
}

type PoReceiptEdge {
  node: PoReceipt!
  cursor: String!
}

enum PoReceiptOrderByInput {
  id_ASC
  id_DESC
  receiptNumber_ASC
  receiptNumber_DESC
  receiptDate_ASC
  receiptDate_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PoReceiptPreviousValues {
  id: ID!
  receiptNumber: String
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PoReceiptSubscriptionPayload {
  mutation: MutationType!
  node: PoReceipt
  updatedFields: [String!]
  previousValues: PoReceiptPreviousValues
}

input PoReceiptSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PoReceiptWhereInput
  AND: [PoReceiptSubscriptionWhereInput!]
  OR: [PoReceiptSubscriptionWhereInput!]
  NOT: [PoReceiptSubscriptionWhereInput!]
}

input PoReceiptUpdateDataInput {
  receiptNumber: String
  purchaseOrder: PurchaseOrderUpdateOneInput
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PoReceiptUpdateInput {
  receiptNumber: String
  purchaseOrder: PurchaseOrderUpdateOneInput
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PoReceiptUpdateManyMutationInput {
  receiptNumber: String
  receiptDate: DateTime
  isArchived: Boolean
  isDeleted: Boolean
}

input PoReceiptUpdateOneInput {
  create: PoReceiptCreateInput
  update: PoReceiptUpdateDataInput
  upsert: PoReceiptUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PoReceiptWhereUniqueInput
}

input PoReceiptUpsertNestedInput {
  update: PoReceiptUpdateDataInput!
  create: PoReceiptCreateInput!
}

input PoReceiptWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  receiptNumber: String
  receiptNumber_not: String
  receiptNumber_in: [String!]
  receiptNumber_not_in: [String!]
  receiptNumber_lt: String
  receiptNumber_lte: String
  receiptNumber_gt: String
  receiptNumber_gte: String
  receiptNumber_contains: String
  receiptNumber_not_contains: String
  receiptNumber_starts_with: String
  receiptNumber_not_starts_with: String
  receiptNumber_ends_with: String
  receiptNumber_not_ends_with: String
  purchaseOrder: PurchaseOrderWhereInput
  receiptDate: DateTime
  receiptDate_not: DateTime
  receiptDate_in: [DateTime!]
  receiptDate_not_in: [DateTime!]
  receiptDate_lt: DateTime
  receiptDate_lte: DateTime
  receiptDate_gt: DateTime
  receiptDate_gte: DateTime
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PoReceiptWhereInput!]
  OR: [PoReceiptWhereInput!]
  NOT: [PoReceiptWhereInput!]
}

input PoReceiptWhereUniqueInput {
  id: ID
}

enum PoStatus {
  OPEN
  CONFIRMED
  DELIVERED
  PARTIALLY_DELIVERED
  PACKED
  PARTIALLY_PACKED
  INVOICED
  RECEIPTED
}

enum PostingType {
  DRCONTROL
  BANK
  REVENUE
  TAXPAYABLE
  TAXRECEIVABLE
}

type PredictedSalesQuantityOfItemsByCompany {
  id: ID!
  datePredictionRun: DateTime
  company: Company!
  inventory: Inventory
  predictedSalesValue: Float
  predictedDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PredictedSalesQuantityOfItemsByCompanyConnection {
  pageInfo: PageInfo!
  edges: [PredictedSalesQuantityOfItemsByCompanyEdge]!
  aggregate: AggregatePredictedSalesQuantityOfItemsByCompany!
}

input PredictedSalesQuantityOfItemsByCompanyCreateInput {
  id: ID
  datePredictionRun: DateTime
  company: CompanyCreateOneInput!
  inventory: InventoryCreateOneInput
  predictedSalesValue: Float
  predictedDate: DateTime
}

type PredictedSalesQuantityOfItemsByCompanyEdge {
  node: PredictedSalesQuantityOfItemsByCompany!
  cursor: String!
}

enum PredictedSalesQuantityOfItemsByCompanyOrderByInput {
  id_ASC
  id_DESC
  datePredictionRun_ASC
  datePredictionRun_DESC
  predictedSalesValue_ASC
  predictedSalesValue_DESC
  predictedDate_ASC
  predictedDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PredictedSalesQuantityOfItemsByCompanyPreviousValues {
  id: ID!
  datePredictionRun: DateTime
  predictedSalesValue: Float
  predictedDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PredictedSalesQuantityOfItemsByCompanySubscriptionPayload {
  mutation: MutationType!
  node: PredictedSalesQuantityOfItemsByCompany
  updatedFields: [String!]
  previousValues: PredictedSalesQuantityOfItemsByCompanyPreviousValues
}

input PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PredictedSalesQuantityOfItemsByCompanyWhereInput
  AND: [PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput!]
  OR: [PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput!]
  NOT: [PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput!]
}

input PredictedSalesQuantityOfItemsByCompanyUpdateInput {
  datePredictionRun: DateTime
  company: CompanyUpdateOneRequiredInput
  inventory: InventoryUpdateOneInput
  predictedSalesValue: Float
  predictedDate: DateTime
}

input PredictedSalesQuantityOfItemsByCompanyUpdateManyMutationInput {
  datePredictionRun: DateTime
  predictedSalesValue: Float
  predictedDate: DateTime
}

input PredictedSalesQuantityOfItemsByCompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  datePredictionRun: DateTime
  datePredictionRun_not: DateTime
  datePredictionRun_in: [DateTime!]
  datePredictionRun_not_in: [DateTime!]
  datePredictionRun_lt: DateTime
  datePredictionRun_lte: DateTime
  datePredictionRun_gt: DateTime
  datePredictionRun_gte: DateTime
  company: CompanyWhereInput
  inventory: InventoryWhereInput
  predictedSalesValue: Float
  predictedSalesValue_not: Float
  predictedSalesValue_in: [Float!]
  predictedSalesValue_not_in: [Float!]
  predictedSalesValue_lt: Float
  predictedSalesValue_lte: Float
  predictedSalesValue_gt: Float
  predictedSalesValue_gte: Float
  predictedDate: DateTime
  predictedDate_not: DateTime
  predictedDate_in: [DateTime!]
  predictedDate_not_in: [DateTime!]
  predictedDate_lt: DateTime
  predictedDate_lte: DateTime
  predictedDate_gt: DateTime
  predictedDate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PredictedSalesQuantityOfItemsByCompanyWhereInput!]
  OR: [PredictedSalesQuantityOfItemsByCompanyWhereInput!]
  NOT: [PredictedSalesQuantityOfItemsByCompanyWhereInput!]
}

input PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput {
  id: ID
}

type PredictedSalesValueByCompany {
  id: ID!
  datePredictionRun: DateTime
  company: Company!
  predictedSalesValue: Float
  predictedDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PredictedSalesValueByCompanyConnection {
  pageInfo: PageInfo!
  edges: [PredictedSalesValueByCompanyEdge]!
  aggregate: AggregatePredictedSalesValueByCompany!
}

input PredictedSalesValueByCompanyCreateInput {
  id: ID
  datePredictionRun: DateTime
  company: CompanyCreateOneInput!
  predictedSalesValue: Float
  predictedDate: DateTime
}

type PredictedSalesValueByCompanyEdge {
  node: PredictedSalesValueByCompany!
  cursor: String!
}

enum PredictedSalesValueByCompanyOrderByInput {
  id_ASC
  id_DESC
  datePredictionRun_ASC
  datePredictionRun_DESC
  predictedSalesValue_ASC
  predictedSalesValue_DESC
  predictedDate_ASC
  predictedDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PredictedSalesValueByCompanyPreviousValues {
  id: ID!
  datePredictionRun: DateTime
  predictedSalesValue: Float
  predictedDate: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PredictedSalesValueByCompanySubscriptionPayload {
  mutation: MutationType!
  node: PredictedSalesValueByCompany
  updatedFields: [String!]
  previousValues: PredictedSalesValueByCompanyPreviousValues
}

input PredictedSalesValueByCompanySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PredictedSalesValueByCompanyWhereInput
  AND: [PredictedSalesValueByCompanySubscriptionWhereInput!]
  OR: [PredictedSalesValueByCompanySubscriptionWhereInput!]
  NOT: [PredictedSalesValueByCompanySubscriptionWhereInput!]
}

input PredictedSalesValueByCompanyUpdateInput {
  datePredictionRun: DateTime
  company: CompanyUpdateOneRequiredInput
  predictedSalesValue: Float
  predictedDate: DateTime
}

input PredictedSalesValueByCompanyUpdateManyMutationInput {
  datePredictionRun: DateTime
  predictedSalesValue: Float
  predictedDate: DateTime
}

input PredictedSalesValueByCompanyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  datePredictionRun: DateTime
  datePredictionRun_not: DateTime
  datePredictionRun_in: [DateTime!]
  datePredictionRun_not_in: [DateTime!]
  datePredictionRun_lt: DateTime
  datePredictionRun_lte: DateTime
  datePredictionRun_gt: DateTime
  datePredictionRun_gte: DateTime
  company: CompanyWhereInput
  predictedSalesValue: Float
  predictedSalesValue_not: Float
  predictedSalesValue_in: [Float!]
  predictedSalesValue_not_in: [Float!]
  predictedSalesValue_lt: Float
  predictedSalesValue_lte: Float
  predictedSalesValue_gt: Float
  predictedSalesValue_gte: Float
  predictedDate: DateTime
  predictedDate_not: DateTime
  predictedDate_in: [DateTime!]
  predictedDate_not_in: [DateTime!]
  predictedDate_lt: DateTime
  predictedDate_lte: DateTime
  predictedDate_gt: DateTime
  predictedDate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PredictedSalesValueByCompanyWhereInput!]
  OR: [PredictedSalesValueByCompanyWhereInput!]
  NOT: [PredictedSalesValueByCompanyWhereInput!]
}

input PredictedSalesValueByCompanyWhereUniqueInput {
  id: ID
}

type Project {
  id: ID!
  company: Company!
  customer: Customer
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  projectService(where: ProjectServiceWhereInput, orderBy: ProjectServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectService!]
  startsAt: DateTime
  status: ProjectStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  company: CompanyCreateOneInput!
  customer: CustomerCreateOneInput
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  projectService: ProjectServiceCreateManyWithoutProjectInput
  startsAt: DateTime
  status: ProjectStatus
}

input ProjectCreateOneInput {
  create: ProjectCreateInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateOneWithoutProjectServiceInput {
  create: ProjectCreateWithoutProjectServiceInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutProjectServiceInput {
  id: ID
  company: CompanyCreateOneInput!
  customer: CustomerCreateOneInput
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  startsAt: DateTime
  status: ProjectStatus
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  endsAt_ASC
  endsAt_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  name_ASC
  name_DESC
  startsAt_ASC
  startsAt_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectPreviousValues {
  id: ID!
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  startsAt: DateTime
  status: ProjectStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectService {
  id: ID!
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  project: Project
  rules(where: ProjectServiceRuleWhereInput, orderBy: ProjectServiceRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectServiceRule!]
  service: Service
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectServiceConnection {
  pageInfo: PageInfo!
  edges: [ProjectServiceEdge]!
  aggregate: AggregateProjectService!
}

input ProjectServiceCreateInput {
  id: ID
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  project: ProjectCreateOneWithoutProjectServiceInput
  rules: ProjectServiceRuleCreateManyWithoutProjectServiceInput
  service: ServiceCreateOneInput
}

input ProjectServiceCreateManyWithoutProjectInput {
  create: [ProjectServiceCreateWithoutProjectInput!]
  connect: [ProjectServiceWhereUniqueInput!]
}

input ProjectServiceCreateOneWithoutRulesInput {
  create: ProjectServiceCreateWithoutRulesInput
  connect: ProjectServiceWhereUniqueInput
}

input ProjectServiceCreateWithoutProjectInput {
  id: ID
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  rules: ProjectServiceRuleCreateManyWithoutProjectServiceInput
  service: ServiceCreateOneInput
}

input ProjectServiceCreateWithoutRulesInput {
  id: ID
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  project: ProjectCreateOneWithoutProjectServiceInput
  service: ServiceCreateOneInput
}

type ProjectServiceEdge {
  node: ProjectService!
  cursor: String!
}

enum ProjectServiceOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectServicePreviousValues {
  id: ID!
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectServiceRule {
  id: ID!
  projectService: ProjectService
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProjectServiceRuleConnection {
  pageInfo: PageInfo!
  edges: [ProjectServiceRuleEdge]!
  aggregate: AggregateProjectServiceRule!
}

input ProjectServiceRuleCreateInput {
  id: ID
  projectService: ProjectServiceCreateOneWithoutRulesInput
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

input ProjectServiceRuleCreateManyWithoutProjectServiceInput {
  create: [ProjectServiceRuleCreateWithoutProjectServiceInput!]
  connect: [ProjectServiceRuleWhereUniqueInput!]
}

input ProjectServiceRuleCreateWithoutProjectServiceInput {
  id: ID
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

type ProjectServiceRuleEdge {
  node: ProjectServiceRule!
  cursor: String!
}

enum ProjectServiceRuleOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  percent_ASC
  percent_DESC
  type_ASC
  type_DESC
  isPercent_ASC
  isPercent_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProjectServiceRulePreviousValues {
  id: ID!
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProjectServiceRuleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  percent: Float
  percent_not: Float
  percent_in: [Float!]
  percent_not_in: [Float!]
  percent_lt: Float
  percent_lte: Float
  percent_gt: Float
  percent_gte: Float
  type: ProjectServiceRuleType
  type_not: ProjectServiceRuleType
  type_in: [ProjectServiceRuleType!]
  type_not_in: [ProjectServiceRuleType!]
  isPercent: Boolean
  isPercent_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectServiceRuleScalarWhereInput!]
  OR: [ProjectServiceRuleScalarWhereInput!]
  NOT: [ProjectServiceRuleScalarWhereInput!]
}

type ProjectServiceRuleSubscriptionPayload {
  mutation: MutationType!
  node: ProjectServiceRule
  updatedFields: [String!]
  previousValues: ProjectServiceRulePreviousValues
}

input ProjectServiceRuleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectServiceRuleWhereInput
  AND: [ProjectServiceRuleSubscriptionWhereInput!]
  OR: [ProjectServiceRuleSubscriptionWhereInput!]
  NOT: [ProjectServiceRuleSubscriptionWhereInput!]
}

enum ProjectServiceRuleType {
  PROJECT_ENDS
  PROJECT_STARTS
}

input ProjectServiceRuleUpdateInput {
  projectService: ProjectServiceUpdateOneWithoutRulesInput
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

input ProjectServiceRuleUpdateManyDataInput {
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

input ProjectServiceRuleUpdateManyMutationInput {
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

input ProjectServiceRuleUpdateManyWithoutProjectServiceInput {
  create: [ProjectServiceRuleCreateWithoutProjectServiceInput!]
  delete: [ProjectServiceRuleWhereUniqueInput!]
  connect: [ProjectServiceRuleWhereUniqueInput!]
  set: [ProjectServiceRuleWhereUniqueInput!]
  disconnect: [ProjectServiceRuleWhereUniqueInput!]
  update: [ProjectServiceRuleUpdateWithWhereUniqueWithoutProjectServiceInput!]
  upsert: [ProjectServiceRuleUpsertWithWhereUniqueWithoutProjectServiceInput!]
  deleteMany: [ProjectServiceRuleScalarWhereInput!]
  updateMany: [ProjectServiceRuleUpdateManyWithWhereNestedInput!]
}

input ProjectServiceRuleUpdateManyWithWhereNestedInput {
  where: ProjectServiceRuleScalarWhereInput!
  data: ProjectServiceRuleUpdateManyDataInput!
}

input ProjectServiceRuleUpdateWithoutProjectServiceDataInput {
  amount: Float
  percent: Float
  type: ProjectServiceRuleType
  isPercent: Boolean
}

input ProjectServiceRuleUpdateWithWhereUniqueWithoutProjectServiceInput {
  where: ProjectServiceRuleWhereUniqueInput!
  data: ProjectServiceRuleUpdateWithoutProjectServiceDataInput!
}

input ProjectServiceRuleUpsertWithWhereUniqueWithoutProjectServiceInput {
  where: ProjectServiceRuleWhereUniqueInput!
  update: ProjectServiceRuleUpdateWithoutProjectServiceDataInput!
  create: ProjectServiceRuleCreateWithoutProjectServiceInput!
}

input ProjectServiceRuleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  projectService: ProjectServiceWhereInput
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  percent: Float
  percent_not: Float
  percent_in: [Float!]
  percent_not_in: [Float!]
  percent_lt: Float
  percent_lte: Float
  percent_gt: Float
  percent_gte: Float
  type: ProjectServiceRuleType
  type_not: ProjectServiceRuleType
  type_in: [ProjectServiceRuleType!]
  type_not_in: [ProjectServiceRuleType!]
  isPercent: Boolean
  isPercent_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectServiceRuleWhereInput!]
  OR: [ProjectServiceRuleWhereInput!]
  NOT: [ProjectServiceRuleWhereInput!]
}

input ProjectServiceRuleWhereUniqueInput {
  id: ID
}

input ProjectServiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectServiceScalarWhereInput!]
  OR: [ProjectServiceScalarWhereInput!]
  NOT: [ProjectServiceScalarWhereInput!]
}

type ProjectServiceSubscriptionPayload {
  mutation: MutationType!
  node: ProjectService
  updatedFields: [String!]
  previousValues: ProjectServicePreviousValues
}

input ProjectServiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectServiceWhereInput
  AND: [ProjectServiceSubscriptionWhereInput!]
  OR: [ProjectServiceSubscriptionWhereInput!]
  NOT: [ProjectServiceSubscriptionWhereInput!]
}

input ProjectServiceUpdateInput {
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  project: ProjectUpdateOneWithoutProjectServiceInput
  rules: ProjectServiceRuleUpdateManyWithoutProjectServiceInput
  service: ServiceUpdateOneInput
}

input ProjectServiceUpdateManyDataInput {
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input ProjectServiceUpdateManyMutationInput {
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input ProjectServiceUpdateManyWithoutProjectInput {
  create: [ProjectServiceCreateWithoutProjectInput!]
  delete: [ProjectServiceWhereUniqueInput!]
  connect: [ProjectServiceWhereUniqueInput!]
  set: [ProjectServiceWhereUniqueInput!]
  disconnect: [ProjectServiceWhereUniqueInput!]
  update: [ProjectServiceUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [ProjectServiceUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [ProjectServiceScalarWhereInput!]
  updateMany: [ProjectServiceUpdateManyWithWhereNestedInput!]
}

input ProjectServiceUpdateManyWithWhereNestedInput {
  where: ProjectServiceScalarWhereInput!
  data: ProjectServiceUpdateManyDataInput!
}

input ProjectServiceUpdateOneWithoutRulesInput {
  create: ProjectServiceCreateWithoutRulesInput
  update: ProjectServiceUpdateWithoutRulesDataInput
  upsert: ProjectServiceUpsertWithoutRulesInput
  delete: Boolean
  disconnect: Boolean
  connect: ProjectServiceWhereUniqueInput
}

input ProjectServiceUpdateWithoutProjectDataInput {
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  rules: ProjectServiceRuleUpdateManyWithoutProjectServiceInput
  service: ServiceUpdateOneInput
}

input ProjectServiceUpdateWithoutRulesDataInput {
  amount: Float
  isArchived: Boolean
  isDeleted: Boolean
  project: ProjectUpdateOneWithoutProjectServiceInput
  service: ServiceUpdateOneInput
}

input ProjectServiceUpdateWithWhereUniqueWithoutProjectInput {
  where: ProjectServiceWhereUniqueInput!
  data: ProjectServiceUpdateWithoutProjectDataInput!
}

input ProjectServiceUpsertWithoutRulesInput {
  update: ProjectServiceUpdateWithoutRulesDataInput!
  create: ProjectServiceCreateWithoutRulesInput!
}

input ProjectServiceUpsertWithWhereUniqueWithoutProjectInput {
  where: ProjectServiceWhereUniqueInput!
  update: ProjectServiceUpdateWithoutProjectDataInput!
  create: ProjectServiceCreateWithoutProjectInput!
}

input ProjectServiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  project: ProjectWhereInput
  rules_every: ProjectServiceRuleWhereInput
  rules_some: ProjectServiceRuleWhereInput
  rules_none: ProjectServiceRuleWhereInput
  service: ServiceWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectServiceWhereInput!]
  OR: [ProjectServiceWhereInput!]
  NOT: [ProjectServiceWhereInput!]
}

input ProjectServiceWhereUniqueInput {
  id: ID
}

enum ProjectStatus {
  CLOSED
  STARTED
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateDataInput {
  company: CompanyUpdateOneRequiredInput
  customer: CustomerUpdateOneInput
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  projectService: ProjectServiceUpdateManyWithoutProjectInput
  startsAt: DateTime
  status: ProjectStatus
}

input ProjectUpdateInput {
  company: CompanyUpdateOneRequiredInput
  customer: CustomerUpdateOneInput
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  projectService: ProjectServiceUpdateManyWithoutProjectInput
  startsAt: DateTime
  status: ProjectStatus
}

input ProjectUpdateManyMutationInput {
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  startsAt: DateTime
  status: ProjectStatus
}

input ProjectUpdateOneInput {
  create: ProjectCreateInput
  update: ProjectUpdateDataInput
  upsert: ProjectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateOneWithoutProjectServiceInput {
  create: ProjectCreateWithoutProjectServiceInput
  update: ProjectUpdateWithoutProjectServiceDataInput
  upsert: ProjectUpsertWithoutProjectServiceInput
  delete: Boolean
  disconnect: Boolean
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutProjectServiceDataInput {
  company: CompanyUpdateOneRequiredInput
  customer: CustomerUpdateOneInput
  description: String
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  name: String
  startsAt: DateTime
  status: ProjectStatus
}

input ProjectUpsertNestedInput {
  update: ProjectUpdateDataInput!
  create: ProjectCreateInput!
}

input ProjectUpsertWithoutProjectServiceInput {
  update: ProjectUpdateWithoutProjectServiceDataInput!
  create: ProjectCreateWithoutProjectServiceInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  company: CompanyWhereInput
  customer: CustomerWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  projectService_every: ProjectServiceWhereInput
  projectService_some: ProjectServiceWhereInput
  projectService_none: ProjectServiceWhereInput
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  status: ProjectStatus
  status_not: ProjectStatus
  status_in: [ProjectStatus!]
  status_not_in: [ProjectStatus!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
}

type PurchaseOrder {
  id: ID!
  pbsOrganisation: String
  date: DateTime
  orderer: User
  status: PoStatus
  supplier: Supplier
  isPbsPO: Boolean
  poNumber: Int!
  preview: Attachment
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseOrderConnection {
  pageInfo: PageInfo!
  edges: [PurchaseOrderEdge]!
  aggregate: AggregatePurchaseOrder!
}

input PurchaseOrderCreateInput {
  id: ID
  pbsOrganisation: String
  date: DateTime
  orderer: UserCreateOneInput
  status: PoStatus
  supplier: SupplierCreateOneInput
  isPbsPO: Boolean
  poNumber: Int!
  preview: AttachmentCreateOneInput
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderCreateOneInput {
  create: PurchaseOrderCreateInput
  connect: PurchaseOrderWhereUniqueInput
}

type PurchaseOrderEdge {
  node: PurchaseOrder!
  cursor: String!
}

type PurchaseOrderLine {
  id: ID!
  item: Inventory
  pbsDrug: String
  qty: Int
  unit: UOM
  unitPrice: Float
  site: WareHouse
  purchaseOrder: PurchaseOrder
  poReceipt: PoReceipt
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseOrderLineConnection {
  pageInfo: PageInfo!
  edges: [PurchaseOrderLineEdge]!
  aggregate: AggregatePurchaseOrderLine!
}

input PurchaseOrderLineCreateInput {
  id: ID
  item: InventoryCreateOneInput
  pbsDrug: String
  qty: Int
  unit: UOM
  unitPrice: Float
  site: WareHouseCreateOneInput
  purchaseOrder: PurchaseOrderCreateOneInput
  poReceipt: PoReceiptCreateOneInput
  isArchived: Boolean
  isDeleted: Boolean
}

type PurchaseOrderLineEdge {
  node: PurchaseOrderLine!
  cursor: String!
}

enum PurchaseOrderLineOrderByInput {
  id_ASC
  id_DESC
  pbsDrug_ASC
  pbsDrug_DESC
  qty_ASC
  qty_DESC
  unit_ASC
  unit_DESC
  unitPrice_ASC
  unitPrice_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PurchaseOrderLinePreviousValues {
  id: ID!
  pbsDrug: String
  qty: Int
  unit: UOM
  unitPrice: Float
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseOrderLineSubscriptionPayload {
  mutation: MutationType!
  node: PurchaseOrderLine
  updatedFields: [String!]
  previousValues: PurchaseOrderLinePreviousValues
}

input PurchaseOrderLineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PurchaseOrderLineWhereInput
  AND: [PurchaseOrderLineSubscriptionWhereInput!]
  OR: [PurchaseOrderLineSubscriptionWhereInput!]
  NOT: [PurchaseOrderLineSubscriptionWhereInput!]
}

input PurchaseOrderLineUpdateInput {
  item: InventoryUpdateOneInput
  pbsDrug: String
  qty: Int
  unit: UOM
  unitPrice: Float
  site: WareHouseUpdateOneInput
  purchaseOrder: PurchaseOrderUpdateOneInput
  poReceipt: PoReceiptUpdateOneInput
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderLineUpdateManyMutationInput {
  pbsDrug: String
  qty: Int
  unit: UOM
  unitPrice: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderLineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  item: InventoryWhereInput
  pbsDrug: String
  pbsDrug_not: String
  pbsDrug_in: [String!]
  pbsDrug_not_in: [String!]
  pbsDrug_lt: String
  pbsDrug_lte: String
  pbsDrug_gt: String
  pbsDrug_gte: String
  pbsDrug_contains: String
  pbsDrug_not_contains: String
  pbsDrug_starts_with: String
  pbsDrug_not_starts_with: String
  pbsDrug_ends_with: String
  pbsDrug_not_ends_with: String
  qty: Int
  qty_not: Int
  qty_in: [Int!]
  qty_not_in: [Int!]
  qty_lt: Int
  qty_lte: Int
  qty_gt: Int
  qty_gte: Int
  unit: UOM
  unit_not: UOM
  unit_in: [UOM!]
  unit_not_in: [UOM!]
  unitPrice: Float
  unitPrice_not: Float
  unitPrice_in: [Float!]
  unitPrice_not_in: [Float!]
  unitPrice_lt: Float
  unitPrice_lte: Float
  unitPrice_gt: Float
  unitPrice_gte: Float
  site: WareHouseWhereInput
  purchaseOrder: PurchaseOrderWhereInput
  poReceipt: PoReceiptWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PurchaseOrderLineWhereInput!]
  OR: [PurchaseOrderLineWhereInput!]
  NOT: [PurchaseOrderLineWhereInput!]
}

input PurchaseOrderLineWhereUniqueInput {
  id: ID
}

enum PurchaseOrderOrderByInput {
  id_ASC
  id_DESC
  pbsOrganisation_ASC
  pbsOrganisation_DESC
  date_ASC
  date_DESC
  status_ASC
  status_DESC
  isPbsPO_ASC
  isPbsPO_DESC
  poNumber_ASC
  poNumber_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PurchaseOrderPreviousValues {
  id: ID!
  pbsOrganisation: String
  date: DateTime
  status: PoStatus
  isPbsPO: Boolean
  poNumber: Int!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PurchaseOrderSubscriptionPayload {
  mutation: MutationType!
  node: PurchaseOrder
  updatedFields: [String!]
  previousValues: PurchaseOrderPreviousValues
}

input PurchaseOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PurchaseOrderWhereInput
  AND: [PurchaseOrderSubscriptionWhereInput!]
  OR: [PurchaseOrderSubscriptionWhereInput!]
  NOT: [PurchaseOrderSubscriptionWhereInput!]
}

input PurchaseOrderUpdateDataInput {
  pbsOrganisation: String
  date: DateTime
  orderer: UserUpdateOneInput
  status: PoStatus
  supplier: SupplierUpdateOneInput
  isPbsPO: Boolean
  poNumber: Int
  preview: AttachmentUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderUpdateInput {
  pbsOrganisation: String
  date: DateTime
  orderer: UserUpdateOneInput
  status: PoStatus
  supplier: SupplierUpdateOneInput
  isPbsPO: Boolean
  poNumber: Int
  preview: AttachmentUpdateOneInput
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderUpdateManyMutationInput {
  pbsOrganisation: String
  date: DateTime
  status: PoStatus
  isPbsPO: Boolean
  poNumber: Int
  isArchived: Boolean
  isDeleted: Boolean
}

input PurchaseOrderUpdateOneInput {
  create: PurchaseOrderCreateInput
  update: PurchaseOrderUpdateDataInput
  upsert: PurchaseOrderUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PurchaseOrderWhereUniqueInput
}

input PurchaseOrderUpsertNestedInput {
  update: PurchaseOrderUpdateDataInput!
  create: PurchaseOrderCreateInput!
}

input PurchaseOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pbsOrganisation: String
  pbsOrganisation_not: String
  pbsOrganisation_in: [String!]
  pbsOrganisation_not_in: [String!]
  pbsOrganisation_lt: String
  pbsOrganisation_lte: String
  pbsOrganisation_gt: String
  pbsOrganisation_gte: String
  pbsOrganisation_contains: String
  pbsOrganisation_not_contains: String
  pbsOrganisation_starts_with: String
  pbsOrganisation_not_starts_with: String
  pbsOrganisation_ends_with: String
  pbsOrganisation_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  orderer: UserWhereInput
  status: PoStatus
  status_not: PoStatus
  status_in: [PoStatus!]
  status_not_in: [PoStatus!]
  supplier: SupplierWhereInput
  isPbsPO: Boolean
  isPbsPO_not: Boolean
  poNumber: Int
  poNumber_not: Int
  poNumber_in: [Int!]
  poNumber_not_in: [Int!]
  poNumber_lt: Int
  poNumber_lte: Int
  poNumber_gt: Int
  poNumber_gte: Int
  preview: AttachmentWhereInput
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PurchaseOrderWhereInput!]
  OR: [PurchaseOrderWhereInput!]
  NOT: [PurchaseOrderWhereInput!]
}

input PurchaseOrderWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  apInvoice(where: ApInvoiceWhereUniqueInput!): ApInvoice
  apInvoices(where: ApInvoiceWhereInput, orderBy: ApInvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ApInvoice]!
  apInvoicesConnection(where: ApInvoiceWhereInput, orderBy: ApInvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ApInvoiceConnection!
  asset(where: AssetWhereUniqueInput!): Asset
  assets(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Asset]!
  assetsConnection(where: AssetWhereInput, orderBy: AssetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetConnection!
  assetGroup(where: AssetGroupWhereUniqueInput!): AssetGroup
  assetGroups(where: AssetGroupWhereInput, orderBy: AssetGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AssetGroup]!
  assetGroupsConnection(where: AssetGroupWhereInput, orderBy: AssetGroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AssetGroupConnection!
  attachment(where: AttachmentWhereUniqueInput!): Attachment
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment]!
  attachmentsConnection(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttachmentConnection!
  bank(where: BankWhereUniqueInput!): Bank
  banks(where: BankWhereInput, orderBy: BankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bank]!
  banksConnection(where: BankWhereInput, orderBy: BankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BankConnection!
  bankTransaction(where: BankTransactionWhereUniqueInput!): BankTransaction
  bankTransactions(where: BankTransactionWhereInput, orderBy: BankTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BankTransaction]!
  bankTransactionsConnection(where: BankTransactionWhereInput, orderBy: BankTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BankTransactionConnection!
  basicDailyFee(where: BasicDailyFeeWhereUniqueInput!): BasicDailyFee
  basicDailyFees(where: BasicDailyFeeWhereInput, orderBy: BasicDailyFeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BasicDailyFee]!
  basicDailyFeesConnection(where: BasicDailyFeeWhereInput, orderBy: BasicDailyFeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BasicDailyFeeConnection!
  company(where: CompanyWhereUniqueInput!): Company
  companies(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Company]!
  companiesConnection(where: CompanyWhereInput, orderBy: CompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyConnection!
  companyMember(where: CompanyMemberWhereUniqueInput!): CompanyMember
  companyMembers(where: CompanyMemberWhereInput, orderBy: CompanyMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CompanyMember]!
  companyMembersConnection(where: CompanyMemberWhereInput, orderBy: CompanyMemberOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompanyMemberConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact]!
  contactsConnection(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  disease(where: DiseaseWhereUniqueInput!): Disease
  diseases(where: DiseaseWhereInput, orderBy: DiseaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Disease]!
  diseasesConnection(where: DiseaseWhereInput, orderBy: DiseaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiseaseConnection!
  hILog(where: HILogWhereUniqueInput!): HILog
  hILogs(where: HILogWhereInput, orderBy: HILogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HILog]!
  hILogsConnection(where: HILogWhereInput, orderBy: HILogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HILogConnection!
  healthcareProvider(where: HealthcareProviderWhereUniqueInput!): HealthcareProvider
  healthcareProviders(where: HealthcareProviderWhereInput, orderBy: HealthcareProviderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HealthcareProvider]!
  healthcareProvidersConnection(where: HealthcareProviderWhereInput, orderBy: HealthcareProviderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HealthcareProviderConnection!
  immunisationSchedule(where: ImmunisationScheduleWhereUniqueInput!): ImmunisationSchedule
  immunisationSchedules(where: ImmunisationScheduleWhereInput, orderBy: ImmunisationScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ImmunisationSchedule]!
  immunisationSchedulesConnection(where: ImmunisationScheduleWhereInput, orderBy: ImmunisationScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImmunisationScheduleConnection!
  integration(where: IntegrationWhereUniqueInput!): Integration
  integrations(where: IntegrationWhereInput, orderBy: IntegrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Integration]!
  integrationsConnection(where: IntegrationWhereInput, orderBy: IntegrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IntegrationConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  inventoryOnHand(where: InventoryOnHandWhereUniqueInput!): InventoryOnHand
  inventoryOnHands(where: InventoryOnHandWhereInput, orderBy: InventoryOnHandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InventoryOnHand]!
  inventoryOnHandsConnection(where: InventoryOnHandWhereInput, orderBy: InventoryOnHandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryOnHandConnection!
  invoice(where: InvoiceWhereUniqueInput!): Invoice
  invoices(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invoice]!
  invoicesConnection(where: InvoiceWhereInput, orderBy: InvoiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvoiceConnection!
  invoiceItemEntry(where: InvoiceItemEntryWhereUniqueInput!): InvoiceItemEntry
  invoiceItemEntries(where: InvoiceItemEntryWhereInput, orderBy: InvoiceItemEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [InvoiceItemEntry]!
  invoiceItemEntriesConnection(where: InvoiceItemEntryWhereInput, orderBy: InvoiceItemEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvoiceItemEntryConnection!
  ledgerJournal(where: LedgerJournalWhereUniqueInput!): LedgerJournal
  ledgerJournals(where: LedgerJournalWhereInput, orderBy: LedgerJournalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LedgerJournal]!
  ledgerJournalsConnection(where: LedgerJournalWhereInput, orderBy: LedgerJournalOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LedgerJournalConnection!
  ledgerPosting(where: LedgerPostingWhereUniqueInput!): LedgerPosting
  ledgerPostings(where: LedgerPostingWhereInput, orderBy: LedgerPostingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LedgerPosting]!
  ledgerPostingsConnection(where: LedgerPostingWhereInput, orderBy: LedgerPostingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LedgerPostingConnection!
  ledgerTransaction(where: LedgerTransactionWhereUniqueInput!): LedgerTransaction
  ledgerTransactions(where: LedgerTransactionWhereInput, orderBy: LedgerTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LedgerTransaction]!
  ledgerTransactionsConnection(where: LedgerTransactionWhereInput, orderBy: LedgerTransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LedgerTransactionConnection!
  mainAccount(where: MainAccountWhereUniqueInput!): MainAccount
  mainAccounts(where: MainAccountWhereInput, orderBy: MainAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MainAccount]!
  mainAccountsConnection(where: MainAccountWhereInput, orderBy: MainAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MainAccountConnection!
  meansTestLimits(where: MeansTestLimitsWhereUniqueInput!): MeansTestLimits
  meansTestLimitses(where: MeansTestLimitsWhereInput, orderBy: MeansTestLimitsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeansTestLimits]!
  meansTestLimitsesConnection(where: MeansTestLimitsWhereInput, orderBy: MeansTestLimitsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeansTestLimitsConnection!
  meansTestedFee(where: MeansTestedFeeWhereUniqueInput!): MeansTestedFee
  meansTestedFees(where: MeansTestedFeeWhereInput, orderBy: MeansTestedFeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MeansTestedFee]!
  meansTestedFeesConnection(where: MeansTestedFeeWhereInput, orderBy: MeansTestedFeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeansTestedFeeConnection!
  medicareService(where: MedicareServiceWhereUniqueInput!): MedicareService
  medicareServices(where: MedicareServiceWhereInput, orderBy: MedicareServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MedicareService]!
  medicareServicesConnection(where: MedicareServiceWhereInput, orderBy: MedicareServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MedicareServiceConnection!
  name(where: NameWhereUniqueInput!): Name
  names(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Name]!
  namesConnection(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NameConnection!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Patient]!
  patientsConnection(where: PatientWhereInput, orderBy: PatientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PatientConnection!
  pbsOrganisation(where: PbsOrganisationWhereUniqueInput!): PbsOrganisation
  pbsOrganisations(where: PbsOrganisationWhereInput, orderBy: PbsOrganisationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PbsOrganisation]!
  pbsOrganisationsConnection(where: PbsOrganisationWhereInput, orderBy: PbsOrganisationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PbsOrganisationConnection!
  pbsTPP(where: PbsTPPWhereUniqueInput!): PbsTPP
  pbsTPPs(where: PbsTPPWhereInput, orderBy: PbsTPPOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PbsTPP]!
  pbsTPPsConnection(where: PbsTPPWhereInput, orderBy: PbsTPPOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PbsTPPConnection!
  plan(where: PlanWhereUniqueInput!): Plan
  plans(where: PlanWhereInput, orderBy: PlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Plan]!
  plansConnection(where: PlanWhereInput, orderBy: PlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlanConnection!
  poReceipt(where: PoReceiptWhereUniqueInput!): PoReceipt
  poReceipts(where: PoReceiptWhereInput, orderBy: PoReceiptOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PoReceipt]!
  poReceiptsConnection(where: PoReceiptWhereInput, orderBy: PoReceiptOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PoReceiptConnection!
  predictedSalesQuantityOfItemsByCompany(where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput!): PredictedSalesQuantityOfItemsByCompany
  predictedSalesQuantityOfItemsByCompanies(where: PredictedSalesQuantityOfItemsByCompanyWhereInput, orderBy: PredictedSalesQuantityOfItemsByCompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PredictedSalesQuantityOfItemsByCompany]!
  predictedSalesQuantityOfItemsByCompaniesConnection(where: PredictedSalesQuantityOfItemsByCompanyWhereInput, orderBy: PredictedSalesQuantityOfItemsByCompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PredictedSalesQuantityOfItemsByCompanyConnection!
  predictedSalesValueByCompany(where: PredictedSalesValueByCompanyWhereUniqueInput!): PredictedSalesValueByCompany
  predictedSalesValueByCompanies(where: PredictedSalesValueByCompanyWhereInput, orderBy: PredictedSalesValueByCompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PredictedSalesValueByCompany]!
  predictedSalesValueByCompaniesConnection(where: PredictedSalesValueByCompanyWhereInput, orderBy: PredictedSalesValueByCompanyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PredictedSalesValueByCompanyConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  projectService(where: ProjectServiceWhereUniqueInput!): ProjectService
  projectServices(where: ProjectServiceWhereInput, orderBy: ProjectServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectService]!
  projectServicesConnection(where: ProjectServiceWhereInput, orderBy: ProjectServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectServiceConnection!
  projectServiceRule(where: ProjectServiceRuleWhereUniqueInput!): ProjectServiceRule
  projectServiceRules(where: ProjectServiceRuleWhereInput, orderBy: ProjectServiceRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProjectServiceRule]!
  projectServiceRulesConnection(where: ProjectServiceRuleWhereInput, orderBy: ProjectServiceRuleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectServiceRuleConnection!
  purchaseOrder(where: PurchaseOrderWhereUniqueInput!): PurchaseOrder
  purchaseOrders(where: PurchaseOrderWhereInput, orderBy: PurchaseOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PurchaseOrder]!
  purchaseOrdersConnection(where: PurchaseOrderWhereInput, orderBy: PurchaseOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PurchaseOrderConnection!
  purchaseOrderLine(where: PurchaseOrderLineWhereUniqueInput!): PurchaseOrderLine
  purchaseOrderLines(where: PurchaseOrderLineWhereInput, orderBy: PurchaseOrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PurchaseOrderLine]!
  purchaseOrderLinesConnection(where: PurchaseOrderLineWhereInput, orderBy: PurchaseOrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PurchaseOrderLineConnection!
  salesOrder(where: SalesOrderWhereUniqueInput!): SalesOrder
  salesOrders(where: SalesOrderWhereInput, orderBy: SalesOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SalesOrder]!
  salesOrdersConnection(where: SalesOrderWhereInput, orderBy: SalesOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SalesOrderConnection!
  salesOrderLine(where: SalesOrderLineWhereUniqueInput!): SalesOrderLine
  salesOrderLines(where: SalesOrderLineWhereInput, orderBy: SalesOrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SalesOrderLine]!
  salesOrderLinesConnection(where: SalesOrderLineWhereInput, orderBy: SalesOrderLineOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SalesOrderLineConnection!
  service(where: ServiceWhereUniqueInput!): Service
  services(where: ServiceWhereInput, orderBy: ServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Service]!
  servicesConnection(where: ServiceWhereInput, orderBy: ServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ServiceConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  supplier(where: SupplierWhereUniqueInput!): Supplier
  suppliers(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Supplier]!
  suppliersConnection(where: SupplierWhereInput, orderBy: SupplierOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupplierConnection!
  timeSheet(where: TimeSheetWhereUniqueInput!): TimeSheet
  timeSheets(where: TimeSheetWhereInput, orderBy: TimeSheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TimeSheet]!
  timeSheetsConnection(where: TimeSheetWhereInput, orderBy: TimeSheetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimeSheetConnection!
  timeSheetEntry(where: TimeSheetEntryWhereUniqueInput!): TimeSheetEntry
  timeSheetEntries(where: TimeSheetEntryWhereInput, orderBy: TimeSheetEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TimeSheetEntry]!
  timeSheetEntriesConnection(where: TimeSheetEntryWhereInput, orderBy: TimeSheetEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimeSheetEntryConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vaccineBrand(where: VaccineBrandWhereUniqueInput!): VaccineBrand
  vaccineBrands(where: VaccineBrandWhereInput, orderBy: VaccineBrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [VaccineBrand]!
  vaccineBrandsConnection(where: VaccineBrandWhereInput, orderBy: VaccineBrandOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VaccineBrandConnection!
  wareHouse(where: WareHouseWhereUniqueInput!): WareHouse
  wareHouses(where: WareHouseWhereInput, orderBy: WareHouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WareHouse]!
  wareHousesConnection(where: WareHouseWhereInput, orderBy: WareHouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WareHouseConnection!
  node(id: ID!): Node
}

type SalesOrder {
  id: ID!
  customer: Customer
  transactionDate: DateTime
  currency: Currency
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SalesOrderConnection {
  pageInfo: PageInfo!
  edges: [SalesOrderEdge]!
  aggregate: AggregateSalesOrder!
}

input SalesOrderCreateInput {
  id: ID
  customer: CustomerCreateOneInput
  transactionDate: DateTime
  currency: Currency
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderCreateOneInput {
  create: SalesOrderCreateInput
  connect: SalesOrderWhereUniqueInput
}

type SalesOrderEdge {
  node: SalesOrder!
  cursor: String!
}

type SalesOrderLine {
  id: ID!
  salesOrder: SalesOrder
  inventory: Inventory
  qty: Int
  price: Float
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SalesOrderLineConnection {
  pageInfo: PageInfo!
  edges: [SalesOrderLineEdge]!
  aggregate: AggregateSalesOrderLine!
}

input SalesOrderLineCreateInput {
  id: ID
  salesOrder: SalesOrderCreateOneInput
  inventory: InventoryCreateOneInput
  qty: Int
  price: Float
  isArchived: Boolean
  isDeleted: Boolean
}

type SalesOrderLineEdge {
  node: SalesOrderLine!
  cursor: String!
}

enum SalesOrderLineOrderByInput {
  id_ASC
  id_DESC
  qty_ASC
  qty_DESC
  price_ASC
  price_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SalesOrderLinePreviousValues {
  id: ID!
  qty: Int
  price: Float
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SalesOrderLineSubscriptionPayload {
  mutation: MutationType!
  node: SalesOrderLine
  updatedFields: [String!]
  previousValues: SalesOrderLinePreviousValues
}

input SalesOrderLineSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SalesOrderLineWhereInput
  AND: [SalesOrderLineSubscriptionWhereInput!]
  OR: [SalesOrderLineSubscriptionWhereInput!]
  NOT: [SalesOrderLineSubscriptionWhereInput!]
}

input SalesOrderLineUpdateInput {
  salesOrder: SalesOrderUpdateOneInput
  inventory: InventoryUpdateOneInput
  qty: Int
  price: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderLineUpdateManyMutationInput {
  qty: Int
  price: Float
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderLineWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  salesOrder: SalesOrderWhereInput
  inventory: InventoryWhereInput
  qty: Int
  qty_not: Int
  qty_in: [Int!]
  qty_not_in: [Int!]
  qty_lt: Int
  qty_lte: Int
  qty_gt: Int
  qty_gte: Int
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SalesOrderLineWhereInput!]
  OR: [SalesOrderLineWhereInput!]
  NOT: [SalesOrderLineWhereInput!]
}

input SalesOrderLineWhereUniqueInput {
  id: ID
}

enum SalesOrderOrderByInput {
  id_ASC
  id_DESC
  transactionDate_ASC
  transactionDate_DESC
  currency_ASC
  currency_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SalesOrderPreviousValues {
  id: ID!
  transactionDate: DateTime
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SalesOrderSubscriptionPayload {
  mutation: MutationType!
  node: SalesOrder
  updatedFields: [String!]
  previousValues: SalesOrderPreviousValues
}

input SalesOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SalesOrderWhereInput
  AND: [SalesOrderSubscriptionWhereInput!]
  OR: [SalesOrderSubscriptionWhereInput!]
  NOT: [SalesOrderSubscriptionWhereInput!]
}

input SalesOrderUpdateDataInput {
  customer: CustomerUpdateOneInput
  transactionDate: DateTime
  currency: Currency
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderUpdateInput {
  customer: CustomerUpdateOneInput
  transactionDate: DateTime
  currency: Currency
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderUpdateManyMutationInput {
  transactionDate: DateTime
  currency: Currency
  isArchived: Boolean
  isDeleted: Boolean
}

input SalesOrderUpdateOneInput {
  create: SalesOrderCreateInput
  update: SalesOrderUpdateDataInput
  upsert: SalesOrderUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SalesOrderWhereUniqueInput
}

input SalesOrderUpsertNestedInput {
  update: SalesOrderUpdateDataInput!
  create: SalesOrderCreateInput!
}

input SalesOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  transactionDate: DateTime
  transactionDate_not: DateTime
  transactionDate_in: [DateTime!]
  transactionDate_not_in: [DateTime!]
  transactionDate_lt: DateTime
  transactionDate_lte: DateTime
  transactionDate_gt: DateTime
  transactionDate_gte: DateTime
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SalesOrderWhereInput!]
  OR: [SalesOrderWhereInput!]
  NOT: [SalesOrderWhereInput!]
}

input SalesOrderWhereUniqueInput {
  id: ID
}

enum SalusResponse {
  SUCCESS
  FAIL
}

type Service {
  id: ID!
  billingType: ServiceBillingType!
  company: Company!
  includeConsTax: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String!
  timeBasedType: TimeBasedType
  totalAmount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ServiceBillingType {
  FIXED
  TIME_BASED
}

type ServiceConnection {
  pageInfo: PageInfo!
  edges: [ServiceEdge]!
  aggregate: AggregateService!
}

input ServiceCreateInput {
  id: ID
  billingType: ServiceBillingType!
  company: CompanyCreateOneInput!
  includeConsTax: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String!
  timeBasedType: TimeBasedType
  totalAmount: Float!
}

input ServiceCreateOneInput {
  create: ServiceCreateInput
  connect: ServiceWhereUniqueInput
}

type ServiceEdge {
  node: Service!
  cursor: String!
}

enum ServiceOrderByInput {
  id_ASC
  id_DESC
  billingType_ASC
  billingType_DESC
  includeConsTax_ASC
  includeConsTax_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  isTemplate_ASC
  isTemplate_DESC
  name_ASC
  name_DESC
  timeBasedType_ASC
  timeBasedType_DESC
  totalAmount_ASC
  totalAmount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ServicePreviousValues {
  id: ID!
  billingType: ServiceBillingType!
  includeConsTax: Boolean!
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String!
  timeBasedType: TimeBasedType
  totalAmount: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ServiceSubscriptionPayload {
  mutation: MutationType!
  node: Service
  updatedFields: [String!]
  previousValues: ServicePreviousValues
}

input ServiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ServiceWhereInput
  AND: [ServiceSubscriptionWhereInput!]
  OR: [ServiceSubscriptionWhereInput!]
  NOT: [ServiceSubscriptionWhereInput!]
}

input ServiceUpdateDataInput {
  billingType: ServiceBillingType
  company: CompanyUpdateOneRequiredInput
  includeConsTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String
  timeBasedType: TimeBasedType
  totalAmount: Float
}

input ServiceUpdateInput {
  billingType: ServiceBillingType
  company: CompanyUpdateOneRequiredInput
  includeConsTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String
  timeBasedType: TimeBasedType
  totalAmount: Float
}

input ServiceUpdateManyMutationInput {
  billingType: ServiceBillingType
  includeConsTax: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isTemplate: Boolean
  name: String
  timeBasedType: TimeBasedType
  totalAmount: Float
}

input ServiceUpdateOneInput {
  create: ServiceCreateInput
  update: ServiceUpdateDataInput
  upsert: ServiceUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ServiceWhereUniqueInput
}

input ServiceUpsertNestedInput {
  update: ServiceUpdateDataInput!
  create: ServiceCreateInput!
}

input ServiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  billingType: ServiceBillingType
  billingType_not: ServiceBillingType
  billingType_in: [ServiceBillingType!]
  billingType_not_in: [ServiceBillingType!]
  company: CompanyWhereInput
  includeConsTax: Boolean
  includeConsTax_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  isTemplate: Boolean
  isTemplate_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  timeBasedType: TimeBasedType
  timeBasedType_not: TimeBasedType
  timeBasedType_in: [TimeBasedType!]
  timeBasedType_not_in: [TimeBasedType!]
  totalAmount: Float
  totalAmount_not: Float
  totalAmount_in: [Float!]
  totalAmount_not_in: [Float!]
  totalAmount_lt: Float
  totalAmount_lte: Float
  totalAmount_gt: Float
  totalAmount_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
}

input ServiceWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  expires_at: DateTime
  is_active: Boolean
  is_archived: Boolean
  is_deleted: Boolean
  signed_at: DateTime
  user: User
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  expires_at: DateTime
  is_active: Boolean
  is_archived: Boolean
  is_deleted: Boolean
  signed_at: DateTime
  user: UserCreateOneInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  expires_at_ASC
  expires_at_DESC
  is_active_ASC
  is_active_DESC
  is_archived_ASC
  is_archived_DESC
  is_deleted_ASC
  is_deleted_DESC
  signed_at_ASC
  signed_at_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SessionPreviousValues {
  id: ID!
  expires_at: DateTime
  is_active: Boolean
  is_archived: Boolean
  is_deleted: Boolean
  signed_at: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  expires_at: DateTime
  is_active: Boolean
  is_archived: Boolean
  is_deleted: Boolean
  signed_at: DateTime
  user: UserUpdateOneInput
}

input SessionUpdateManyMutationInput {
  expires_at: DateTime
  is_active: Boolean
  is_archived: Boolean
  is_deleted: Boolean
  signed_at: DateTime
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  expires_at: DateTime
  expires_at_not: DateTime
  expires_at_in: [DateTime!]
  expires_at_not_in: [DateTime!]
  expires_at_lt: DateTime
  expires_at_lte: DateTime
  expires_at_gt: DateTime
  expires_at_gte: DateTime
  is_active: Boolean
  is_active_not: Boolean
  is_archived: Boolean
  is_archived_not: Boolean
  is_deleted: Boolean
  is_deleted_not: Boolean
  signed_at: DateTime
  signed_at_not: DateTime
  signed_at_in: [DateTime!]
  signed_at_not_in: [DateTime!]
  signed_at_lt: DateTime
  signed_at_lte: DateTime
  signed_at_gt: DateTime
  signed_at_gte: DateTime
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  apInvoice(where: ApInvoiceSubscriptionWhereInput): ApInvoiceSubscriptionPayload
  asset(where: AssetSubscriptionWhereInput): AssetSubscriptionPayload
  assetGroup(where: AssetGroupSubscriptionWhereInput): AssetGroupSubscriptionPayload
  attachment(where: AttachmentSubscriptionWhereInput): AttachmentSubscriptionPayload
  bank(where: BankSubscriptionWhereInput): BankSubscriptionPayload
  bankTransaction(where: BankTransactionSubscriptionWhereInput): BankTransactionSubscriptionPayload
  basicDailyFee(where: BasicDailyFeeSubscriptionWhereInput): BasicDailyFeeSubscriptionPayload
  company(where: CompanySubscriptionWhereInput): CompanySubscriptionPayload
  companyMember(where: CompanyMemberSubscriptionWhereInput): CompanyMemberSubscriptionPayload
  contact(where: ContactSubscriptionWhereInput): ContactSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  disease(where: DiseaseSubscriptionWhereInput): DiseaseSubscriptionPayload
  hILog(where: HILogSubscriptionWhereInput): HILogSubscriptionPayload
  healthcareProvider(where: HealthcareProviderSubscriptionWhereInput): HealthcareProviderSubscriptionPayload
  immunisationSchedule(where: ImmunisationScheduleSubscriptionWhereInput): ImmunisationScheduleSubscriptionPayload
  integration(where: IntegrationSubscriptionWhereInput): IntegrationSubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  inventoryOnHand(where: InventoryOnHandSubscriptionWhereInput): InventoryOnHandSubscriptionPayload
  invoice(where: InvoiceSubscriptionWhereInput): InvoiceSubscriptionPayload
  invoiceItemEntry(where: InvoiceItemEntrySubscriptionWhereInput): InvoiceItemEntrySubscriptionPayload
  ledgerJournal(where: LedgerJournalSubscriptionWhereInput): LedgerJournalSubscriptionPayload
  ledgerPosting(where: LedgerPostingSubscriptionWhereInput): LedgerPostingSubscriptionPayload
  ledgerTransaction(where: LedgerTransactionSubscriptionWhereInput): LedgerTransactionSubscriptionPayload
  mainAccount(where: MainAccountSubscriptionWhereInput): MainAccountSubscriptionPayload
  meansTestLimits(where: MeansTestLimitsSubscriptionWhereInput): MeansTestLimitsSubscriptionPayload
  meansTestedFee(where: MeansTestedFeeSubscriptionWhereInput): MeansTestedFeeSubscriptionPayload
  medicareService(where: MedicareServiceSubscriptionWhereInput): MedicareServiceSubscriptionPayload
  name(where: NameSubscriptionWhereInput): NameSubscriptionPayload
  patient(where: PatientSubscriptionWhereInput): PatientSubscriptionPayload
  pbsOrganisation(where: PbsOrganisationSubscriptionWhereInput): PbsOrganisationSubscriptionPayload
  pbsTPP(where: PbsTPPSubscriptionWhereInput): PbsTPPSubscriptionPayload
  plan(where: PlanSubscriptionWhereInput): PlanSubscriptionPayload
  poReceipt(where: PoReceiptSubscriptionWhereInput): PoReceiptSubscriptionPayload
  predictedSalesQuantityOfItemsByCompany(where: PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput): PredictedSalesQuantityOfItemsByCompanySubscriptionPayload
  predictedSalesValueByCompany(where: PredictedSalesValueByCompanySubscriptionWhereInput): PredictedSalesValueByCompanySubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  projectService(where: ProjectServiceSubscriptionWhereInput): ProjectServiceSubscriptionPayload
  projectServiceRule(where: ProjectServiceRuleSubscriptionWhereInput): ProjectServiceRuleSubscriptionPayload
  purchaseOrder(where: PurchaseOrderSubscriptionWhereInput): PurchaseOrderSubscriptionPayload
  purchaseOrderLine(where: PurchaseOrderLineSubscriptionWhereInput): PurchaseOrderLineSubscriptionPayload
  salesOrder(where: SalesOrderSubscriptionWhereInput): SalesOrderSubscriptionPayload
  salesOrderLine(where: SalesOrderLineSubscriptionWhereInput): SalesOrderLineSubscriptionPayload
  service(where: ServiceSubscriptionWhereInput): ServiceSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  supplier(where: SupplierSubscriptionWhereInput): SupplierSubscriptionPayload
  timeSheet(where: TimeSheetSubscriptionWhereInput): TimeSheetSubscriptionPayload
  timeSheetEntry(where: TimeSheetEntrySubscriptionWhereInput): TimeSheetEntrySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vaccineBrand(where: VaccineBrandSubscriptionWhereInput): VaccineBrandSubscriptionPayload
  wareHouse(where: WareHouseSubscriptionWhereInput): WareHouseSubscriptionPayload
}

type Supplier {
  id: ID!
  name: String
  address(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address!]
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SupplierConnection {
  pageInfo: PageInfo!
  edges: [SupplierEdge]!
  aggregate: AggregateSupplier!
}

input SupplierCreateInput {
  id: ID
  name: String
  address: AddressCreateManyInput
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input SupplierCreateOneInput {
  create: SupplierCreateInput
  connect: SupplierWhereUniqueInput
}

type SupplierEdge {
  node: Supplier!
  cursor: String!
}

enum SupplierOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  termsOfPayment_ASC
  termsOfPayment_DESC
  bankAccount_ASC
  bankAccount_DESC
  emailAddressForRemittance_ASC
  emailAddressForRemittance_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SupplierPreviousValues {
  id: ID!
  name: String
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SupplierSubscriptionPayload {
  mutation: MutationType!
  node: Supplier
  updatedFields: [String!]
  previousValues: SupplierPreviousValues
}

input SupplierSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupplierWhereInput
  AND: [SupplierSubscriptionWhereInput!]
  OR: [SupplierSubscriptionWhereInput!]
  NOT: [SupplierSubscriptionWhereInput!]
}

enum SupplierTermsOfPayment {
  COD
  DAYS_14
  DAYS_30
  DAYS_60
}

input SupplierUpdateDataInput {
  name: String
  address: AddressUpdateManyInput
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input SupplierUpdateInput {
  name: String
  address: AddressUpdateManyInput
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input SupplierUpdateManyMutationInput {
  name: String
  termsOfPayment: SupplierTermsOfPayment
  bankAccount: Json
  emailAddressForRemittance: String
  isArchived: Boolean
  isDeleted: Boolean
}

input SupplierUpdateOneInput {
  create: SupplierCreateInput
  update: SupplierUpdateDataInput
  upsert: SupplierUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SupplierWhereUniqueInput
}

input SupplierUpsertNestedInput {
  update: SupplierUpdateDataInput!
  create: SupplierCreateInput!
}

input SupplierWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address_every: AddressWhereInput
  address_some: AddressWhereInput
  address_none: AddressWhereInput
  termsOfPayment: SupplierTermsOfPayment
  termsOfPayment_not: SupplierTermsOfPayment
  termsOfPayment_in: [SupplierTermsOfPayment!]
  termsOfPayment_not_in: [SupplierTermsOfPayment!]
  emailAddressForRemittance: String
  emailAddressForRemittance_not: String
  emailAddressForRemittance_in: [String!]
  emailAddressForRemittance_not_in: [String!]
  emailAddressForRemittance_lt: String
  emailAddressForRemittance_lte: String
  emailAddressForRemittance_gt: String
  emailAddressForRemittance_gte: String
  emailAddressForRemittance_contains: String
  emailAddressForRemittance_not_contains: String
  emailAddressForRemittance_starts_with: String
  emailAddressForRemittance_not_starts_with: String
  emailAddressForRemittance_ends_with: String
  emailAddressForRemittance_not_ends_with: String
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SupplierWhereInput!]
  OR: [SupplierWhereInput!]
  NOT: [SupplierWhereInput!]
}

input SupplierWhereUniqueInput {
  id: ID
}

enum TimeBasedType {
  QUARTERHOUR
  HALFHOUR
  HOUR
}

type TimeSheet {
  id: ID!
  attachments(where: AttachmentWhereInput, orderBy: AttachmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attachment!]
  company: Company!
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: Attachment
  startsAt: DateTime
  status: TimeSheetStatus
  timeSheetEntries(where: TimeSheetEntryWhereInput, orderBy: TimeSheetEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TimeSheetEntry!]
  user: User
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TimeSheetConnection {
  pageInfo: PageInfo!
  edges: [TimeSheetEdge]!
  aggregate: AggregateTimeSheet!
}

input TimeSheetCreateInput {
  id: ID
  attachments: AttachmentCreateManyInput
  company: CompanyCreateOneInput!
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: AttachmentCreateOneInput
  startsAt: DateTime
  status: TimeSheetStatus
  timeSheetEntries: TimeSheetEntryCreateManyWithoutTimeSheetInput
  user: UserCreateOneInput
}

input TimeSheetCreateOneInput {
  create: TimeSheetCreateInput
  connect: TimeSheetWhereUniqueInput
}

input TimeSheetCreateOneWithoutTimeSheetEntriesInput {
  create: TimeSheetCreateWithoutTimeSheetEntriesInput
  connect: TimeSheetWhereUniqueInput
}

input TimeSheetCreateWithoutTimeSheetEntriesInput {
  id: ID
  attachments: AttachmentCreateManyInput
  company: CompanyCreateOneInput!
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: AttachmentCreateOneInput
  startsAt: DateTime
  status: TimeSheetStatus
  user: UserCreateOneInput
}

type TimeSheetEdge {
  node: TimeSheet!
  cursor: String!
}

type TimeSheetEntry {
  id: ID!
  customer: Customer
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: Project
  service: Service
  timeSheet: TimeSheet
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TimeSheetEntryConnection {
  pageInfo: PageInfo!
  edges: [TimeSheetEntryEdge]!
  aggregate: AggregateTimeSheetEntry!
}

input TimeSheetEntryCreateInput {
  id: ID
  customer: CustomerCreateOneInput
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: ProjectCreateOneInput
  service: ServiceCreateOneInput
  timeSheet: TimeSheetCreateOneWithoutTimeSheetEntriesInput
}

input TimeSheetEntryCreateManyWithoutTimeSheetInput {
  create: [TimeSheetEntryCreateWithoutTimeSheetInput!]
  connect: [TimeSheetEntryWhereUniqueInput!]
}

input TimeSheetEntryCreateOneInput {
  create: TimeSheetEntryCreateInput
  connect: TimeSheetEntryWhereUniqueInput
}

input TimeSheetEntryCreateWithoutTimeSheetInput {
  id: ID
  customer: CustomerCreateOneInput
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: ProjectCreateOneInput
  service: ServiceCreateOneInput
}

type TimeSheetEntryEdge {
  node: TimeSheetEntry!
  cursor: String!
}

enum TimeSheetEntryOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  duration_ASC
  duration_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  isInvoiced_ASC
  isInvoiced_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TimeSheetEntryPreviousValues {
  id: ID!
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TimeSheetEntryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  duration: Float
  duration_not: Float
  duration_in: [Float!]
  duration_not_in: [Float!]
  duration_lt: Float
  duration_lte: Float
  duration_gt: Float
  duration_gte: Float
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  isInvoiced: Boolean
  isInvoiced_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TimeSheetEntryScalarWhereInput!]
  OR: [TimeSheetEntryScalarWhereInput!]
  NOT: [TimeSheetEntryScalarWhereInput!]
}

type TimeSheetEntrySubscriptionPayload {
  mutation: MutationType!
  node: TimeSheetEntry
  updatedFields: [String!]
  previousValues: TimeSheetEntryPreviousValues
}

input TimeSheetEntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TimeSheetEntryWhereInput
  AND: [TimeSheetEntrySubscriptionWhereInput!]
  OR: [TimeSheetEntrySubscriptionWhereInput!]
  NOT: [TimeSheetEntrySubscriptionWhereInput!]
}

input TimeSheetEntryUpdateDataInput {
  customer: CustomerUpdateOneInput
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: ProjectUpdateOneInput
  service: ServiceUpdateOneInput
  timeSheet: TimeSheetUpdateOneWithoutTimeSheetEntriesInput
}

input TimeSheetEntryUpdateInput {
  customer: CustomerUpdateOneInput
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: ProjectUpdateOneInput
  service: ServiceUpdateOneInput
  timeSheet: TimeSheetUpdateOneWithoutTimeSheetEntriesInput
}

input TimeSheetEntryUpdateManyDataInput {
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
}

input TimeSheetEntryUpdateManyMutationInput {
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
}

input TimeSheetEntryUpdateManyWithoutTimeSheetInput {
  create: [TimeSheetEntryCreateWithoutTimeSheetInput!]
  delete: [TimeSheetEntryWhereUniqueInput!]
  connect: [TimeSheetEntryWhereUniqueInput!]
  set: [TimeSheetEntryWhereUniqueInput!]
  disconnect: [TimeSheetEntryWhereUniqueInput!]
  update: [TimeSheetEntryUpdateWithWhereUniqueWithoutTimeSheetInput!]
  upsert: [TimeSheetEntryUpsertWithWhereUniqueWithoutTimeSheetInput!]
  deleteMany: [TimeSheetEntryScalarWhereInput!]
  updateMany: [TimeSheetEntryUpdateManyWithWhereNestedInput!]
}

input TimeSheetEntryUpdateManyWithWhereNestedInput {
  where: TimeSheetEntryScalarWhereInput!
  data: TimeSheetEntryUpdateManyDataInput!
}

input TimeSheetEntryUpdateOneInput {
  create: TimeSheetEntryCreateInput
  update: TimeSheetEntryUpdateDataInput
  upsert: TimeSheetEntryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TimeSheetEntryWhereUniqueInput
}

input TimeSheetEntryUpdateWithoutTimeSheetDataInput {
  customer: CustomerUpdateOneInput
  date: DateTime
  duration: Float
  isArchived: Boolean
  isDeleted: Boolean
  isInvoiced: Boolean
  project: ProjectUpdateOneInput
  service: ServiceUpdateOneInput
}

input TimeSheetEntryUpdateWithWhereUniqueWithoutTimeSheetInput {
  where: TimeSheetEntryWhereUniqueInput!
  data: TimeSheetEntryUpdateWithoutTimeSheetDataInput!
}

input TimeSheetEntryUpsertNestedInput {
  update: TimeSheetEntryUpdateDataInput!
  create: TimeSheetEntryCreateInput!
}

input TimeSheetEntryUpsertWithWhereUniqueWithoutTimeSheetInput {
  where: TimeSheetEntryWhereUniqueInput!
  update: TimeSheetEntryUpdateWithoutTimeSheetDataInput!
  create: TimeSheetEntryCreateWithoutTimeSheetInput!
}

input TimeSheetEntryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  duration: Float
  duration_not: Float
  duration_in: [Float!]
  duration_not_in: [Float!]
  duration_lt: Float
  duration_lte: Float
  duration_gt: Float
  duration_gte: Float
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  isInvoiced: Boolean
  isInvoiced_not: Boolean
  project: ProjectWhereInput
  service: ServiceWhereInput
  timeSheet: TimeSheetWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TimeSheetEntryWhereInput!]
  OR: [TimeSheetEntryWhereInput!]
  NOT: [TimeSheetEntryWhereInput!]
}

input TimeSheetEntryWhereUniqueInput {
  id: ID
}

enum TimeSheetOrderByInput {
  id_ASC
  id_DESC
  endsAt_ASC
  endsAt_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  number_ASC
  number_DESC
  startsAt_ASC
  startsAt_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TimeSheetPreviousValues {
  id: ID!
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  startsAt: DateTime
  status: TimeSheetStatus
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum TimeSheetStatus {
  APPROVED
  DRAFT
  FINALISED
}

type TimeSheetSubscriptionPayload {
  mutation: MutationType!
  node: TimeSheet
  updatedFields: [String!]
  previousValues: TimeSheetPreviousValues
}

input TimeSheetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TimeSheetWhereInput
  AND: [TimeSheetSubscriptionWhereInput!]
  OR: [TimeSheetSubscriptionWhereInput!]
  NOT: [TimeSheetSubscriptionWhereInput!]
}

input TimeSheetUpdateDataInput {
  attachments: AttachmentUpdateManyInput
  company: CompanyUpdateOneRequiredInput
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: AttachmentUpdateOneInput
  startsAt: DateTime
  status: TimeSheetStatus
  timeSheetEntries: TimeSheetEntryUpdateManyWithoutTimeSheetInput
  user: UserUpdateOneInput
}

input TimeSheetUpdateInput {
  attachments: AttachmentUpdateManyInput
  company: CompanyUpdateOneRequiredInput
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: AttachmentUpdateOneInput
  startsAt: DateTime
  status: TimeSheetStatus
  timeSheetEntries: TimeSheetEntryUpdateManyWithoutTimeSheetInput
  user: UserUpdateOneInput
}

input TimeSheetUpdateManyMutationInput {
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  startsAt: DateTime
  status: TimeSheetStatus
}

input TimeSheetUpdateOneInput {
  create: TimeSheetCreateInput
  update: TimeSheetUpdateDataInput
  upsert: TimeSheetUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TimeSheetWhereUniqueInput
}

input TimeSheetUpdateOneWithoutTimeSheetEntriesInput {
  create: TimeSheetCreateWithoutTimeSheetEntriesInput
  update: TimeSheetUpdateWithoutTimeSheetEntriesDataInput
  upsert: TimeSheetUpsertWithoutTimeSheetEntriesInput
  delete: Boolean
  disconnect: Boolean
  connect: TimeSheetWhereUniqueInput
}

input TimeSheetUpdateWithoutTimeSheetEntriesDataInput {
  attachments: AttachmentUpdateManyInput
  company: CompanyUpdateOneRequiredInput
  endsAt: DateTime
  isArchived: Boolean
  isDeleted: Boolean
  number: Int
  preview: AttachmentUpdateOneInput
  startsAt: DateTime
  status: TimeSheetStatus
  user: UserUpdateOneInput
}

input TimeSheetUpsertNestedInput {
  update: TimeSheetUpdateDataInput!
  create: TimeSheetCreateInput!
}

input TimeSheetUpsertWithoutTimeSheetEntriesInput {
  update: TimeSheetUpdateWithoutTimeSheetEntriesDataInput!
  create: TimeSheetCreateWithoutTimeSheetEntriesInput!
}

input TimeSheetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  attachments_every: AttachmentWhereInput
  attachments_some: AttachmentWhereInput
  attachments_none: AttachmentWhereInput
  company: CompanyWhereInput
  endsAt: DateTime
  endsAt_not: DateTime
  endsAt_in: [DateTime!]
  endsAt_not_in: [DateTime!]
  endsAt_lt: DateTime
  endsAt_lte: DateTime
  endsAt_gt: DateTime
  endsAt_gte: DateTime
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  preview: AttachmentWhereInput
  startsAt: DateTime
  startsAt_not: DateTime
  startsAt_in: [DateTime!]
  startsAt_not_in: [DateTime!]
  startsAt_lt: DateTime
  startsAt_lte: DateTime
  startsAt_gt: DateTime
  startsAt_gte: DateTime
  status: TimeSheetStatus
  status_not: TimeSheetStatus
  status_in: [TimeSheetStatus!]
  status_not_in: [TimeSheetStatus!]
  timeSheetEntries_every: TimeSheetEntryWhereInput
  timeSheetEntries_some: TimeSheetEntryWhereInput
  timeSheetEntries_none: TimeSheetEntryWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TimeSheetWhereInput!]
  OR: [TimeSheetWhereInput!]
  NOT: [TimeSheetWhereInput!]
}

input TimeSheetWhereUniqueInput {
  id: ID
}

enum UOM {
  EA
}

type User {
  id: ID!
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  contactNumber_ASC
  contactNumber_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  isActive_ASC
  isActive_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  isRoot_ASC
  isRoot_DESC
  jobTitle_ASC
  jobTitle_DESC
  lastName_ASC
  lastName_DESC
  password_ASC
  password_DESC
  secondAuthEnabled_ASC
  secondAuthEnabled_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
}

input UserUpdateInput {
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
}

input UserUpdateManyMutationInput {
  contactNumber: Json
  email: String
  firstName: String
  isActive: Boolean
  isArchived: Boolean
  isDeleted: Boolean
  isRoot: Boolean
  jobTitle: String
  lastName: String
  password: String
  secondAuthEnabled: Boolean
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  isRoot: Boolean
  isRoot_not: Boolean
  jobTitle: String
  jobTitle_not: String
  jobTitle_in: [String!]
  jobTitle_not_in: [String!]
  jobTitle_lt: String
  jobTitle_lte: String
  jobTitle_gt: String
  jobTitle_gte: String
  jobTitle_contains: String
  jobTitle_not_contains: String
  jobTitle_starts_with: String
  jobTitle_not_starts_with: String
  jobTitle_ends_with: String
  jobTitle_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  secondAuthEnabled: Boolean
  secondAuthEnabled_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type VaccineBrand {
  id: ID!
  name: String
}

type VaccineBrandConnection {
  pageInfo: PageInfo!
  edges: [VaccineBrandEdge]!
  aggregate: AggregateVaccineBrand!
}

input VaccineBrandCreateInput {
  id: ID
  name: String
}

input VaccineBrandCreateOneInput {
  create: VaccineBrandCreateInput
  connect: VaccineBrandWhereUniqueInput
}

type VaccineBrandEdge {
  node: VaccineBrand!
  cursor: String!
}

enum VaccineBrandOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type VaccineBrandPreviousValues {
  id: ID!
  name: String
}

type VaccineBrandSubscriptionPayload {
  mutation: MutationType!
  node: VaccineBrand
  updatedFields: [String!]
  previousValues: VaccineBrandPreviousValues
}

input VaccineBrandSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VaccineBrandWhereInput
  AND: [VaccineBrandSubscriptionWhereInput!]
  OR: [VaccineBrandSubscriptionWhereInput!]
  NOT: [VaccineBrandSubscriptionWhereInput!]
}

input VaccineBrandUpdateDataInput {
  name: String
}

input VaccineBrandUpdateInput {
  name: String
}

input VaccineBrandUpdateManyMutationInput {
  name: String
}

input VaccineBrandUpdateOneInput {
  create: VaccineBrandCreateInput
  update: VaccineBrandUpdateDataInput
  upsert: VaccineBrandUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VaccineBrandWhereUniqueInput
}

input VaccineBrandUpsertNestedInput {
  update: VaccineBrandUpdateDataInput!
  create: VaccineBrandCreateInput!
}

input VaccineBrandWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [VaccineBrandWhereInput!]
  OR: [VaccineBrandWhereInput!]
  NOT: [VaccineBrandWhereInput!]
}

input VaccineBrandWhereUniqueInput {
  id: ID
}

type WareHouse {
  id: ID!
  name: String
  company: Company!
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WareHouseConnection {
  pageInfo: PageInfo!
  edges: [WareHouseEdge]!
  aggregate: AggregateWareHouse!
}

input WareHouseCreateInput {
  id: ID
  name: String
  company: CompanyCreateOneInput!
  isArchived: Boolean
  isDeleted: Boolean
}

input WareHouseCreateOneInput {
  create: WareHouseCreateInput
  connect: WareHouseWhereUniqueInput
}

type WareHouseEdge {
  node: WareHouse!
  cursor: String!
}

enum WareHouseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  isArchived_ASC
  isArchived_DESC
  isDeleted_ASC
  isDeleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WareHousePreviousValues {
  id: ID!
  name: String
  isArchived: Boolean
  isDeleted: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WareHouseSubscriptionPayload {
  mutation: MutationType!
  node: WareHouse
  updatedFields: [String!]
  previousValues: WareHousePreviousValues
}

input WareHouseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WareHouseWhereInput
  AND: [WareHouseSubscriptionWhereInput!]
  OR: [WareHouseSubscriptionWhereInput!]
  NOT: [WareHouseSubscriptionWhereInput!]
}

input WareHouseUpdateDataInput {
  name: String
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input WareHouseUpdateInput {
  name: String
  company: CompanyUpdateOneRequiredInput
  isArchived: Boolean
  isDeleted: Boolean
}

input WareHouseUpdateManyMutationInput {
  name: String
  isArchived: Boolean
  isDeleted: Boolean
}

input WareHouseUpdateOneInput {
  create: WareHouseCreateInput
  update: WareHouseUpdateDataInput
  upsert: WareHouseUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: WareHouseWhereUniqueInput
}

input WareHouseUpsertNestedInput {
  update: WareHouseUpdateDataInput!
  create: WareHouseCreateInput!
}

input WareHouseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  company: CompanyWhereInput
  isArchived: Boolean
  isArchived_not: Boolean
  isDeleted: Boolean
  isDeleted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WareHouseWhereInput!]
  OR: [WareHouseWhereInput!]
  NOT: [WareHouseWhereInput!]
}

input WareHouseWhereUniqueInput {
  id: ID
}
`
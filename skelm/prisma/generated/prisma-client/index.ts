// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  apInvoice: (where?: ApInvoiceWhereInput) => Promise<boolean>;
  asset: (where?: AssetWhereInput) => Promise<boolean>;
  assetGroup: (where?: AssetGroupWhereInput) => Promise<boolean>;
  attachment: (where?: AttachmentWhereInput) => Promise<boolean>;
  bank: (where?: BankWhereInput) => Promise<boolean>;
  bankTransaction: (where?: BankTransactionWhereInput) => Promise<boolean>;
  basicDailyFee: (where?: BasicDailyFeeWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  companyMember: (where?: CompanyMemberWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  disease: (where?: DiseaseWhereInput) => Promise<boolean>;
  hILog: (where?: HILogWhereInput) => Promise<boolean>;
  healthcareProvider: (
    where?: HealthcareProviderWhereInput
  ) => Promise<boolean>;
  immunisationSchedule: (
    where?: ImmunisationScheduleWhereInput
  ) => Promise<boolean>;
  integration: (where?: IntegrationWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  inventoryOnHand: (where?: InventoryOnHandWhereInput) => Promise<boolean>;
  invoice: (where?: InvoiceWhereInput) => Promise<boolean>;
  invoiceItemEntry: (where?: InvoiceItemEntryWhereInput) => Promise<boolean>;
  ledgerJournal: (where?: LedgerJournalWhereInput) => Promise<boolean>;
  ledgerPosting: (where?: LedgerPostingWhereInput) => Promise<boolean>;
  ledgerTransaction: (where?: LedgerTransactionWhereInput) => Promise<boolean>;
  mainAccount: (where?: MainAccountWhereInput) => Promise<boolean>;
  meansTestLimits: (where?: MeansTestLimitsWhereInput) => Promise<boolean>;
  meansTestedFee: (where?: MeansTestedFeeWhereInput) => Promise<boolean>;
  medicareService: (where?: MedicareServiceWhereInput) => Promise<boolean>;
  name: (where?: NameWhereInput) => Promise<boolean>;
  patient: (where?: PatientWhereInput) => Promise<boolean>;
  pbsOrganisation: (where?: PbsOrganisationWhereInput) => Promise<boolean>;
  pbsTPP: (where?: PbsTPPWhereInput) => Promise<boolean>;
  plan: (where?: PlanWhereInput) => Promise<boolean>;
  poReceipt: (where?: PoReceiptWhereInput) => Promise<boolean>;
  predictedSalesQuantityOfItemsByCompany: (
    where?: PredictedSalesQuantityOfItemsByCompanyWhereInput
  ) => Promise<boolean>;
  predictedSalesValueByCompany: (
    where?: PredictedSalesValueByCompanyWhereInput
  ) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  projectService: (where?: ProjectServiceWhereInput) => Promise<boolean>;
  projectServiceRule: (
    where?: ProjectServiceRuleWhereInput
  ) => Promise<boolean>;
  purchaseOrder: (where?: PurchaseOrderWhereInput) => Promise<boolean>;
  purchaseOrderLine: (where?: PurchaseOrderLineWhereInput) => Promise<boolean>;
  salesOrder: (where?: SalesOrderWhereInput) => Promise<boolean>;
  salesOrderLine: (where?: SalesOrderLineWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  supplier: (where?: SupplierWhereInput) => Promise<boolean>;
  timeSheet: (where?: TimeSheetWhereInput) => Promise<boolean>;
  timeSheetEntry: (where?: TimeSheetEntryWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  vaccineBrand: (where?: VaccineBrandWhereInput) => Promise<boolean>;
  wareHouse: (where?: WareHouseWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  apInvoice: (where: ApInvoiceWhereUniqueInput) => ApInvoiceNullablePromise;
  apInvoices: (args?: {
    where?: ApInvoiceWhereInput;
    orderBy?: ApInvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ApInvoice>;
  apInvoicesConnection: (args?: {
    where?: ApInvoiceWhereInput;
    orderBy?: ApInvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApInvoiceConnectionPromise;
  asset: (where: AssetWhereUniqueInput) => AssetNullablePromise;
  assets: (args?: {
    where?: AssetWhereInput;
    orderBy?: AssetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Asset>;
  assetsConnection: (args?: {
    where?: AssetWhereInput;
    orderBy?: AssetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AssetConnectionPromise;
  assetGroup: (where: AssetGroupWhereUniqueInput) => AssetGroupNullablePromise;
  assetGroups: (args?: {
    where?: AssetGroupWhereInput;
    orderBy?: AssetGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AssetGroup>;
  assetGroupsConnection: (args?: {
    where?: AssetGroupWhereInput;
    orderBy?: AssetGroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AssetGroupConnectionPromise;
  attachment: (where: AttachmentWhereUniqueInput) => AttachmentNullablePromise;
  attachments: (args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Attachment>;
  attachmentsConnection: (args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttachmentConnectionPromise;
  bank: (where: BankWhereUniqueInput) => BankNullablePromise;
  banks: (args?: {
    where?: BankWhereInput;
    orderBy?: BankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bank>;
  banksConnection: (args?: {
    where?: BankWhereInput;
    orderBy?: BankOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BankConnectionPromise;
  bankTransaction: (
    where: BankTransactionWhereUniqueInput
  ) => BankTransactionNullablePromise;
  bankTransactions: (args?: {
    where?: BankTransactionWhereInput;
    orderBy?: BankTransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BankTransaction>;
  bankTransactionsConnection: (args?: {
    where?: BankTransactionWhereInput;
    orderBy?: BankTransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BankTransactionConnectionPromise;
  basicDailyFee: (
    where: BasicDailyFeeWhereUniqueInput
  ) => BasicDailyFeeNullablePromise;
  basicDailyFees: (args?: {
    where?: BasicDailyFeeWhereInput;
    orderBy?: BasicDailyFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BasicDailyFee>;
  basicDailyFeesConnection: (args?: {
    where?: BasicDailyFeeWhereInput;
    orderBy?: BasicDailyFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BasicDailyFeeConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  companyMember: (
    where: CompanyMemberWhereUniqueInput
  ) => CompanyMemberNullablePromise;
  companyMembers: (args?: {
    where?: CompanyMemberWhereInput;
    orderBy?: CompanyMemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CompanyMember>;
  companyMembersConnection: (args?: {
    where?: CompanyMemberWhereInput;
    orderBy?: CompanyMemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyMemberConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  disease: (where: DiseaseWhereUniqueInput) => DiseaseNullablePromise;
  diseases: (args?: {
    where?: DiseaseWhereInput;
    orderBy?: DiseaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Disease>;
  diseasesConnection: (args?: {
    where?: DiseaseWhereInput;
    orderBy?: DiseaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiseaseConnectionPromise;
  hILog: (where: HILogWhereUniqueInput) => HILogNullablePromise;
  hILogs: (args?: {
    where?: HILogWhereInput;
    orderBy?: HILogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HILog>;
  hILogsConnection: (args?: {
    where?: HILogWhereInput;
    orderBy?: HILogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HILogConnectionPromise;
  healthcareProvider: (
    where: HealthcareProviderWhereUniqueInput
  ) => HealthcareProviderNullablePromise;
  healthcareProviders: (args?: {
    where?: HealthcareProviderWhereInput;
    orderBy?: HealthcareProviderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HealthcareProvider>;
  healthcareProvidersConnection: (args?: {
    where?: HealthcareProviderWhereInput;
    orderBy?: HealthcareProviderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HealthcareProviderConnectionPromise;
  immunisationSchedule: (
    where: ImmunisationScheduleWhereUniqueInput
  ) => ImmunisationScheduleNullablePromise;
  immunisationSchedules: (args?: {
    where?: ImmunisationScheduleWhereInput;
    orderBy?: ImmunisationScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ImmunisationSchedule>;
  immunisationSchedulesConnection: (args?: {
    where?: ImmunisationScheduleWhereInput;
    orderBy?: ImmunisationScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImmunisationScheduleConnectionPromise;
  integration: (
    where: IntegrationWhereUniqueInput
  ) => IntegrationNullablePromise;
  integrations: (args?: {
    where?: IntegrationWhereInput;
    orderBy?: IntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Integration>;
  integrationsConnection: (args?: {
    where?: IntegrationWhereInput;
    orderBy?: IntegrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IntegrationConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryNullablePromise;
  inventories: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Inventory>;
  inventoriesConnection: (args?: {
    where?: InventoryWhereInput;
    orderBy?: InventoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryConnectionPromise;
  inventoryOnHand: (
    where: InventoryOnHandWhereUniqueInput
  ) => InventoryOnHandNullablePromise;
  inventoryOnHands: (args?: {
    where?: InventoryOnHandWhereInput;
    orderBy?: InventoryOnHandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InventoryOnHand>;
  inventoryOnHandsConnection: (args?: {
    where?: InventoryOnHandWhereInput;
    orderBy?: InventoryOnHandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InventoryOnHandConnectionPromise;
  invoice: (where: InvoiceWhereUniqueInput) => InvoiceNullablePromise;
  invoices: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invoice>;
  invoicesConnection: (args?: {
    where?: InvoiceWhereInput;
    orderBy?: InvoiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvoiceConnectionPromise;
  invoiceItemEntry: (
    where: InvoiceItemEntryWhereUniqueInput
  ) => InvoiceItemEntryNullablePromise;
  invoiceItemEntries: (args?: {
    where?: InvoiceItemEntryWhereInput;
    orderBy?: InvoiceItemEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<InvoiceItemEntry>;
  invoiceItemEntriesConnection: (args?: {
    where?: InvoiceItemEntryWhereInput;
    orderBy?: InvoiceItemEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvoiceItemEntryConnectionPromise;
  ledgerJournal: (
    where: LedgerJournalWhereUniqueInput
  ) => LedgerJournalNullablePromise;
  ledgerJournals: (args?: {
    where?: LedgerJournalWhereInput;
    orderBy?: LedgerJournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LedgerJournal>;
  ledgerJournalsConnection: (args?: {
    where?: LedgerJournalWhereInput;
    orderBy?: LedgerJournalOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LedgerJournalConnectionPromise;
  ledgerPosting: (
    where: LedgerPostingWhereUniqueInput
  ) => LedgerPostingNullablePromise;
  ledgerPostings: (args?: {
    where?: LedgerPostingWhereInput;
    orderBy?: LedgerPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LedgerPosting>;
  ledgerPostingsConnection: (args?: {
    where?: LedgerPostingWhereInput;
    orderBy?: LedgerPostingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LedgerPostingConnectionPromise;
  ledgerTransaction: (
    where: LedgerTransactionWhereUniqueInput
  ) => LedgerTransactionNullablePromise;
  ledgerTransactions: (args?: {
    where?: LedgerTransactionWhereInput;
    orderBy?: LedgerTransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LedgerTransaction>;
  ledgerTransactionsConnection: (args?: {
    where?: LedgerTransactionWhereInput;
    orderBy?: LedgerTransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LedgerTransactionConnectionPromise;
  mainAccount: (
    where: MainAccountWhereUniqueInput
  ) => MainAccountNullablePromise;
  mainAccounts: (args?: {
    where?: MainAccountWhereInput;
    orderBy?: MainAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MainAccount>;
  mainAccountsConnection: (args?: {
    where?: MainAccountWhereInput;
    orderBy?: MainAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MainAccountConnectionPromise;
  meansTestLimits: (
    where: MeansTestLimitsWhereUniqueInput
  ) => MeansTestLimitsNullablePromise;
  meansTestLimitses: (args?: {
    where?: MeansTestLimitsWhereInput;
    orderBy?: MeansTestLimitsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeansTestLimits>;
  meansTestLimitsesConnection: (args?: {
    where?: MeansTestLimitsWhereInput;
    orderBy?: MeansTestLimitsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeansTestLimitsConnectionPromise;
  meansTestedFee: (
    where: MeansTestedFeeWhereUniqueInput
  ) => MeansTestedFeeNullablePromise;
  meansTestedFees: (args?: {
    where?: MeansTestedFeeWhereInput;
    orderBy?: MeansTestedFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MeansTestedFee>;
  meansTestedFeesConnection: (args?: {
    where?: MeansTestedFeeWhereInput;
    orderBy?: MeansTestedFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeansTestedFeeConnectionPromise;
  medicareService: (
    where: MedicareServiceWhereUniqueInput
  ) => MedicareServiceNullablePromise;
  medicareServices: (args?: {
    where?: MedicareServiceWhereInput;
    orderBy?: MedicareServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MedicareService>;
  medicareServicesConnection: (args?: {
    where?: MedicareServiceWhereInput;
    orderBy?: MedicareServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MedicareServiceConnectionPromise;
  name: (where: NameWhereUniqueInput) => NameNullablePromise;
  names: (args?: {
    where?: NameWhereInput;
    orderBy?: NameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Name>;
  namesConnection: (args?: {
    where?: NameWhereInput;
    orderBy?: NameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NameConnectionPromise;
  patient: (where: PatientWhereUniqueInput) => PatientNullablePromise;
  patients: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Patient>;
  patientsConnection: (args?: {
    where?: PatientWhereInput;
    orderBy?: PatientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PatientConnectionPromise;
  pbsOrganisation: (
    where: PbsOrganisationWhereUniqueInput
  ) => PbsOrganisationNullablePromise;
  pbsOrganisations: (args?: {
    where?: PbsOrganisationWhereInput;
    orderBy?: PbsOrganisationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PbsOrganisation>;
  pbsOrganisationsConnection: (args?: {
    where?: PbsOrganisationWhereInput;
    orderBy?: PbsOrganisationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PbsOrganisationConnectionPromise;
  pbsTPP: (where: PbsTPPWhereUniqueInput) => PbsTPPNullablePromise;
  pbsTPPs: (args?: {
    where?: PbsTPPWhereInput;
    orderBy?: PbsTPPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PbsTPP>;
  pbsTPPsConnection: (args?: {
    where?: PbsTPPWhereInput;
    orderBy?: PbsTPPOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PbsTPPConnectionPromise;
  plan: (where: PlanWhereUniqueInput) => PlanNullablePromise;
  plans: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Plan>;
  plansConnection: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlanConnectionPromise;
  poReceipt: (where: PoReceiptWhereUniqueInput) => PoReceiptNullablePromise;
  poReceipts: (args?: {
    where?: PoReceiptWhereInput;
    orderBy?: PoReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PoReceipt>;
  poReceiptsConnection: (args?: {
    where?: PoReceiptWhereInput;
    orderBy?: PoReceiptOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PoReceiptConnectionPromise;
  predictedSalesQuantityOfItemsByCompany: (
    where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput
  ) => PredictedSalesQuantityOfItemsByCompanyNullablePromise;
  predictedSalesQuantityOfItemsByCompanies: (args?: {
    where?: PredictedSalesQuantityOfItemsByCompanyWhereInput;
    orderBy?: PredictedSalesQuantityOfItemsByCompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PredictedSalesQuantityOfItemsByCompany>;
  predictedSalesQuantityOfItemsByCompaniesConnection: (args?: {
    where?: PredictedSalesQuantityOfItemsByCompanyWhereInput;
    orderBy?: PredictedSalesQuantityOfItemsByCompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PredictedSalesQuantityOfItemsByCompanyConnectionPromise;
  predictedSalesValueByCompany: (
    where: PredictedSalesValueByCompanyWhereUniqueInput
  ) => PredictedSalesValueByCompanyNullablePromise;
  predictedSalesValueByCompanies: (args?: {
    where?: PredictedSalesValueByCompanyWhereInput;
    orderBy?: PredictedSalesValueByCompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PredictedSalesValueByCompany>;
  predictedSalesValueByCompaniesConnection: (args?: {
    where?: PredictedSalesValueByCompanyWhereInput;
    orderBy?: PredictedSalesValueByCompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PredictedSalesValueByCompanyConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  projectService: (
    where: ProjectServiceWhereUniqueInput
  ) => ProjectServiceNullablePromise;
  projectServices: (args?: {
    where?: ProjectServiceWhereInput;
    orderBy?: ProjectServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProjectService>;
  projectServicesConnection: (args?: {
    where?: ProjectServiceWhereInput;
    orderBy?: ProjectServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectServiceConnectionPromise;
  projectServiceRule: (
    where: ProjectServiceRuleWhereUniqueInput
  ) => ProjectServiceRuleNullablePromise;
  projectServiceRules: (args?: {
    where?: ProjectServiceRuleWhereInput;
    orderBy?: ProjectServiceRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProjectServiceRule>;
  projectServiceRulesConnection: (args?: {
    where?: ProjectServiceRuleWhereInput;
    orderBy?: ProjectServiceRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectServiceRuleConnectionPromise;
  purchaseOrder: (
    where: PurchaseOrderWhereUniqueInput
  ) => PurchaseOrderNullablePromise;
  purchaseOrders: (args?: {
    where?: PurchaseOrderWhereInput;
    orderBy?: PurchaseOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PurchaseOrder>;
  purchaseOrdersConnection: (args?: {
    where?: PurchaseOrderWhereInput;
    orderBy?: PurchaseOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PurchaseOrderConnectionPromise;
  purchaseOrderLine: (
    where: PurchaseOrderLineWhereUniqueInput
  ) => PurchaseOrderLineNullablePromise;
  purchaseOrderLines: (args?: {
    where?: PurchaseOrderLineWhereInput;
    orderBy?: PurchaseOrderLineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PurchaseOrderLine>;
  purchaseOrderLinesConnection: (args?: {
    where?: PurchaseOrderLineWhereInput;
    orderBy?: PurchaseOrderLineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PurchaseOrderLineConnectionPromise;
  salesOrder: (where: SalesOrderWhereUniqueInput) => SalesOrderNullablePromise;
  salesOrders: (args?: {
    where?: SalesOrderWhereInput;
    orderBy?: SalesOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SalesOrder>;
  salesOrdersConnection: (args?: {
    where?: SalesOrderWhereInput;
    orderBy?: SalesOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SalesOrderConnectionPromise;
  salesOrderLine: (
    where: SalesOrderLineWhereUniqueInput
  ) => SalesOrderLineNullablePromise;
  salesOrderLines: (args?: {
    where?: SalesOrderLineWhereInput;
    orderBy?: SalesOrderLineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SalesOrderLine>;
  salesOrderLinesConnection: (args?: {
    where?: SalesOrderLineWhereInput;
    orderBy?: SalesOrderLineOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SalesOrderLineConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServiceNullablePromise;
  services: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Service>;
  servicesConnection: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionNullablePromise;
  sessions: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Session>;
  sessionsConnection: (args?: {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SessionConnectionPromise;
  supplier: (where: SupplierWhereUniqueInput) => SupplierNullablePromise;
  suppliers: (args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Supplier>;
  suppliersConnection: (args?: {
    where?: SupplierWhereInput;
    orderBy?: SupplierOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SupplierConnectionPromise;
  timeSheet: (where: TimeSheetWhereUniqueInput) => TimeSheetNullablePromise;
  timeSheets: (args?: {
    where?: TimeSheetWhereInput;
    orderBy?: TimeSheetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TimeSheet>;
  timeSheetsConnection: (args?: {
    where?: TimeSheetWhereInput;
    orderBy?: TimeSheetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TimeSheetConnectionPromise;
  timeSheetEntry: (
    where: TimeSheetEntryWhereUniqueInput
  ) => TimeSheetEntryNullablePromise;
  timeSheetEntries: (args?: {
    where?: TimeSheetEntryWhereInput;
    orderBy?: TimeSheetEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TimeSheetEntry>;
  timeSheetEntriesConnection: (args?: {
    where?: TimeSheetEntryWhereInput;
    orderBy?: TimeSheetEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TimeSheetEntryConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  vaccineBrand: (
    where: VaccineBrandWhereUniqueInput
  ) => VaccineBrandNullablePromise;
  vaccineBrands: (args?: {
    where?: VaccineBrandWhereInput;
    orderBy?: VaccineBrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VaccineBrand>;
  vaccineBrandsConnection: (args?: {
    where?: VaccineBrandWhereInput;
    orderBy?: VaccineBrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VaccineBrandConnectionPromise;
  wareHouse: (where: WareHouseWhereUniqueInput) => WareHouseNullablePromise;
  wareHouses: (args?: {
    where?: WareHouseWhereInput;
    orderBy?: WareHouseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WareHouse>;
  wareHousesConnection: (args?: {
    where?: WareHouseWhereInput;
    orderBy?: WareHouseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WareHouseConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createApInvoice: (data: ApInvoiceCreateInput) => ApInvoicePromise;
  updateApInvoice: (args: {
    data: ApInvoiceUpdateInput;
    where: ApInvoiceWhereUniqueInput;
  }) => ApInvoicePromise;
  updateManyApInvoices: (args: {
    data: ApInvoiceUpdateManyMutationInput;
    where?: ApInvoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertApInvoice: (args: {
    where: ApInvoiceWhereUniqueInput;
    create: ApInvoiceCreateInput;
    update: ApInvoiceUpdateInput;
  }) => ApInvoicePromise;
  deleteApInvoice: (where: ApInvoiceWhereUniqueInput) => ApInvoicePromise;
  deleteManyApInvoices: (where?: ApInvoiceWhereInput) => BatchPayloadPromise;
  createAsset: (data: AssetCreateInput) => AssetPromise;
  updateAsset: (args: {
    data: AssetUpdateInput;
    where: AssetWhereUniqueInput;
  }) => AssetPromise;
  updateManyAssets: (args: {
    data: AssetUpdateManyMutationInput;
    where?: AssetWhereInput;
  }) => BatchPayloadPromise;
  upsertAsset: (args: {
    where: AssetWhereUniqueInput;
    create: AssetCreateInput;
    update: AssetUpdateInput;
  }) => AssetPromise;
  deleteAsset: (where: AssetWhereUniqueInput) => AssetPromise;
  deleteManyAssets: (where?: AssetWhereInput) => BatchPayloadPromise;
  createAssetGroup: (data: AssetGroupCreateInput) => AssetGroupPromise;
  updateAssetGroup: (args: {
    data: AssetGroupUpdateInput;
    where: AssetGroupWhereUniqueInput;
  }) => AssetGroupPromise;
  updateManyAssetGroups: (args: {
    data: AssetGroupUpdateManyMutationInput;
    where?: AssetGroupWhereInput;
  }) => BatchPayloadPromise;
  upsertAssetGroup: (args: {
    where: AssetGroupWhereUniqueInput;
    create: AssetGroupCreateInput;
    update: AssetGroupUpdateInput;
  }) => AssetGroupPromise;
  deleteAssetGroup: (where: AssetGroupWhereUniqueInput) => AssetGroupPromise;
  deleteManyAssetGroups: (where?: AssetGroupWhereInput) => BatchPayloadPromise;
  createAttachment: (data: AttachmentCreateInput) => AttachmentPromise;
  updateAttachment: (args: {
    data: AttachmentUpdateInput;
    where: AttachmentWhereUniqueInput;
  }) => AttachmentPromise;
  updateManyAttachments: (args: {
    data: AttachmentUpdateManyMutationInput;
    where?: AttachmentWhereInput;
  }) => BatchPayloadPromise;
  upsertAttachment: (args: {
    where: AttachmentWhereUniqueInput;
    create: AttachmentCreateInput;
    update: AttachmentUpdateInput;
  }) => AttachmentPromise;
  deleteAttachment: (where: AttachmentWhereUniqueInput) => AttachmentPromise;
  deleteManyAttachments: (where?: AttachmentWhereInput) => BatchPayloadPromise;
  createBank: (data: BankCreateInput) => BankPromise;
  updateBank: (args: {
    data: BankUpdateInput;
    where: BankWhereUniqueInput;
  }) => BankPromise;
  updateManyBanks: (args: {
    data: BankUpdateManyMutationInput;
    where?: BankWhereInput;
  }) => BatchPayloadPromise;
  upsertBank: (args: {
    where: BankWhereUniqueInput;
    create: BankCreateInput;
    update: BankUpdateInput;
  }) => BankPromise;
  deleteBank: (where: BankWhereUniqueInput) => BankPromise;
  deleteManyBanks: (where?: BankWhereInput) => BatchPayloadPromise;
  createBankTransaction: (
    data: BankTransactionCreateInput
  ) => BankTransactionPromise;
  updateBankTransaction: (args: {
    data: BankTransactionUpdateInput;
    where: BankTransactionWhereUniqueInput;
  }) => BankTransactionPromise;
  updateManyBankTransactions: (args: {
    data: BankTransactionUpdateManyMutationInput;
    where?: BankTransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertBankTransaction: (args: {
    where: BankTransactionWhereUniqueInput;
    create: BankTransactionCreateInput;
    update: BankTransactionUpdateInput;
  }) => BankTransactionPromise;
  deleteBankTransaction: (
    where: BankTransactionWhereUniqueInput
  ) => BankTransactionPromise;
  deleteManyBankTransactions: (
    where?: BankTransactionWhereInput
  ) => BatchPayloadPromise;
  createBasicDailyFee: (data: BasicDailyFeeCreateInput) => BasicDailyFeePromise;
  updateBasicDailyFee: (args: {
    data: BasicDailyFeeUpdateInput;
    where: BasicDailyFeeWhereUniqueInput;
  }) => BasicDailyFeePromise;
  updateManyBasicDailyFees: (args: {
    data: BasicDailyFeeUpdateManyMutationInput;
    where?: BasicDailyFeeWhereInput;
  }) => BatchPayloadPromise;
  upsertBasicDailyFee: (args: {
    where: BasicDailyFeeWhereUniqueInput;
    create: BasicDailyFeeCreateInput;
    update: BasicDailyFeeUpdateInput;
  }) => BasicDailyFeePromise;
  deleteBasicDailyFee: (
    where: BasicDailyFeeWhereUniqueInput
  ) => BasicDailyFeePromise;
  deleteManyBasicDailyFees: (
    where?: BasicDailyFeeWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCompanyMember: (data: CompanyMemberCreateInput) => CompanyMemberPromise;
  updateCompanyMember: (args: {
    data: CompanyMemberUpdateInput;
    where: CompanyMemberWhereUniqueInput;
  }) => CompanyMemberPromise;
  updateManyCompanyMembers: (args: {
    data: CompanyMemberUpdateManyMutationInput;
    where?: CompanyMemberWhereInput;
  }) => BatchPayloadPromise;
  upsertCompanyMember: (args: {
    where: CompanyMemberWhereUniqueInput;
    create: CompanyMemberCreateInput;
    update: CompanyMemberUpdateInput;
  }) => CompanyMemberPromise;
  deleteCompanyMember: (
    where: CompanyMemberWhereUniqueInput
  ) => CompanyMemberPromise;
  deleteManyCompanyMembers: (
    where?: CompanyMemberWhereInput
  ) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createDisease: (data: DiseaseCreateInput) => DiseasePromise;
  updateDisease: (args: {
    data: DiseaseUpdateInput;
    where: DiseaseWhereUniqueInput;
  }) => DiseasePromise;
  updateManyDiseases: (args: {
    data: DiseaseUpdateManyMutationInput;
    where?: DiseaseWhereInput;
  }) => BatchPayloadPromise;
  upsertDisease: (args: {
    where: DiseaseWhereUniqueInput;
    create: DiseaseCreateInput;
    update: DiseaseUpdateInput;
  }) => DiseasePromise;
  deleteDisease: (where: DiseaseWhereUniqueInput) => DiseasePromise;
  deleteManyDiseases: (where?: DiseaseWhereInput) => BatchPayloadPromise;
  createHILog: (data: HILogCreateInput) => HILogPromise;
  updateHILog: (args: {
    data: HILogUpdateInput;
    where: HILogWhereUniqueInput;
  }) => HILogPromise;
  updateManyHILogs: (args: {
    data: HILogUpdateManyMutationInput;
    where?: HILogWhereInput;
  }) => BatchPayloadPromise;
  upsertHILog: (args: {
    where: HILogWhereUniqueInput;
    create: HILogCreateInput;
    update: HILogUpdateInput;
  }) => HILogPromise;
  deleteHILog: (where: HILogWhereUniqueInput) => HILogPromise;
  deleteManyHILogs: (where?: HILogWhereInput) => BatchPayloadPromise;
  createHealthcareProvider: (
    data: HealthcareProviderCreateInput
  ) => HealthcareProviderPromise;
  updateHealthcareProvider: (args: {
    data: HealthcareProviderUpdateInput;
    where: HealthcareProviderWhereUniqueInput;
  }) => HealthcareProviderPromise;
  updateManyHealthcareProviders: (args: {
    data: HealthcareProviderUpdateManyMutationInput;
    where?: HealthcareProviderWhereInput;
  }) => BatchPayloadPromise;
  upsertHealthcareProvider: (args: {
    where: HealthcareProviderWhereUniqueInput;
    create: HealthcareProviderCreateInput;
    update: HealthcareProviderUpdateInput;
  }) => HealthcareProviderPromise;
  deleteHealthcareProvider: (
    where: HealthcareProviderWhereUniqueInput
  ) => HealthcareProviderPromise;
  deleteManyHealthcareProviders: (
    where?: HealthcareProviderWhereInput
  ) => BatchPayloadPromise;
  createImmunisationSchedule: (
    data: ImmunisationScheduleCreateInput
  ) => ImmunisationSchedulePromise;
  updateImmunisationSchedule: (args: {
    data: ImmunisationScheduleUpdateInput;
    where: ImmunisationScheduleWhereUniqueInput;
  }) => ImmunisationSchedulePromise;
  updateManyImmunisationSchedules: (args: {
    data: ImmunisationScheduleUpdateManyMutationInput;
    where?: ImmunisationScheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertImmunisationSchedule: (args: {
    where: ImmunisationScheduleWhereUniqueInput;
    create: ImmunisationScheduleCreateInput;
    update: ImmunisationScheduleUpdateInput;
  }) => ImmunisationSchedulePromise;
  deleteImmunisationSchedule: (
    where: ImmunisationScheduleWhereUniqueInput
  ) => ImmunisationSchedulePromise;
  deleteManyImmunisationSchedules: (
    where?: ImmunisationScheduleWhereInput
  ) => BatchPayloadPromise;
  createIntegration: (data: IntegrationCreateInput) => IntegrationPromise;
  updateIntegration: (args: {
    data: IntegrationUpdateInput;
    where: IntegrationWhereUniqueInput;
  }) => IntegrationPromise;
  updateManyIntegrations: (args: {
    data: IntegrationUpdateManyMutationInput;
    where?: IntegrationWhereInput;
  }) => BatchPayloadPromise;
  upsertIntegration: (args: {
    where: IntegrationWhereUniqueInput;
    create: IntegrationCreateInput;
    update: IntegrationUpdateInput;
  }) => IntegrationPromise;
  deleteIntegration: (where: IntegrationWhereUniqueInput) => IntegrationPromise;
  deleteManyIntegrations: (
    where?: IntegrationWhereInput
  ) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (args: {
    data: InventoryUpdateInput;
    where: InventoryWhereUniqueInput;
  }) => InventoryPromise;
  updateManyInventories: (args: {
    data: InventoryUpdateManyMutationInput;
    where?: InventoryWhereInput;
  }) => BatchPayloadPromise;
  upsertInventory: (args: {
    where: InventoryWhereUniqueInput;
    create: InventoryCreateInput;
    update: InventoryUpdateInput;
  }) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createInventoryOnHand: (
    data: InventoryOnHandCreateInput
  ) => InventoryOnHandPromise;
  updateInventoryOnHand: (args: {
    data: InventoryOnHandUpdateInput;
    where: InventoryOnHandWhereUniqueInput;
  }) => InventoryOnHandPromise;
  updateManyInventoryOnHands: (args: {
    data: InventoryOnHandUpdateManyMutationInput;
    where?: InventoryOnHandWhereInput;
  }) => BatchPayloadPromise;
  upsertInventoryOnHand: (args: {
    where: InventoryOnHandWhereUniqueInput;
    create: InventoryOnHandCreateInput;
    update: InventoryOnHandUpdateInput;
  }) => InventoryOnHandPromise;
  deleteInventoryOnHand: (
    where: InventoryOnHandWhereUniqueInput
  ) => InventoryOnHandPromise;
  deleteManyInventoryOnHands: (
    where?: InventoryOnHandWhereInput
  ) => BatchPayloadPromise;
  createInvoice: (data: InvoiceCreateInput) => InvoicePromise;
  updateInvoice: (args: {
    data: InvoiceUpdateInput;
    where: InvoiceWhereUniqueInput;
  }) => InvoicePromise;
  updateManyInvoices: (args: {
    data: InvoiceUpdateManyMutationInput;
    where?: InvoiceWhereInput;
  }) => BatchPayloadPromise;
  upsertInvoice: (args: {
    where: InvoiceWhereUniqueInput;
    create: InvoiceCreateInput;
    update: InvoiceUpdateInput;
  }) => InvoicePromise;
  deleteInvoice: (where: InvoiceWhereUniqueInput) => InvoicePromise;
  deleteManyInvoices: (where?: InvoiceWhereInput) => BatchPayloadPromise;
  createInvoiceItemEntry: (
    data: InvoiceItemEntryCreateInput
  ) => InvoiceItemEntryPromise;
  updateInvoiceItemEntry: (args: {
    data: InvoiceItemEntryUpdateInput;
    where: InvoiceItemEntryWhereUniqueInput;
  }) => InvoiceItemEntryPromise;
  updateManyInvoiceItemEntries: (args: {
    data: InvoiceItemEntryUpdateManyMutationInput;
    where?: InvoiceItemEntryWhereInput;
  }) => BatchPayloadPromise;
  upsertInvoiceItemEntry: (args: {
    where: InvoiceItemEntryWhereUniqueInput;
    create: InvoiceItemEntryCreateInput;
    update: InvoiceItemEntryUpdateInput;
  }) => InvoiceItemEntryPromise;
  deleteInvoiceItemEntry: (
    where: InvoiceItemEntryWhereUniqueInput
  ) => InvoiceItemEntryPromise;
  deleteManyInvoiceItemEntries: (
    where?: InvoiceItemEntryWhereInput
  ) => BatchPayloadPromise;
  createLedgerJournal: (data: LedgerJournalCreateInput) => LedgerJournalPromise;
  updateLedgerJournal: (args: {
    data: LedgerJournalUpdateInput;
    where: LedgerJournalWhereUniqueInput;
  }) => LedgerJournalPromise;
  updateManyLedgerJournals: (args: {
    data: LedgerJournalUpdateManyMutationInput;
    where?: LedgerJournalWhereInput;
  }) => BatchPayloadPromise;
  upsertLedgerJournal: (args: {
    where: LedgerJournalWhereUniqueInput;
    create: LedgerJournalCreateInput;
    update: LedgerJournalUpdateInput;
  }) => LedgerJournalPromise;
  deleteLedgerJournal: (
    where: LedgerJournalWhereUniqueInput
  ) => LedgerJournalPromise;
  deleteManyLedgerJournals: (
    where?: LedgerJournalWhereInput
  ) => BatchPayloadPromise;
  createLedgerPosting: (data: LedgerPostingCreateInput) => LedgerPostingPromise;
  updateLedgerPosting: (args: {
    data: LedgerPostingUpdateInput;
    where: LedgerPostingWhereUniqueInput;
  }) => LedgerPostingPromise;
  updateManyLedgerPostings: (args: {
    data: LedgerPostingUpdateManyMutationInput;
    where?: LedgerPostingWhereInput;
  }) => BatchPayloadPromise;
  upsertLedgerPosting: (args: {
    where: LedgerPostingWhereUniqueInput;
    create: LedgerPostingCreateInput;
    update: LedgerPostingUpdateInput;
  }) => LedgerPostingPromise;
  deleteLedgerPosting: (
    where: LedgerPostingWhereUniqueInput
  ) => LedgerPostingPromise;
  deleteManyLedgerPostings: (
    where?: LedgerPostingWhereInput
  ) => BatchPayloadPromise;
  createLedgerTransaction: (
    data: LedgerTransactionCreateInput
  ) => LedgerTransactionPromise;
  updateLedgerTransaction: (args: {
    data: LedgerTransactionUpdateInput;
    where: LedgerTransactionWhereUniqueInput;
  }) => LedgerTransactionPromise;
  updateManyLedgerTransactions: (args: {
    data: LedgerTransactionUpdateManyMutationInput;
    where?: LedgerTransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertLedgerTransaction: (args: {
    where: LedgerTransactionWhereUniqueInput;
    create: LedgerTransactionCreateInput;
    update: LedgerTransactionUpdateInput;
  }) => LedgerTransactionPromise;
  deleteLedgerTransaction: (
    where: LedgerTransactionWhereUniqueInput
  ) => LedgerTransactionPromise;
  deleteManyLedgerTransactions: (
    where?: LedgerTransactionWhereInput
  ) => BatchPayloadPromise;
  createMainAccount: (data: MainAccountCreateInput) => MainAccountPromise;
  updateMainAccount: (args: {
    data: MainAccountUpdateInput;
    where: MainAccountWhereUniqueInput;
  }) => MainAccountPromise;
  updateManyMainAccounts: (args: {
    data: MainAccountUpdateManyMutationInput;
    where?: MainAccountWhereInput;
  }) => BatchPayloadPromise;
  upsertMainAccount: (args: {
    where: MainAccountWhereUniqueInput;
    create: MainAccountCreateInput;
    update: MainAccountUpdateInput;
  }) => MainAccountPromise;
  deleteMainAccount: (where: MainAccountWhereUniqueInput) => MainAccountPromise;
  deleteManyMainAccounts: (
    where?: MainAccountWhereInput
  ) => BatchPayloadPromise;
  createMeansTestLimits: (
    data: MeansTestLimitsCreateInput
  ) => MeansTestLimitsPromise;
  updateMeansTestLimits: (args: {
    data: MeansTestLimitsUpdateInput;
    where: MeansTestLimitsWhereUniqueInput;
  }) => MeansTestLimitsPromise;
  updateManyMeansTestLimitses: (args: {
    data: MeansTestLimitsUpdateManyMutationInput;
    where?: MeansTestLimitsWhereInput;
  }) => BatchPayloadPromise;
  upsertMeansTestLimits: (args: {
    where: MeansTestLimitsWhereUniqueInput;
    create: MeansTestLimitsCreateInput;
    update: MeansTestLimitsUpdateInput;
  }) => MeansTestLimitsPromise;
  deleteMeansTestLimits: (
    where: MeansTestLimitsWhereUniqueInput
  ) => MeansTestLimitsPromise;
  deleteManyMeansTestLimitses: (
    where?: MeansTestLimitsWhereInput
  ) => BatchPayloadPromise;
  createMeansTestedFee: (
    data: MeansTestedFeeCreateInput
  ) => MeansTestedFeePromise;
  updateMeansTestedFee: (args: {
    data: MeansTestedFeeUpdateInput;
    where: MeansTestedFeeWhereUniqueInput;
  }) => MeansTestedFeePromise;
  updateManyMeansTestedFees: (args: {
    data: MeansTestedFeeUpdateManyMutationInput;
    where?: MeansTestedFeeWhereInput;
  }) => BatchPayloadPromise;
  upsertMeansTestedFee: (args: {
    where: MeansTestedFeeWhereUniqueInput;
    create: MeansTestedFeeCreateInput;
    update: MeansTestedFeeUpdateInput;
  }) => MeansTestedFeePromise;
  deleteMeansTestedFee: (
    where: MeansTestedFeeWhereUniqueInput
  ) => MeansTestedFeePromise;
  deleteManyMeansTestedFees: (
    where?: MeansTestedFeeWhereInput
  ) => BatchPayloadPromise;
  createMedicareService: (
    data: MedicareServiceCreateInput
  ) => MedicareServicePromise;
  updateMedicareService: (args: {
    data: MedicareServiceUpdateInput;
    where: MedicareServiceWhereUniqueInput;
  }) => MedicareServicePromise;
  updateManyMedicareServices: (args: {
    data: MedicareServiceUpdateManyMutationInput;
    where?: MedicareServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertMedicareService: (args: {
    where: MedicareServiceWhereUniqueInput;
    create: MedicareServiceCreateInput;
    update: MedicareServiceUpdateInput;
  }) => MedicareServicePromise;
  deleteMedicareService: (
    where: MedicareServiceWhereUniqueInput
  ) => MedicareServicePromise;
  deleteManyMedicareServices: (
    where?: MedicareServiceWhereInput
  ) => BatchPayloadPromise;
  createName: (data: NameCreateInput) => NamePromise;
  updateName: (args: {
    data: NameUpdateInput;
    where: NameWhereUniqueInput;
  }) => NamePromise;
  updateManyNames: (args: {
    data: NameUpdateManyMutationInput;
    where?: NameWhereInput;
  }) => BatchPayloadPromise;
  upsertName: (args: {
    where: NameWhereUniqueInput;
    create: NameCreateInput;
    update: NameUpdateInput;
  }) => NamePromise;
  deleteName: (where: NameWhereUniqueInput) => NamePromise;
  deleteManyNames: (where?: NameWhereInput) => BatchPayloadPromise;
  createPatient: (data: PatientCreateInput) => PatientPromise;
  updatePatient: (args: {
    data: PatientUpdateInput;
    where: PatientWhereUniqueInput;
  }) => PatientPromise;
  updateManyPatients: (args: {
    data: PatientUpdateManyMutationInput;
    where?: PatientWhereInput;
  }) => BatchPayloadPromise;
  upsertPatient: (args: {
    where: PatientWhereUniqueInput;
    create: PatientCreateInput;
    update: PatientUpdateInput;
  }) => PatientPromise;
  deletePatient: (where: PatientWhereUniqueInput) => PatientPromise;
  deleteManyPatients: (where?: PatientWhereInput) => BatchPayloadPromise;
  createPbsOrganisation: (
    data: PbsOrganisationCreateInput
  ) => PbsOrganisationPromise;
  updatePbsOrganisation: (args: {
    data: PbsOrganisationUpdateInput;
    where: PbsOrganisationWhereUniqueInput;
  }) => PbsOrganisationPromise;
  updateManyPbsOrganisations: (args: {
    data: PbsOrganisationUpdateManyMutationInput;
    where?: PbsOrganisationWhereInput;
  }) => BatchPayloadPromise;
  upsertPbsOrganisation: (args: {
    where: PbsOrganisationWhereUniqueInput;
    create: PbsOrganisationCreateInput;
    update: PbsOrganisationUpdateInput;
  }) => PbsOrganisationPromise;
  deletePbsOrganisation: (
    where: PbsOrganisationWhereUniqueInput
  ) => PbsOrganisationPromise;
  deleteManyPbsOrganisations: (
    where?: PbsOrganisationWhereInput
  ) => BatchPayloadPromise;
  createPbsTPP: (data: PbsTPPCreateInput) => PbsTPPPromise;
  updatePbsTPP: (args: {
    data: PbsTPPUpdateInput;
    where: PbsTPPWhereUniqueInput;
  }) => PbsTPPPromise;
  updateManyPbsTPPs: (args: {
    data: PbsTPPUpdateManyMutationInput;
    where?: PbsTPPWhereInput;
  }) => BatchPayloadPromise;
  upsertPbsTPP: (args: {
    where: PbsTPPWhereUniqueInput;
    create: PbsTPPCreateInput;
    update: PbsTPPUpdateInput;
  }) => PbsTPPPromise;
  deletePbsTPP: (where: PbsTPPWhereUniqueInput) => PbsTPPPromise;
  deleteManyPbsTPPs: (where?: PbsTPPWhereInput) => BatchPayloadPromise;
  createPlan: (data: PlanCreateInput) => PlanPromise;
  updatePlan: (args: {
    data: PlanUpdateInput;
    where: PlanWhereUniqueInput;
  }) => PlanPromise;
  updateManyPlans: (args: {
    data: PlanUpdateManyMutationInput;
    where?: PlanWhereInput;
  }) => BatchPayloadPromise;
  upsertPlan: (args: {
    where: PlanWhereUniqueInput;
    create: PlanCreateInput;
    update: PlanUpdateInput;
  }) => PlanPromise;
  deletePlan: (where: PlanWhereUniqueInput) => PlanPromise;
  deleteManyPlans: (where?: PlanWhereInput) => BatchPayloadPromise;
  createPoReceipt: (data: PoReceiptCreateInput) => PoReceiptPromise;
  updatePoReceipt: (args: {
    data: PoReceiptUpdateInput;
    where: PoReceiptWhereUniqueInput;
  }) => PoReceiptPromise;
  updateManyPoReceipts: (args: {
    data: PoReceiptUpdateManyMutationInput;
    where?: PoReceiptWhereInput;
  }) => BatchPayloadPromise;
  upsertPoReceipt: (args: {
    where: PoReceiptWhereUniqueInput;
    create: PoReceiptCreateInput;
    update: PoReceiptUpdateInput;
  }) => PoReceiptPromise;
  deletePoReceipt: (where: PoReceiptWhereUniqueInput) => PoReceiptPromise;
  deleteManyPoReceipts: (where?: PoReceiptWhereInput) => BatchPayloadPromise;
  createPredictedSalesQuantityOfItemsByCompany: (
    data: PredictedSalesQuantityOfItemsByCompanyCreateInput
  ) => PredictedSalesQuantityOfItemsByCompanyPromise;
  updatePredictedSalesQuantityOfItemsByCompany: (args: {
    data: PredictedSalesQuantityOfItemsByCompanyUpdateInput;
    where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput;
  }) => PredictedSalesQuantityOfItemsByCompanyPromise;
  updateManyPredictedSalesQuantityOfItemsByCompanies: (args: {
    data: PredictedSalesQuantityOfItemsByCompanyUpdateManyMutationInput;
    where?: PredictedSalesQuantityOfItemsByCompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertPredictedSalesQuantityOfItemsByCompany: (args: {
    where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput;
    create: PredictedSalesQuantityOfItemsByCompanyCreateInput;
    update: PredictedSalesQuantityOfItemsByCompanyUpdateInput;
  }) => PredictedSalesQuantityOfItemsByCompanyPromise;
  deletePredictedSalesQuantityOfItemsByCompany: (
    where: PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput
  ) => PredictedSalesQuantityOfItemsByCompanyPromise;
  deleteManyPredictedSalesQuantityOfItemsByCompanies: (
    where?: PredictedSalesQuantityOfItemsByCompanyWhereInput
  ) => BatchPayloadPromise;
  createPredictedSalesValueByCompany: (
    data: PredictedSalesValueByCompanyCreateInput
  ) => PredictedSalesValueByCompanyPromise;
  updatePredictedSalesValueByCompany: (args: {
    data: PredictedSalesValueByCompanyUpdateInput;
    where: PredictedSalesValueByCompanyWhereUniqueInput;
  }) => PredictedSalesValueByCompanyPromise;
  updateManyPredictedSalesValueByCompanies: (args: {
    data: PredictedSalesValueByCompanyUpdateManyMutationInput;
    where?: PredictedSalesValueByCompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertPredictedSalesValueByCompany: (args: {
    where: PredictedSalesValueByCompanyWhereUniqueInput;
    create: PredictedSalesValueByCompanyCreateInput;
    update: PredictedSalesValueByCompanyUpdateInput;
  }) => PredictedSalesValueByCompanyPromise;
  deletePredictedSalesValueByCompany: (
    where: PredictedSalesValueByCompanyWhereUniqueInput
  ) => PredictedSalesValueByCompanyPromise;
  deleteManyPredictedSalesValueByCompanies: (
    where?: PredictedSalesValueByCompanyWhereInput
  ) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createProjectService: (
    data: ProjectServiceCreateInput
  ) => ProjectServicePromise;
  updateProjectService: (args: {
    data: ProjectServiceUpdateInput;
    where: ProjectServiceWhereUniqueInput;
  }) => ProjectServicePromise;
  updateManyProjectServices: (args: {
    data: ProjectServiceUpdateManyMutationInput;
    where?: ProjectServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertProjectService: (args: {
    where: ProjectServiceWhereUniqueInput;
    create: ProjectServiceCreateInput;
    update: ProjectServiceUpdateInput;
  }) => ProjectServicePromise;
  deleteProjectService: (
    where: ProjectServiceWhereUniqueInput
  ) => ProjectServicePromise;
  deleteManyProjectServices: (
    where?: ProjectServiceWhereInput
  ) => BatchPayloadPromise;
  createProjectServiceRule: (
    data: ProjectServiceRuleCreateInput
  ) => ProjectServiceRulePromise;
  updateProjectServiceRule: (args: {
    data: ProjectServiceRuleUpdateInput;
    where: ProjectServiceRuleWhereUniqueInput;
  }) => ProjectServiceRulePromise;
  updateManyProjectServiceRules: (args: {
    data: ProjectServiceRuleUpdateManyMutationInput;
    where?: ProjectServiceRuleWhereInput;
  }) => BatchPayloadPromise;
  upsertProjectServiceRule: (args: {
    where: ProjectServiceRuleWhereUniqueInput;
    create: ProjectServiceRuleCreateInput;
    update: ProjectServiceRuleUpdateInput;
  }) => ProjectServiceRulePromise;
  deleteProjectServiceRule: (
    where: ProjectServiceRuleWhereUniqueInput
  ) => ProjectServiceRulePromise;
  deleteManyProjectServiceRules: (
    where?: ProjectServiceRuleWhereInput
  ) => BatchPayloadPromise;
  createPurchaseOrder: (data: PurchaseOrderCreateInput) => PurchaseOrderPromise;
  updatePurchaseOrder: (args: {
    data: PurchaseOrderUpdateInput;
    where: PurchaseOrderWhereUniqueInput;
  }) => PurchaseOrderPromise;
  updateManyPurchaseOrders: (args: {
    data: PurchaseOrderUpdateManyMutationInput;
    where?: PurchaseOrderWhereInput;
  }) => BatchPayloadPromise;
  upsertPurchaseOrder: (args: {
    where: PurchaseOrderWhereUniqueInput;
    create: PurchaseOrderCreateInput;
    update: PurchaseOrderUpdateInput;
  }) => PurchaseOrderPromise;
  deletePurchaseOrder: (
    where: PurchaseOrderWhereUniqueInput
  ) => PurchaseOrderPromise;
  deleteManyPurchaseOrders: (
    where?: PurchaseOrderWhereInput
  ) => BatchPayloadPromise;
  createPurchaseOrderLine: (
    data: PurchaseOrderLineCreateInput
  ) => PurchaseOrderLinePromise;
  updatePurchaseOrderLine: (args: {
    data: PurchaseOrderLineUpdateInput;
    where: PurchaseOrderLineWhereUniqueInput;
  }) => PurchaseOrderLinePromise;
  updateManyPurchaseOrderLines: (args: {
    data: PurchaseOrderLineUpdateManyMutationInput;
    where?: PurchaseOrderLineWhereInput;
  }) => BatchPayloadPromise;
  upsertPurchaseOrderLine: (args: {
    where: PurchaseOrderLineWhereUniqueInput;
    create: PurchaseOrderLineCreateInput;
    update: PurchaseOrderLineUpdateInput;
  }) => PurchaseOrderLinePromise;
  deletePurchaseOrderLine: (
    where: PurchaseOrderLineWhereUniqueInput
  ) => PurchaseOrderLinePromise;
  deleteManyPurchaseOrderLines: (
    where?: PurchaseOrderLineWhereInput
  ) => BatchPayloadPromise;
  createSalesOrder: (data: SalesOrderCreateInput) => SalesOrderPromise;
  updateSalesOrder: (args: {
    data: SalesOrderUpdateInput;
    where: SalesOrderWhereUniqueInput;
  }) => SalesOrderPromise;
  updateManySalesOrders: (args: {
    data: SalesOrderUpdateManyMutationInput;
    where?: SalesOrderWhereInput;
  }) => BatchPayloadPromise;
  upsertSalesOrder: (args: {
    where: SalesOrderWhereUniqueInput;
    create: SalesOrderCreateInput;
    update: SalesOrderUpdateInput;
  }) => SalesOrderPromise;
  deleteSalesOrder: (where: SalesOrderWhereUniqueInput) => SalesOrderPromise;
  deleteManySalesOrders: (where?: SalesOrderWhereInput) => BatchPayloadPromise;
  createSalesOrderLine: (
    data: SalesOrderLineCreateInput
  ) => SalesOrderLinePromise;
  updateSalesOrderLine: (args: {
    data: SalesOrderLineUpdateInput;
    where: SalesOrderLineWhereUniqueInput;
  }) => SalesOrderLinePromise;
  updateManySalesOrderLines: (args: {
    data: SalesOrderLineUpdateManyMutationInput;
    where?: SalesOrderLineWhereInput;
  }) => BatchPayloadPromise;
  upsertSalesOrderLine: (args: {
    where: SalesOrderLineWhereUniqueInput;
    create: SalesOrderLineCreateInput;
    update: SalesOrderLineUpdateInput;
  }) => SalesOrderLinePromise;
  deleteSalesOrderLine: (
    where: SalesOrderLineWhereUniqueInput
  ) => SalesOrderLinePromise;
  deleteManySalesOrderLines: (
    where?: SalesOrderLineWhereInput
  ) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (args: {
    data: ServiceUpdateInput;
    where: ServiceWhereUniqueInput;
  }) => ServicePromise;
  updateManyServices: (args: {
    data: ServiceUpdateManyMutationInput;
    where?: ServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertService: (args: {
    where: ServiceWhereUniqueInput;
    create: ServiceCreateInput;
    update: ServiceUpdateInput;
  }) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (args: {
    data: SessionUpdateInput;
    where: SessionWhereUniqueInput;
  }) => SessionPromise;
  updateManySessions: (args: {
    data: SessionUpdateManyMutationInput;
    where?: SessionWhereInput;
  }) => BatchPayloadPromise;
  upsertSession: (args: {
    where: SessionWhereUniqueInput;
    create: SessionCreateInput;
    update: SessionUpdateInput;
  }) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSupplier: (data: SupplierCreateInput) => SupplierPromise;
  updateSupplier: (args: {
    data: SupplierUpdateInput;
    where: SupplierWhereUniqueInput;
  }) => SupplierPromise;
  updateManySuppliers: (args: {
    data: SupplierUpdateManyMutationInput;
    where?: SupplierWhereInput;
  }) => BatchPayloadPromise;
  upsertSupplier: (args: {
    where: SupplierWhereUniqueInput;
    create: SupplierCreateInput;
    update: SupplierUpdateInput;
  }) => SupplierPromise;
  deleteSupplier: (where: SupplierWhereUniqueInput) => SupplierPromise;
  deleteManySuppliers: (where?: SupplierWhereInput) => BatchPayloadPromise;
  createTimeSheet: (data: TimeSheetCreateInput) => TimeSheetPromise;
  updateTimeSheet: (args: {
    data: TimeSheetUpdateInput;
    where: TimeSheetWhereUniqueInput;
  }) => TimeSheetPromise;
  updateManyTimeSheets: (args: {
    data: TimeSheetUpdateManyMutationInput;
    where?: TimeSheetWhereInput;
  }) => BatchPayloadPromise;
  upsertTimeSheet: (args: {
    where: TimeSheetWhereUniqueInput;
    create: TimeSheetCreateInput;
    update: TimeSheetUpdateInput;
  }) => TimeSheetPromise;
  deleteTimeSheet: (where: TimeSheetWhereUniqueInput) => TimeSheetPromise;
  deleteManyTimeSheets: (where?: TimeSheetWhereInput) => BatchPayloadPromise;
  createTimeSheetEntry: (
    data: TimeSheetEntryCreateInput
  ) => TimeSheetEntryPromise;
  updateTimeSheetEntry: (args: {
    data: TimeSheetEntryUpdateInput;
    where: TimeSheetEntryWhereUniqueInput;
  }) => TimeSheetEntryPromise;
  updateManyTimeSheetEntries: (args: {
    data: TimeSheetEntryUpdateManyMutationInput;
    where?: TimeSheetEntryWhereInput;
  }) => BatchPayloadPromise;
  upsertTimeSheetEntry: (args: {
    where: TimeSheetEntryWhereUniqueInput;
    create: TimeSheetEntryCreateInput;
    update: TimeSheetEntryUpdateInput;
  }) => TimeSheetEntryPromise;
  deleteTimeSheetEntry: (
    where: TimeSheetEntryWhereUniqueInput
  ) => TimeSheetEntryPromise;
  deleteManyTimeSheetEntries: (
    where?: TimeSheetEntryWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVaccineBrand: (data: VaccineBrandCreateInput) => VaccineBrandPromise;
  updateVaccineBrand: (args: {
    data: VaccineBrandUpdateInput;
    where: VaccineBrandWhereUniqueInput;
  }) => VaccineBrandPromise;
  updateManyVaccineBrands: (args: {
    data: VaccineBrandUpdateManyMutationInput;
    where?: VaccineBrandWhereInput;
  }) => BatchPayloadPromise;
  upsertVaccineBrand: (args: {
    where: VaccineBrandWhereUniqueInput;
    create: VaccineBrandCreateInput;
    update: VaccineBrandUpdateInput;
  }) => VaccineBrandPromise;
  deleteVaccineBrand: (
    where: VaccineBrandWhereUniqueInput
  ) => VaccineBrandPromise;
  deleteManyVaccineBrands: (
    where?: VaccineBrandWhereInput
  ) => BatchPayloadPromise;
  createWareHouse: (data: WareHouseCreateInput) => WareHousePromise;
  updateWareHouse: (args: {
    data: WareHouseUpdateInput;
    where: WareHouseWhereUniqueInput;
  }) => WareHousePromise;
  updateManyWareHouses: (args: {
    data: WareHouseUpdateManyMutationInput;
    where?: WareHouseWhereInput;
  }) => BatchPayloadPromise;
  upsertWareHouse: (args: {
    where: WareHouseWhereUniqueInput;
    create: WareHouseCreateInput;
    update: WareHouseUpdateInput;
  }) => WareHousePromise;
  deleteWareHouse: (where: WareHouseWhereUniqueInput) => WareHousePromise;
  deleteManyWareHouses: (where?: WareHouseWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  apInvoice: (
    where?: ApInvoiceSubscriptionWhereInput
  ) => ApInvoiceSubscriptionPayloadSubscription;
  asset: (
    where?: AssetSubscriptionWhereInput
  ) => AssetSubscriptionPayloadSubscription;
  assetGroup: (
    where?: AssetGroupSubscriptionWhereInput
  ) => AssetGroupSubscriptionPayloadSubscription;
  attachment: (
    where?: AttachmentSubscriptionWhereInput
  ) => AttachmentSubscriptionPayloadSubscription;
  bank: (
    where?: BankSubscriptionWhereInput
  ) => BankSubscriptionPayloadSubscription;
  bankTransaction: (
    where?: BankTransactionSubscriptionWhereInput
  ) => BankTransactionSubscriptionPayloadSubscription;
  basicDailyFee: (
    where?: BasicDailyFeeSubscriptionWhereInput
  ) => BasicDailyFeeSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  companyMember: (
    where?: CompanyMemberSubscriptionWhereInput
  ) => CompanyMemberSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  disease: (
    where?: DiseaseSubscriptionWhereInput
  ) => DiseaseSubscriptionPayloadSubscription;
  hILog: (
    where?: HILogSubscriptionWhereInput
  ) => HILogSubscriptionPayloadSubscription;
  healthcareProvider: (
    where?: HealthcareProviderSubscriptionWhereInput
  ) => HealthcareProviderSubscriptionPayloadSubscription;
  immunisationSchedule: (
    where?: ImmunisationScheduleSubscriptionWhereInput
  ) => ImmunisationScheduleSubscriptionPayloadSubscription;
  integration: (
    where?: IntegrationSubscriptionWhereInput
  ) => IntegrationSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  inventoryOnHand: (
    where?: InventoryOnHandSubscriptionWhereInput
  ) => InventoryOnHandSubscriptionPayloadSubscription;
  invoice: (
    where?: InvoiceSubscriptionWhereInput
  ) => InvoiceSubscriptionPayloadSubscription;
  invoiceItemEntry: (
    where?: InvoiceItemEntrySubscriptionWhereInput
  ) => InvoiceItemEntrySubscriptionPayloadSubscription;
  ledgerJournal: (
    where?: LedgerJournalSubscriptionWhereInput
  ) => LedgerJournalSubscriptionPayloadSubscription;
  ledgerPosting: (
    where?: LedgerPostingSubscriptionWhereInput
  ) => LedgerPostingSubscriptionPayloadSubscription;
  ledgerTransaction: (
    where?: LedgerTransactionSubscriptionWhereInput
  ) => LedgerTransactionSubscriptionPayloadSubscription;
  mainAccount: (
    where?: MainAccountSubscriptionWhereInput
  ) => MainAccountSubscriptionPayloadSubscription;
  meansTestLimits: (
    where?: MeansTestLimitsSubscriptionWhereInput
  ) => MeansTestLimitsSubscriptionPayloadSubscription;
  meansTestedFee: (
    where?: MeansTestedFeeSubscriptionWhereInput
  ) => MeansTestedFeeSubscriptionPayloadSubscription;
  medicareService: (
    where?: MedicareServiceSubscriptionWhereInput
  ) => MedicareServiceSubscriptionPayloadSubscription;
  name: (
    where?: NameSubscriptionWhereInput
  ) => NameSubscriptionPayloadSubscription;
  patient: (
    where?: PatientSubscriptionWhereInput
  ) => PatientSubscriptionPayloadSubscription;
  pbsOrganisation: (
    where?: PbsOrganisationSubscriptionWhereInput
  ) => PbsOrganisationSubscriptionPayloadSubscription;
  pbsTPP: (
    where?: PbsTPPSubscriptionWhereInput
  ) => PbsTPPSubscriptionPayloadSubscription;
  plan: (
    where?: PlanSubscriptionWhereInput
  ) => PlanSubscriptionPayloadSubscription;
  poReceipt: (
    where?: PoReceiptSubscriptionWhereInput
  ) => PoReceiptSubscriptionPayloadSubscription;
  predictedSalesQuantityOfItemsByCompany: (
    where?: PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput
  ) => PredictedSalesQuantityOfItemsByCompanySubscriptionPayloadSubscription;
  predictedSalesValueByCompany: (
    where?: PredictedSalesValueByCompanySubscriptionWhereInput
  ) => PredictedSalesValueByCompanySubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  projectService: (
    where?: ProjectServiceSubscriptionWhereInput
  ) => ProjectServiceSubscriptionPayloadSubscription;
  projectServiceRule: (
    where?: ProjectServiceRuleSubscriptionWhereInput
  ) => ProjectServiceRuleSubscriptionPayloadSubscription;
  purchaseOrder: (
    where?: PurchaseOrderSubscriptionWhereInput
  ) => PurchaseOrderSubscriptionPayloadSubscription;
  purchaseOrderLine: (
    where?: PurchaseOrderLineSubscriptionWhereInput
  ) => PurchaseOrderLineSubscriptionPayloadSubscription;
  salesOrder: (
    where?: SalesOrderSubscriptionWhereInput
  ) => SalesOrderSubscriptionPayloadSubscription;
  salesOrderLine: (
    where?: SalesOrderLineSubscriptionWhereInput
  ) => SalesOrderLineSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  supplier: (
    where?: SupplierSubscriptionWhereInput
  ) => SupplierSubscriptionPayloadSubscription;
  timeSheet: (
    where?: TimeSheetSubscriptionWhereInput
  ) => TimeSheetSubscriptionPayloadSubscription;
  timeSheetEntry: (
    where?: TimeSheetEntrySubscriptionWhereInput
  ) => TimeSheetEntrySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  vaccineBrand: (
    where?: VaccineBrandSubscriptionWhereInput
  ) => VaccineBrandSubscriptionPayloadSubscription;
  wareHouse: (
    where?: WareHouseSubscriptionWhereInput
  ) => WareHouseSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DrCr = "DEBIT" | "CREDIT";

export type BankTransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "transactionDate_ASC"
  | "transactionDate_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "description_ASC"
  | "description_DESC"
  | "posted_ASC"
  | "posted_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LedgerPostingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "postingType_ASC"
  | "postingType_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WareHouseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ApInvoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "invoiceNumber_ASC"
  | "invoiceNumber_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "contactNumber_ASC"
  | "contactNumber_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "isRoot_ASC"
  | "isRoot_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "password_ASC"
  | "password_DESC"
  | "secondAuthEnabled_ASC"
  | "secondAuthEnabled_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostingType =
  | "DRCONTROL"
  | "BANK"
  | "REVENUE"
  | "TAXPAYABLE"
  | "TAXRECEIVABLE";

export type TimeSheetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "endsAt_ASC"
  | "endsAt_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "number_ASC"
  | "number_DESC"
  | "startsAt_ASC"
  | "startsAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LedgerJournalOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "description_ASC"
  | "description_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "includeConsTax_ASC"
  | "includeConsTax_DESC"
  | "posted_ASC"
  | "posted_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "expires_at_ASC"
  | "expires_at_DESC"
  | "is_active_ASC"
  | "is_active_DESC"
  | "is_archived_ASC"
  | "is_archived_DESC"
  | "is_deleted_ASC"
  | "is_deleted_DESC"
  | "signed_at_ASC"
  | "signed_at_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InvoiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "number_ASC"
  | "number_DESC"
  | "description_ASC"
  | "description_DESC"
  | "invoiceDate_ASC"
  | "invoiceDate_DESC"
  | "dueDate_ASC"
  | "dueDate_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "total_ASC"
  | "total_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalesOrderLineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "qty_ASC"
  | "qty_DESC"
  | "price_ASC"
  | "price_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TimeSheetEntryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "isInvoiced_ASC"
  | "isInvoiced_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PurchaseOrderLineOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pbsDrug_ASC"
  | "pbsDrug_DESC"
  | "qty_ASC"
  | "qty_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "unitPrice_ASC"
  | "unitPrice_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectServiceRuleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "percent_ASC"
  | "percent_DESC"
  | "type_ASC"
  | "type_DESC"
  | "isPercent_ASC"
  | "isPercent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ApInvoiceStatus = "OPEN" | "PAID";

export type ProjectServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PredictedSalesValueByCompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "datePredictionRun_ASC"
  | "datePredictionRun_DESC"
  | "predictedSalesValue_ASC"
  | "predictedSalesValue_DESC"
  | "predictedDate_ASC"
  | "predictedDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AssetGroupDepreciationType = "STRAIGHT_LINE" | "REDUCING_BALANCE";

export type PoStatus =
  | "OPEN"
  | "CONFIRMED"
  | "DELIVERED"
  | "PARTIALLY_DELIVERED"
  | "PACKED"
  | "PARTIALLY_PACKED"
  | "INVOICED"
  | "RECEIPTED";

export type InvoiceItemEntryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "tax_ASC"
  | "tax_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SupplierTermsOfPayment = "COD" | "DAYS_14" | "DAYS_30" | "DAYS_60";

export type MainAccountType =
  | "ASSET"
  | "LIABILITY"
  | "EQUITY"
  | "REVENUE"
  | "EXPENSE";

export type BusinessType = "HEALTH" | "OTHER";

export type TimeSheetStatus = "APPROVED" | "DRAFT" | "FINALISED";

export type Currency =
  | "AED"
  | "AFN"
  | "ALL"
  | "AMD"
  | "ANG"
  | "AOA"
  | "ARS"
  | "AUD"
  | "AWG"
  | "AZN"
  | "BAM"
  | "BBD"
  | "BDT"
  | "BGN"
  | "BHD"
  | "BIF"
  | "BMD"
  | "BND"
  | "BOB"
  | "BRL"
  | "BSD"
  | "BTN"
  | "BWP"
  | "BYR"
  | "BZD"
  | "CAD"
  | "CDF"
  | "CHF"
  | "CLP"
  | "CNY"
  | "COP"
  | "CRC"
  | "CUC"
  | "CUP"
  | "CVE"
  | "CZK"
  | "DJF"
  | "DKK"
  | "DOP"
  | "DZD"
  | "EGP"
  | "ERN"
  | "ETB"
  | "EUR"
  | "FJD"
  | "FKP"
  | "GBP"
  | "GEL"
  | "GGP"
  | "GHS"
  | "GIP"
  | "GMD"
  | "GNF"
  | "GTQ"
  | "GYD"
  | "HKD"
  | "HNL"
  | "HRK"
  | "HTG"
  | "HUF"
  | "IDR"
  | "ILS"
  | "IMP"
  | "INR"
  | "IQD"
  | "IRR"
  | "ISK"
  | "JEP"
  | "JMD"
  | "JOD"
  | "JPY"
  | "KES"
  | "KGS"
  | "KHR"
  | "KMF"
  | "KPW"
  | "KRW"
  | "KWD"
  | "KYD"
  | "KZT"
  | "LAK"
  | "LBP"
  | "LKR"
  | "LRD"
  | "LSL"
  | "LYD"
  | "MAD"
  | "MDL"
  | "MGA"
  | "MKD"
  | "MMK"
  | "MNT"
  | "MOP"
  | "MRO"
  | "MUR"
  | "MVR"
  | "MWK"
  | "MXN"
  | "MYR"
  | "MZN"
  | "NAD"
  | "NGN"
  | "NIO"
  | "NOK"
  | "NPR"
  | "NZD"
  | "OMR"
  | "PAB"
  | "PEN"
  | "PGK"
  | "PHP"
  | "PKR"
  | "PLN"
  | "PYG"
  | "QAR"
  | "RON"
  | "RSD"
  | "RUB"
  | "RWF"
  | "SAR"
  | "SBD"
  | "SCR"
  | "SDG"
  | "SEK"
  | "SGD"
  | "SHP"
  | "SLL"
  | "SOS"
  | "SPL"
  | "SRD"
  | "STD"
  | "SVC"
  | "SYP"
  | "SZL"
  | "THB"
  | "TJS"
  | "TMT"
  | "TND"
  | "TOP"
  | "TRY"
  | "TTD"
  | "TVD"
  | "TWD"
  | "TZS"
  | "UAH"
  | "UGX"
  | "USD"
  | "UYU"
  | "UZS"
  | "VEF"
  | "VND"
  | "VUV"
  | "WST"
  | "XAF"
  | "XCD"
  | "XDR"
  | "XOF"
  | "XPF"
  | "YER"
  | "ZAR"
  | "ZMW";

export type ProjectStatus = "CLOSED" | "STARTED";

export type PBSPricingModel =
  | "EX_MANUFACTURER"
  | "AEMP"
  | "PEMP"
  | "PUEMP"
  | "PREMP"
  | "READY_PREPARED"
  | "READY_PREPARED_NO_PREMIUM"
  | "READY_PREPARED_NO_PREMIUM_NO_CHARGE"
  | "INFUSIBLE"
  | "EXTEMPORANEOUS";

export type TimeBasedType = "QUARTERHOUR" | "HALFHOUR" | "HOUR";

export type PbsOrganisationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "title_ASC"
  | "title_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "stateAddress_ASC"
  | "stateAddress_DESC"
  | "postcode_ASC"
  | "postcode_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "effectiveFrom_ASC"
  | "effectiveFrom_DESC"
  | "effectiveTo_ASC"
  | "effectiveTo_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AssetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "dateOfAquisition_ASC"
  | "dateOfAquisition_DESC"
  | "aquisitionPrice_ASC"
  | "aquisitionPrice_DESC"
  | "netBookValue_ASC"
  | "netBookValue_DESC"
  | "depreciation_ASC"
  | "depreciation_DESC"
  | "salvageValue_ASC"
  | "salvageValue_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AboriginalStatus =
  | "ABORIGINAL_NOT_TORRES"
  | "TORRES_NOT_ABORIGINAL"
  | "BOTH"
  | "NEITHER"
  | "NOT_STATED";

export type ServiceBillingType = "FIXED" | "TIME_BASED";

export type NameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "isPrimary_ASC"
  | "isPrimary_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectServiceRuleType = "PROJECT_ENDS" | "PROJECT_STARTS";

export type PlanType = "FREE" | "PRO" | "ENTERPRISE";

export type InvoiceType =
  | "PROJECT"
  | "TIMESHEET"
  | "TIMESHEET_WITH_DETAILS"
  | "FREE_TEXT";

export type CompanyMemberStatus = "ACTIVE" | "PENDING";

export type InvoiceStatus =
  | "APPROVED"
  | "ARCHIVED"
  | "DRAFT"
  | "FULLY_PAID"
  | "PARTIALLY_PAID"
  | "UNPAID"
  | "PROPOSED"
  | "REJECTED";

export type CompanyMemberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "role_ASC"
  | "role_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AssetGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "depreciationType_ASC"
  | "depreciationType_DESC"
  | "usefulLife_ASC"
  | "usefulLife_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MainAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "ConsTaxFree_ASC"
  | "ConsTaxFree_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryOnHandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "pbsDrug_ASC"
  | "pbsDrug_DESC"
  | "onHandQty_ASC"
  | "onHandQty_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "inventoryModel_ASC"
  | "inventoryModel_DESC"
  | "uom_ASC"
  | "uom_DESC"
  | "price_ASC"
  | "price_DESC"
  | "SellingPrice_ASC"
  | "SellingPrice_DESC"
  | "Barcode_ASC"
  | "Barcode_DESC"
  | "Taxable_ASC"
  | "Taxable_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "country_ASC"
  | "country_DESC"
  | "postCode_ASC"
  | "postCode_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UOM = "EA";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "billingType_ASC"
  | "billingType_DESC"
  | "includeConsTax_ASC"
  | "includeConsTax_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "isTemplate_ASC"
  | "isTemplate_DESC"
  | "name_ASC"
  | "name_DESC"
  | "timeBasedType_ASC"
  | "timeBasedType_DESC"
  | "totalAmount_ASC"
  | "totalAmount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryModel = "FIFO" | "LIFO" | "WEIGHTED_AVERAGE";

export type PurchaseOrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pbsOrganisation_ASC"
  | "pbsOrganisation_DESC"
  | "date_ASC"
  | "date_DESC"
  | "status_ASC"
  | "status_DESC"
  | "isPbsPO_ASC"
  | "isPbsPO_DESC"
  | "poNumber_ASC"
  | "poNumber_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AttachmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "fileName_ASC"
  | "fileName_DESC"
  | "label_ASC"
  | "label_DESC"
  | "url_ASC"
  | "url_DESC"
  | "s3Bucket_ASC"
  | "s3Bucket_DESC"
  | "s3Key_ASC"
  | "s3Key_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PredictedSalesQuantityOfItemsByCompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "datePredictionRun_ASC"
  | "datePredictionRun_DESC"
  | "predictedSalesValue_ASC"
  | "predictedSalesValue_DESC"
  | "predictedDate_ASC"
  | "predictedDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IntegrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "data_ASC"
  | "data_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "price_ASC"
  | "price_DESC"
  | "type_ASC"
  | "type_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IntegrationType = "SLACK";

export type PbsTPPOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "snomedCode_ASC"
  | "snomedCode_DESC"
  | "clinicalPreferredTerm_ASC"
  | "clinicalPreferredTerm_DESC"
  | "packSize_ASC"
  | "packSize_DESC"
  | "brandName_ASC"
  | "brandName_DESC"
  | "exManufacturerPrice_ASC"
  | "exManufacturerPrice_DESC"
  | "pricingModel_ASC"
  | "pricingModel_DESC"
  | "mpp_id_ASC"
  | "mpp_id_DESC"
  | "effectiveFrom_ASC"
  | "effectiveFrom_DESC"
  | "effectiveTo_ASC"
  | "effectiveTo_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImmunisationScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ageNumber_ASC"
  | "ageNumber_DESC"
  | "agePeriod_ASC"
  | "agePeriod_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PatientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "dvaCardType_ASC"
  | "dvaCardType_DESC"
  | "aboriginalStatus_ASC"
  | "aboriginalStatus_DESC"
  | "pensionerConcession_ASC"
  | "pensionerConcession_DESC"
  | "commonwealthSeniors_ASC"
  | "commonwealthSeniors_DESC"
  | "healthcareConcession_ASC"
  | "healthcareConcession_DESC"
  | "safetyNetConcession_ASC"
  | "safetyNetConcession_DESC"
  | "medicareNumber_ASC"
  | "medicareNumber_DESC"
  | "DVA_ASC"
  | "DVA_DESC"
  | "potentialDuplicate_ASC"
  | "potentialDuplicate_DESC"
  | "oneName_ASC"
  | "oneName_DESC"
  | "ihi_ASC"
  | "ihi_DESC"
  | "ihiValidatedDate_ASC"
  | "ihiValidatedDate_DESC"
  | "noOfBirths_ASC"
  | "noOfBirths_DESC"
  | "deceasedDate_ASC"
  | "deceasedDate_DESC"
  | "levelOfCare_ASC"
  | "levelOfCare_DESC"
  | "dateEnteredAgedCare_ASC"
  | "dateEnteredAgedCare_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PeriodUnit = "WEEKS" | "MONTHS" | "YEARS";

export type MedicareServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "MBSScheduleFee_ASC"
  | "MBSScheduleFee_DESC"
  | "description_ASC"
  | "description_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HealthcareProviderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "occupation_ASC"
  | "occupation_DESC"
  | "hpii_ASC"
  | "hpii_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "emailAddress_ASC"
  | "emailAddress_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "ahpraNumber_ASC"
  | "ahpraNumber_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MeansTestedFeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "dateFrom_ASC"
  | "dateFrom_DESC"
  | "dateTo_ASC"
  | "dateTo_DESC";

export type Gender = "MALE" | "FEMALE" | "INTERSEX" | "UNSPECIFIED";

export type LedgerTransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "drcr_ASC"
  | "drcr_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "date_ASC"
  | "date_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BankOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "institution_ASC"
  | "institution_DESC"
  | "bsb_ASC"
  | "bsb_DESC"
  | "accountNumber_ASC"
  | "accountNumber_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SupplierOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "termsOfPayment_ASC"
  | "termsOfPayment_DESC"
  | "bankAccount_ASC"
  | "bankAccount_DESC"
  | "emailAddressForRemittance_ASC"
  | "emailAddressForRemittance_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HILogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hpio_ASC"
  | "hpio_DESC"
  | "hpii_ASC"
  | "hpii_DESC"
  | "ihi_ASC"
  | "ihi_DESC"
  | "timeWaitedForSalus_ASC"
  | "timeWaitedForSalus_DESC"
  | "csp_ASC"
  | "csp_DESC"
  | "hiWebServiceUsed_ASC"
  | "hiWebServiceUsed_DESC"
  | "hiWebServiceVersion_ASC"
  | "hiWebServiceVersion_DESC"
  | "hiNumberStatus_ASC"
  | "hiNumberStatus_DESC"
  | "recordStatus_ASC"
  | "recordStatus_DESC"
  | "salusResponse_ASC"
  | "salusResponse_DESC"
  | "failureMessage_ASC"
  | "failureMessage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "endsAt_ASC"
  | "endsAt_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startsAt_ASC"
  | "startsAt_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalusResponse = "SUCCESS" | "FAIL";

export type Country =
  | "AD"
  | "AE"
  | "AF"
  | "AG"
  | "AI"
  | "AL"
  | "AM"
  | "AO"
  | "AR"
  | "AS"
  | "AT"
  | "AU"
  | "AW"
  | "AX"
  | "AZ"
  | "BA"
  | "BB"
  | "BD"
  | "BE"
  | "BF"
  | "BG"
  | "BH"
  | "BI"
  | "BJ"
  | "BL"
  | "BM"
  | "BN"
  | "BO"
  | "BQ"
  | "BR"
  | "BS"
  | "BT"
  | "BV"
  | "BW"
  | "BY"
  | "BZ"
  | "CA"
  | "CC"
  | "CD"
  | "CF"
  | "CG"
  | "CH"
  | "CI"
  | "CK"
  | "CL"
  | "CM"
  | "CN"
  | "CO"
  | "CR"
  | "CU"
  | "CV"
  | "CW"
  | "CX"
  | "CY"
  | "CZ"
  | "DE"
  | "DJ"
  | "DK"
  | "DM"
  | "DO"
  | "DZ"
  | "EA"
  | "EC"
  | "EE"
  | "EG"
  | "EH"
  | "ER"
  | "ES"
  | "ET"
  | "FI"
  | "FJ"
  | "FK"
  | "FM"
  | "FO"
  | "FR"
  | "GA"
  | "GB"
  | "GD"
  | "GE"
  | "GF"
  | "GG"
  | "GH"
  | "GI"
  | "GL"
  | "GM"
  | "GN"
  | "GP"
  | "GQ"
  | "GR"
  | "GS"
  | "GT"
  | "GU"
  | "GW"
  | "GY"
  | "HK"
  | "HM"
  | "HN"
  | "HR"
  | "HT"
  | "HU"
  | "IC"
  | "ID"
  | "IE"
  | "IL"
  | "IM"
  | "IN"
  | "IO"
  | "IQ"
  | "IR"
  | "IS"
  | "IT"
  | "JE"
  | "JM"
  | "JO"
  | "JP"
  | "KE"
  | "KG"
  | "KH"
  | "KI"
  | "KM"
  | "KN"
  | "KP"
  | "KR"
  | "KW"
  | "KY"
  | "KZ"
  | "LA"
  | "LB"
  | "LC"
  | "LI"
  | "LK"
  | "LR"
  | "LS"
  | "LT"
  | "LU"
  | "LV"
  | "LY"
  | "MA"
  | "MC"
  | "MD"
  | "ME"
  | "MF"
  | "MG"
  | "MH"
  | "MK"
  | "ML"
  | "MM"
  | "MN"
  | "MO"
  | "MP"
  | "MQ"
  | "MR"
  | "MS"
  | "MT"
  | "MU"
  | "MV"
  | "MW"
  | "MX"
  | "MY"
  | "MZ"
  | "NA"
  | "NC"
  | "NE"
  | "NF"
  | "NG"
  | "NI"
  | "NL"
  | "NO"
  | "NP"
  | "NR"
  | "NU"
  | "NZ"
  | "OM"
  | "PA"
  | "PE"
  | "PF"
  | "PG"
  | "PH"
  | "PK"
  | "PL"
  | "PM"
  | "PN"
  | "PR"
  | "PS"
  | "PT"
  | "PW"
  | "PY"
  | "QA"
  | "RE"
  | "RO"
  | "RS"
  | "RU"
  | "RW"
  | "SA"
  | "SB"
  | "SC"
  | "SD"
  | "SE"
  | "SG"
  | "SH"
  | "SI"
  | "SJ"
  | "SK"
  | "SL"
  | "SM"
  | "SN"
  | "SO"
  | "SR"
  | "SS"
  | "ST"
  | "SV"
  | "SX"
  | "SY"
  | "SZ"
  | "TC"
  | "TD"
  | "TF"
  | "TG"
  | "TH"
  | "TJ"
  | "TK"
  | "TL"
  | "TM"
  | "TN"
  | "TO"
  | "TR"
  | "TT"
  | "TV"
  | "TW"
  | "TZ"
  | "UA"
  | "UG"
  | "UM"
  | "US"
  | "UY"
  | "UZ"
  | "VA"
  | "VC"
  | "VE"
  | "VG"
  | "VI"
  | "VN"
  | "VU"
  | "WF"
  | "WS"
  | "XK"
  | "YE"
  | "YT"
  | "ZA"
  | "ZM"
  | "ZW";

export type HINumberStatus = "ACTIVE" | "RETIRED" | "RESOLVED" | "DEACTIVATED";

export type DVACardType = "GOLD" | "WHITE" | "ORANGE";

export type DiseaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MeansTestLimitsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "annual_ASC"
  | "annual_DESC"
  | "lifetime_ASC"
  | "lifetime_DESC"
  | "dateFrom_ASC"
  | "dateFrom_DESC"
  | "dateTo_ASC"
  | "dateTo_DESC";

export type LevelOfCare = "Level1" | "Level2" | "Level3" | "Level4";

export type BasicDailyFeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "level_ASC"
  | "level_DESC"
  | "rate_ASC"
  | "rate_DESC"
  | "dateFrom_ASC"
  | "dateFrom_DESC"
  | "dateTo_ASC"
  | "dateTo_DESC"
  | "rechargeable_ASC"
  | "rechargeable_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bankAccount_ASC"
  | "bankAccount_DESC"
  | "businessType_ASC"
  | "businessType_DESC"
  | "country_ASC"
  | "country_DESC"
  | "govNumber_ASC"
  | "govNumber_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "HPIO_ASC"
  | "HPIO_DESC"
  | "legalName_ASC"
  | "legalName_DESC"
  | "name_ASC"
  | "name_DESC"
  | "salesTax_ASC"
  | "salesTax_DESC"
  | "timeSheetSettings_ASC"
  | "timeSheetSettings_DESC"
  | "websiteURL_ASC"
  | "websiteURL_DESC"
  | "stripeCustomerId_ASC"
  | "stripeCustomerId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "govNumber_ASC"
  | "govNumber_DESC"
  | "salesTax_ASC"
  | "salesTax_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "name_ASC"
  | "name_DESC"
  | "billingFrequency_ASC"
  | "billingFrequency_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VaccineBrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type CompanyMemberRole = "ADMIN" | "OWNER" | "USER";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "surname_ASC"
  | "surname_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobileCode_ASC"
  | "mobileCode_DESC"
  | "mobileNumber_ASC"
  | "mobileNumber_DESC"
  | "landlineCode_ASC"
  | "landlineCode_DESC"
  | "landlineNumber_ASC"
  | "landlineNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PoReceiptOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "receiptNumber_ASC"
  | "receiptNumber_DESC"
  | "receiptDate_ASC"
  | "receiptDate_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalesOrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "transactionDate_ASC"
  | "transactionDate_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDeleted_ASC"
  | "isDeleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PurchaseOrderUpsertNestedInput {
  update: PurchaseOrderUpdateDataInput;
  create: PurchaseOrderCreateInput;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LedgerPostingUpdateManyMutationInput {
  postingType?: Maybe<PostingType>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectServiceRuleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  percent?: Maybe<Float>;
  percent_not?: Maybe<Float>;
  percent_in?: Maybe<Float[] | Float>;
  percent_not_in?: Maybe<Float[] | Float>;
  percent_lt?: Maybe<Float>;
  percent_lte?: Maybe<Float>;
  percent_gt?: Maybe<Float>;
  percent_gte?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  type_not?: Maybe<ProjectServiceRuleType>;
  type_in?: Maybe<ProjectServiceRuleType[] | ProjectServiceRuleType>;
  type_not_in?: Maybe<ProjectServiceRuleType[] | ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
  isPercent_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ProjectServiceRuleScalarWhereInput[] | ProjectServiceRuleScalarWhereInput
  >;
  OR?: Maybe<
    ProjectServiceRuleScalarWhereInput[] | ProjectServiceRuleScalarWhereInput
  >;
  NOT?: Maybe<
    ProjectServiceRuleScalarWhereInput[] | ProjectServiceRuleScalarWhereInput
  >;
}

export interface LedgerPostingUpdateInput {
  postingType?: Maybe<PostingType>;
  mainAccount?: Maybe<MainAccountUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface CompanyUpsertWithoutCompanyMembersInput {
  update: CompanyUpdateWithoutCompanyMembersDataInput;
  create: CompanyCreateWithoutCompanyMembersInput;
}

export interface LedgerPostingCreateInput {
  id?: Maybe<ID_Input>;
  postingType?: Maybe<PostingType>;
  mainAccount?: Maybe<MainAccountCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type BasicDailyFeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LedgerJournalUpdateManyMutationInput {
  total?: Maybe<Float>;
  description?: Maybe<String>;
  currency?: Maybe<Currency>;
  includeConsTax?: Maybe<Boolean>;
  posted?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface LedgerJournalWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  includeConsTax?: Maybe<Boolean>;
  includeConsTax_not?: Maybe<Boolean>;
  posted?: Maybe<Boolean>;
  posted_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LedgerJournalWhereInput[] | LedgerJournalWhereInput>;
  OR?: Maybe<LedgerJournalWhereInput[] | LedgerJournalWhereInput>;
  NOT?: Maybe<LedgerJournalWhereInput[] | LedgerJournalWhereInput>;
}

export type SalesOrderLineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BankTransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  transactionDate?: Maybe<DateTimeInput>;
  transactionDate_not?: Maybe<DateTimeInput>;
  transactionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  transactionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  transactionDate_lt?: Maybe<DateTimeInput>;
  transactionDate_lte?: Maybe<DateTimeInput>;
  transactionDate_gt?: Maybe<DateTimeInput>;
  transactionDate_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  posted?: Maybe<Boolean>;
  posted_not?: Maybe<Boolean>;
  ledgerJournal?: Maybe<LedgerJournalWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BankTransactionWhereInput[] | BankTransactionWhereInput>;
  OR?: Maybe<BankTransactionWhereInput[] | BankTransactionWhereInput>;
  NOT?: Maybe<BankTransactionWhereInput[] | BankTransactionWhereInput>;
}

export interface LedgerJournalUpdateInput {
  total?: Maybe<Float>;
  description?: Maybe<String>;
  currency?: Maybe<Currency>;
  includeConsTax?: Maybe<Boolean>;
  posted?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface TimeSheetEntrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TimeSheetEntryWhereInput>;
  AND?: Maybe<
    | TimeSheetEntrySubscriptionWhereInput[]
    | TimeSheetEntrySubscriptionWhereInput
  >;
  OR?: Maybe<
    | TimeSheetEntrySubscriptionWhereInput[]
    | TimeSheetEntrySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | TimeSheetEntrySubscriptionWhereInput[]
    | TimeSheetEntrySubscriptionWhereInput
  >;
}

export interface SalesOrderLineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  salesOrder?: Maybe<SalesOrderWhereInput>;
  inventory?: Maybe<InventoryWhereInput>;
  qty?: Maybe<Int>;
  qty_not?: Maybe<Int>;
  qty_in?: Maybe<Int[] | Int>;
  qty_not_in?: Maybe<Int[] | Int>;
  qty_lt?: Maybe<Int>;
  qty_lte?: Maybe<Int>;
  qty_gt?: Maybe<Int>;
  qty_gte?: Maybe<Int>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SalesOrderLineWhereInput[] | SalesOrderLineWhereInput>;
  OR?: Maybe<SalesOrderLineWhereInput[] | SalesOrderLineWhereInput>;
  NOT?: Maybe<SalesOrderLineWhereInput[] | SalesOrderLineWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InvoiceItemEntryUpdateManyMutationInput {
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SessionWhereInput>;
  AND?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  OR?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
  NOT?: Maybe<SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput>;
}

export interface InvoiceUpsertWithoutItemsInput {
  update: InvoiceUpdateWithoutItemsDataInput;
  create: InvoiceCreateWithoutItemsInput;
}

export interface SalesOrderLineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SalesOrderLineWhereInput>;
  AND?: Maybe<
    | SalesOrderLineSubscriptionWhereInput[]
    | SalesOrderLineSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SalesOrderLineSubscriptionWhereInput[]
    | SalesOrderLineSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SalesOrderLineSubscriptionWhereInput[]
    | SalesOrderLineSubscriptionWhereInput
  >;
}

export interface InvoiceUpdateWithoutItemsDataInput {
  title?: Maybe<String>;
  attachments?: Maybe<AttachmentUpdateManyInput>;
  buyer?: Maybe<CustomerUpdateOneInput>;
  number?: Maybe<Int>;
  description?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  seller?: Maybe<CompanyUpdateOneRequiredInput>;
  status?: Maybe<InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  total?: Maybe<Float>;
}

export interface SalesOrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SalesOrderWhereInput>;
  AND?: Maybe<
    SalesOrderSubscriptionWhereInput[] | SalesOrderSubscriptionWhereInput
  >;
  OR?: Maybe<
    SalesOrderSubscriptionWhereInput[] | SalesOrderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SalesOrderSubscriptionWhereInput[] | SalesOrderSubscriptionWhereInput
  >;
}

export interface InvoiceUpdateOneWithoutItemsInput {
  create?: Maybe<InvoiceCreateWithoutItemsInput>;
  update?: Maybe<InvoiceUpdateWithoutItemsDataInput>;
  upsert?: Maybe<InvoiceUpsertWithoutItemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface PurchaseOrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PurchaseOrderWhereInput>;
  AND?: Maybe<
    PurchaseOrderSubscriptionWhereInput[] | PurchaseOrderSubscriptionWhereInput
  >;
  OR?: Maybe<
    PurchaseOrderSubscriptionWhereInput[] | PurchaseOrderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PurchaseOrderSubscriptionWhereInput[] | PurchaseOrderSubscriptionWhereInput
  >;
}

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceRuleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectServiceRuleWhereInput>;
  AND?: Maybe<
    | ProjectServiceRuleSubscriptionWhereInput[]
    | ProjectServiceRuleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProjectServiceRuleSubscriptionWhereInput[]
    | ProjectServiceRuleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProjectServiceRuleSubscriptionWhereInput[]
    | ProjectServiceRuleSubscriptionWhereInput
  >;
}

export interface InvoiceItemEntryUpdateInput {
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
  invoice?: Maybe<InvoiceUpdateOneWithoutItemsInput>;
  project?: Maybe<ProjectUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneInput>;
  timeSheetEntry?: Maybe<TimeSheetEntryUpdateOneInput>;
  timeSheet?: Maybe<TimeSheetUpdateOneInput>;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface InvoiceCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  attachments?: Maybe<AttachmentCreateManyInput>;
  buyer?: Maybe<CustomerCreateOneInput>;
  number?: Maybe<Int>;
  description?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  preview?: Maybe<AttachmentCreateOneInput>;
  seller: CompanyCreateOneInput;
  status?: Maybe<InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  total?: Maybe<Float>;
}

export interface PredictedSalesValueByCompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PredictedSalesValueByCompanyWhereInput>;
  AND?: Maybe<
    | PredictedSalesValueByCompanySubscriptionWhereInput[]
    | PredictedSalesValueByCompanySubscriptionWhereInput
  >;
  OR?: Maybe<
    | PredictedSalesValueByCompanySubscriptionWhereInput[]
    | PredictedSalesValueByCompanySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PredictedSalesValueByCompanySubscriptionWhereInput[]
    | PredictedSalesValueByCompanySubscriptionWhereInput
  >;
}

export interface InvoiceCreateOneWithoutItemsInput {
  create?: Maybe<InvoiceCreateWithoutItemsInput>;
  connect?: Maybe<InvoiceWhereUniqueInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  govNumber?: Maybe<String>;
  govNumber_not?: Maybe<String>;
  govNumber_in?: Maybe<String[] | String>;
  govNumber_not_in?: Maybe<String[] | String>;
  govNumber_lt?: Maybe<String>;
  govNumber_lte?: Maybe<String>;
  govNumber_gt?: Maybe<String>;
  govNumber_gte?: Maybe<String>;
  govNumber_contains?: Maybe<String>;
  govNumber_not_contains?: Maybe<String>;
  govNumber_starts_with?: Maybe<String>;
  govNumber_not_starts_with?: Maybe<String>;
  govNumber_ends_with?: Maybe<String>;
  govNumber_not_ends_with?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  salesTax_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  billingFrequency?: Maybe<SupplierTermsOfPayment>;
  billingFrequency_not?: Maybe<SupplierTermsOfPayment>;
  billingFrequency_in?: Maybe<
    SupplierTermsOfPayment[] | SupplierTermsOfPayment
  >;
  billingFrequency_not_in?: Maybe<
    SupplierTermsOfPayment[] | SupplierTermsOfPayment
  >;
  meansTestedFee?: Maybe<MeansTestedFeeWhereInput>;
  basicDailyFee?: Maybe<BasicDailyFeeWhereInput>;
  contacts_every?: Maybe<ContactWhereInput>;
  contacts_some?: Maybe<ContactWhereInput>;
  contacts_none?: Maybe<ContactWhereInput>;
  addresses_every?: Maybe<AddressWhereInput>;
  addresses_some?: Maybe<AddressWhereInput>;
  addresses_none?: Maybe<AddressWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface InvoiceItemEntryCreateInput {
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
  invoice?: Maybe<InvoiceCreateOneWithoutItemsInput>;
  project?: Maybe<ProjectCreateOneInput>;
  service?: Maybe<ServiceCreateOneInput>;
  timeSheetEntry?: Maybe<TimeSheetEntryCreateOneInput>;
  timeSheet?: Maybe<TimeSheetCreateOneInput>;
}

export interface PoReceiptSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PoReceiptWhereInput>;
  AND?: Maybe<
    PoReceiptSubscriptionWhereInput[] | PoReceiptSubscriptionWhereInput
  >;
  OR?: Maybe<
    PoReceiptSubscriptionWhereInput[] | PoReceiptSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PoReceiptSubscriptionWhereInput[] | PoReceiptSubscriptionWhereInput
  >;
}

export type SessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PbsTPPSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PbsTPPWhereInput>;
  AND?: Maybe<PbsTPPSubscriptionWhereInput[] | PbsTPPSubscriptionWhereInput>;
  OR?: Maybe<PbsTPPSubscriptionWhereInput[] | PbsTPPSubscriptionWhereInput>;
  NOT?: Maybe<PbsTPPSubscriptionWhereInput[] | PbsTPPSubscriptionWhereInput>;
}

export interface InvoiceUpdateManyMutationInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  description?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  status?: Maybe<InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  total?: Maybe<Float>;
}

export type DiseaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  expires_at?: Maybe<DateTimeInput>;
  expires_at_not?: Maybe<DateTimeInput>;
  expires_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expires_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expires_at_lt?: Maybe<DateTimeInput>;
  expires_at_lte?: Maybe<DateTimeInput>;
  expires_at_gt?: Maybe<DateTimeInput>;
  expires_at_gte?: Maybe<DateTimeInput>;
  is_active?: Maybe<Boolean>;
  is_active_not?: Maybe<Boolean>;
  is_archived?: Maybe<Boolean>;
  is_archived_not?: Maybe<Boolean>;
  is_deleted?: Maybe<Boolean>;
  is_deleted_not?: Maybe<Boolean>;
  signed_at?: Maybe<DateTimeInput>;
  signed_at_not?: Maybe<DateTimeInput>;
  signed_at_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  signed_at_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  signed_at_lt?: Maybe<DateTimeInput>;
  signed_at_lte?: Maybe<DateTimeInput>;
  signed_at_gt?: Maybe<DateTimeInput>;
  signed_at_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  OR?: Maybe<SessionWhereInput[] | SessionWhereInput>;
  NOT?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface DiseaseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
  OR?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
  NOT?: Maybe<DiseaseWhereInput[] | DiseaseWhereInput>;
}

export interface InvoiceItemEntryUpdateManyDataInput {
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
}

export interface NameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NameWhereInput>;
  AND?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
  OR?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
  NOT?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
}

export interface InvoiceItemEntryUpdateManyWithWhereNestedInput {
  where: InvoiceItemEntryScalarWhereInput;
  data: InvoiceItemEntryUpdateManyDataInput;
}

export interface MeansTestedFeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeansTestedFeeWhereInput>;
  AND?: Maybe<
    | MeansTestedFeeSubscriptionWhereInput[]
    | MeansTestedFeeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeansTestedFeeSubscriptionWhereInput[]
    | MeansTestedFeeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeansTestedFeeSubscriptionWhereInput[]
    | MeansTestedFeeSubscriptionWhereInput
  >;
}

export interface InvoiceItemEntryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  quantity?: Maybe<Float>;
  quantity_not?: Maybe<Float>;
  quantity_in?: Maybe<Float[] | Float>;
  quantity_not_in?: Maybe<Float[] | Float>;
  quantity_lt?: Maybe<Float>;
  quantity_lte?: Maybe<Float>;
  quantity_gt?: Maybe<Float>;
  quantity_gte?: Maybe<Float>;
  tax?: Maybe<Float>;
  tax_not?: Maybe<Float>;
  tax_in?: Maybe<Float[] | Float>;
  tax_not_in?: Maybe<Float[] | Float>;
  tax_lt?: Maybe<Float>;
  tax_lte?: Maybe<Float>;
  tax_gt?: Maybe<Float>;
  tax_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    InvoiceItemEntryScalarWhereInput[] | InvoiceItemEntryScalarWhereInput
  >;
  OR?: Maybe<
    InvoiceItemEntryScalarWhereInput[] | InvoiceItemEntryScalarWhereInput
  >;
  NOT?: Maybe<
    InvoiceItemEntryScalarWhereInput[] | InvoiceItemEntryScalarWhereInput
  >;
}

export interface MeansTestLimitsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeansTestLimitsWhereInput>;
  AND?: Maybe<
    | MeansTestLimitsSubscriptionWhereInput[]
    | MeansTestLimitsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MeansTestLimitsSubscriptionWhereInput[]
    | MeansTestLimitsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MeansTestLimitsSubscriptionWhereInput[]
    | MeansTestLimitsSubscriptionWhereInput
  >;
}

export interface InvoiceItemEntryUpsertWithWhereUniqueWithoutInvoiceInput {
  where: InvoiceItemEntryWhereUniqueInput;
  update: InvoiceItemEntryUpdateWithoutInvoiceDataInput;
  create: InvoiceItemEntryCreateWithoutInvoiceInput;
}

export interface LedgerTransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LedgerTransactionWhereInput>;
  AND?: Maybe<
    | LedgerTransactionSubscriptionWhereInput[]
    | LedgerTransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | LedgerTransactionSubscriptionWhereInput[]
    | LedgerTransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | LedgerTransactionSubscriptionWhereInput[]
    | LedgerTransactionSubscriptionWhereInput
  >;
}

export type SupplierWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LedgerPostingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LedgerPostingWhereInput>;
  AND?: Maybe<
    LedgerPostingSubscriptionWhereInput[] | LedgerPostingSubscriptionWhereInput
  >;
  OR?: Maybe<
    LedgerPostingSubscriptionWhereInput[] | LedgerPostingSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LedgerPostingSubscriptionWhereInput[] | LedgerPostingSubscriptionWhereInput
  >;
}

export interface TimeSheetUpsertNestedInput {
  update: TimeSheetUpdateDataInput;
  create: TimeSheetCreateInput;
}

export interface InvoiceItemEntrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvoiceItemEntryWhereInput>;
  AND?: Maybe<
    | InvoiceItemEntrySubscriptionWhereInput[]
    | InvoiceItemEntrySubscriptionWhereInput
  >;
  OR?: Maybe<
    | InvoiceItemEntrySubscriptionWhereInput[]
    | InvoiceItemEntrySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InvoiceItemEntrySubscriptionWhereInput[]
    | InvoiceItemEntrySubscriptionWhereInput
  >;
}

export interface TimeSheetEntryUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
}

export type HealthcareProviderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetEntryUpdateManyWithWhereNestedInput {
  where: TimeSheetEntryScalarWhereInput;
  data: TimeSheetEntryUpdateManyDataInput;
}

export interface BankWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  institution?: Maybe<String>;
  institution_not?: Maybe<String>;
  institution_in?: Maybe<String[] | String>;
  institution_not_in?: Maybe<String[] | String>;
  institution_lt?: Maybe<String>;
  institution_lte?: Maybe<String>;
  institution_gt?: Maybe<String>;
  institution_gte?: Maybe<String>;
  institution_contains?: Maybe<String>;
  institution_not_contains?: Maybe<String>;
  institution_starts_with?: Maybe<String>;
  institution_not_starts_with?: Maybe<String>;
  institution_ends_with?: Maybe<String>;
  institution_not_ends_with?: Maybe<String>;
  bsb?: Maybe<String>;
  bsb_not?: Maybe<String>;
  bsb_in?: Maybe<String[] | String>;
  bsb_not_in?: Maybe<String[] | String>;
  bsb_lt?: Maybe<String>;
  bsb_lte?: Maybe<String>;
  bsb_gt?: Maybe<String>;
  bsb_gte?: Maybe<String>;
  bsb_contains?: Maybe<String>;
  bsb_not_contains?: Maybe<String>;
  bsb_starts_with?: Maybe<String>;
  bsb_not_starts_with?: Maybe<String>;
  bsb_ends_with?: Maybe<String>;
  bsb_not_ends_with?: Maybe<String>;
  accountNumber?: Maybe<String>;
  accountNumber_not?: Maybe<String>;
  accountNumber_in?: Maybe<String[] | String>;
  accountNumber_not_in?: Maybe<String[] | String>;
  accountNumber_lt?: Maybe<String>;
  accountNumber_lte?: Maybe<String>;
  accountNumber_gt?: Maybe<String>;
  accountNumber_gte?: Maybe<String>;
  accountNumber_contains?: Maybe<String>;
  accountNumber_not_contains?: Maybe<String>;
  accountNumber_starts_with?: Maybe<String>;
  accountNumber_not_starts_with?: Maybe<String>;
  accountNumber_ends_with?: Maybe<String>;
  accountNumber_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BankWhereInput[] | BankWhereInput>;
  OR?: Maybe<BankWhereInput[] | BankWhereInput>;
  NOT?: Maybe<BankWhereInput[] | BankWhereInput>;
}

export interface TimeSheetEntryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  isInvoiced_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    TimeSheetEntryScalarWhereInput[] | TimeSheetEntryScalarWhereInput
  >;
  OR?: Maybe<TimeSheetEntryScalarWhereInput[] | TimeSheetEntryScalarWhereInput>;
  NOT?: Maybe<
    TimeSheetEntryScalarWhereInput[] | TimeSheetEntryScalarWhereInput
  >;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryWhereInput>;
  AND?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  OR?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput
  >;
}

export type TimeSheetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImmunisationScheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImmunisationScheduleWhereInput>;
  AND?: Maybe<
    | ImmunisationScheduleSubscriptionWhereInput[]
    | ImmunisationScheduleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ImmunisationScheduleSubscriptionWhereInput[]
    | ImmunisationScheduleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ImmunisationScheduleSubscriptionWhereInput[]
    | ImmunisationScheduleSubscriptionWhereInput
  >;
}

export interface TimeSheetEntryUpsertWithWhereUniqueWithoutTimeSheetInput {
  where: TimeSheetEntryWhereUniqueInput;
  update: TimeSheetEntryUpdateWithoutTimeSheetDataInput;
  create: TimeSheetEntryCreateWithoutTimeSheetInput;
}

export type ImmunisationScheduleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetEntryUpdateWithoutTimeSheetDataInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  project?: Maybe<ProjectUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneInput>;
}

export type BankWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetEntryUpdateWithWhereUniqueWithoutTimeSheetInput {
  where: TimeSheetEntryWhereUniqueInput;
  data: TimeSheetEntryUpdateWithoutTimeSheetDataInput;
}

export interface ImmunisationScheduleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  ageNumber?: Maybe<Int>;
  ageNumber_not?: Maybe<Int>;
  ageNumber_in?: Maybe<Int[] | Int>;
  ageNumber_not_in?: Maybe<Int[] | Int>;
  ageNumber_lt?: Maybe<Int>;
  ageNumber_lte?: Maybe<Int>;
  ageNumber_gt?: Maybe<Int>;
  ageNumber_gte?: Maybe<Int>;
  agePeriod?: Maybe<PeriodUnit>;
  agePeriod_not?: Maybe<PeriodUnit>;
  agePeriod_in?: Maybe<PeriodUnit[] | PeriodUnit>;
  agePeriod_not_in?: Maybe<PeriodUnit[] | PeriodUnit>;
  disease?: Maybe<DiseaseWhereInput>;
  vaccineBrand?: Maybe<VaccineBrandWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ImmunisationScheduleWhereInput[] | ImmunisationScheduleWhereInput
  >;
  OR?: Maybe<ImmunisationScheduleWhereInput[] | ImmunisationScheduleWhereInput>;
  NOT?: Maybe<
    ImmunisationScheduleWhereInput[] | ImmunisationScheduleWhereInput
  >;
}

export interface TimeSheetEntryUpdateManyWithoutTimeSheetInput {
  create?: Maybe<
    | TimeSheetEntryCreateWithoutTimeSheetInput[]
    | TimeSheetEntryCreateWithoutTimeSheetInput
  >;
  delete?: Maybe<
    TimeSheetEntryWhereUniqueInput[] | TimeSheetEntryWhereUniqueInput
  >;
  connect?: Maybe<
    TimeSheetEntryWhereUniqueInput[] | TimeSheetEntryWhereUniqueInput
  >;
  set?: Maybe<
    TimeSheetEntryWhereUniqueInput[] | TimeSheetEntryWhereUniqueInput
  >;
  disconnect?: Maybe<
    TimeSheetEntryWhereUniqueInput[] | TimeSheetEntryWhereUniqueInput
  >;
  update?: Maybe<
    | TimeSheetEntryUpdateWithWhereUniqueWithoutTimeSheetInput[]
    | TimeSheetEntryUpdateWithWhereUniqueWithoutTimeSheetInput
  >;
  upsert?: Maybe<
    | TimeSheetEntryUpsertWithWhereUniqueWithoutTimeSheetInput[]
    | TimeSheetEntryUpsertWithWhereUniqueWithoutTimeSheetInput
  >;
  deleteMany?: Maybe<
    TimeSheetEntryScalarWhereInput[] | TimeSheetEntryScalarWhereInput
  >;
  updateMany?: Maybe<
    | TimeSheetEntryUpdateManyWithWhereNestedInput[]
    | TimeSheetEntryUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export type TimeSheetEntryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyMemberSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyMemberWhereInput>;
  AND?: Maybe<
    CompanyMemberSubscriptionWhereInput[] | CompanyMemberSubscriptionWhereInput
  >;
  OR?: Maybe<
    CompanyMemberSubscriptionWhereInput[] | CompanyMemberSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CompanyMemberSubscriptionWhereInput[] | CompanyMemberSubscriptionWhereInput
  >;
}

export interface TimeSheetUpdateDataInput {
  attachments?: Maybe<AttachmentUpdateManyInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  timeSheetEntries?: Maybe<TimeSheetEntryUpdateManyWithoutTimeSheetInput>;
  user?: Maybe<UserUpdateOneInput>;
}

export type IntegrationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetUpdateOneInput {
  create?: Maybe<TimeSheetCreateInput>;
  update?: Maybe<TimeSheetUpdateDataInput>;
  upsert?: Maybe<TimeSheetUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TimeSheetWhereUniqueInput>;
}

export interface BankTransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BankTransactionWhereInput>;
  AND?: Maybe<
    | BankTransactionSubscriptionWhereInput[]
    | BankTransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | BankTransactionSubscriptionWhereInput[]
    | BankTransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | BankTransactionSubscriptionWhereInput[]
    | BankTransactionSubscriptionWhereInput
  >;
}

export interface TimeSheetEntryUpsertNestedInput {
  update: TimeSheetEntryUpdateDataInput;
  create: TimeSheetEntryCreateInput;
}

export interface BankSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BankWhereInput>;
  AND?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
  OR?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
  NOT?: Maybe<BankSubscriptionWhereInput[] | BankSubscriptionWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AssetGroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AssetGroupWhereInput>;
  AND?: Maybe<
    AssetGroupSubscriptionWhereInput[] | AssetGroupSubscriptionWhereInput
  >;
  OR?: Maybe<
    AssetGroupSubscriptionWhereInput[] | AssetGroupSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AssetGroupSubscriptionWhereInput[] | AssetGroupSubscriptionWhereInput
  >;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  postCode?: Maybe<String>;
  postCode_not?: Maybe<String>;
  postCode_in?: Maybe<String[] | String>;
  postCode_not_in?: Maybe<String[] | String>;
  postCode_lt?: Maybe<String>;
  postCode_lte?: Maybe<String>;
  postCode_gt?: Maybe<String>;
  postCode_gte?: Maybe<String>;
  postCode_contains?: Maybe<String>;
  postCode_not_contains?: Maybe<String>;
  postCode_starts_with?: Maybe<String>;
  postCode_not_starts_with?: Maybe<String>;
  postCode_ends_with?: Maybe<String>;
  postCode_not_ends_with?: Maybe<String>;
  latitude?: Maybe<String>;
  latitude_not?: Maybe<String>;
  latitude_in?: Maybe<String[] | String>;
  latitude_not_in?: Maybe<String[] | String>;
  latitude_lt?: Maybe<String>;
  latitude_lte?: Maybe<String>;
  latitude_gt?: Maybe<String>;
  latitude_gte?: Maybe<String>;
  latitude_contains?: Maybe<String>;
  latitude_not_contains?: Maybe<String>;
  latitude_starts_with?: Maybe<String>;
  latitude_not_starts_with?: Maybe<String>;
  latitude_ends_with?: Maybe<String>;
  latitude_not_ends_with?: Maybe<String>;
  longitude?: Maybe<String>;
  longitude_not?: Maybe<String>;
  longitude_in?: Maybe<String[] | String>;
  longitude_not_in?: Maybe<String[] | String>;
  longitude_lt?: Maybe<String>;
  longitude_lte?: Maybe<String>;
  longitude_gt?: Maybe<String>;
  longitude_gte?: Maybe<String>;
  longitude_contains?: Maybe<String>;
  longitude_not_contains?: Maybe<String>;
  longitude_starts_with?: Maybe<String>;
  longitude_not_starts_with?: Maybe<String>;
  longitude_ends_with?: Maybe<String>;
  longitude_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetUpsertWithoutTimeSheetEntriesInput {
  update: TimeSheetUpdateWithoutTimeSheetEntriesDataInput;
  create: TimeSheetCreateWithoutTimeSheetEntriesInput;
}

export type AttachmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TimeSheetUpdateWithoutTimeSheetEntriesDataInput {
  attachments?: Maybe<AttachmentUpdateManyInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface InventoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  inventoryModel?: Maybe<InventoryModel>;
  inventoryModel_not?: Maybe<InventoryModel>;
  inventoryModel_in?: Maybe<InventoryModel[] | InventoryModel>;
  inventoryModel_not_in?: Maybe<InventoryModel[] | InventoryModel>;
  uom?: Maybe<UOM>;
  uom_not?: Maybe<UOM>;
  uom_in?: Maybe<UOM[] | UOM>;
  uom_not_in?: Maybe<UOM[] | UOM>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  SellingPrice?: Maybe<Float>;
  SellingPrice_not?: Maybe<Float>;
  SellingPrice_in?: Maybe<Float[] | Float>;
  SellingPrice_not_in?: Maybe<Float[] | Float>;
  SellingPrice_lt?: Maybe<Float>;
  SellingPrice_lte?: Maybe<Float>;
  SellingPrice_gt?: Maybe<Float>;
  SellingPrice_gte?: Maybe<Float>;
  Barcode?: Maybe<String>;
  Barcode_not?: Maybe<String>;
  Barcode_in?: Maybe<String[] | String>;
  Barcode_not_in?: Maybe<String[] | String>;
  Barcode_lt?: Maybe<String>;
  Barcode_lte?: Maybe<String>;
  Barcode_gt?: Maybe<String>;
  Barcode_gte?: Maybe<String>;
  Barcode_contains?: Maybe<String>;
  Barcode_not_contains?: Maybe<String>;
  Barcode_starts_with?: Maybe<String>;
  Barcode_not_starts_with?: Maybe<String>;
  Barcode_ends_with?: Maybe<String>;
  Barcode_not_ends_with?: Maybe<String>;
  Taxable?: Maybe<Boolean>;
  Taxable_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  OR?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
  NOT?: Maybe<InventoryWhereInput[] | InventoryWhereInput>;
}

export interface TimeSheetUpdateOneWithoutTimeSheetEntriesInput {
  create?: Maybe<TimeSheetCreateWithoutTimeSheetEntriesInput>;
  update?: Maybe<TimeSheetUpdateWithoutTimeSheetEntriesDataInput>;
  upsert?: Maybe<TimeSheetUpsertWithoutTimeSheetEntriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TimeSheetWhereUniqueInput>;
}

export interface WareHouseUpdateInput {
  name?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type VaccineBrandWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VaccineBrandUpdateInput {
  name?: Maybe<String>;
}

export interface TimeSheetEntryUpdateDataInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  project?: Maybe<ProjectUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneInput>;
  timeSheet?: Maybe<TimeSheetUpdateOneWithoutTimeSheetEntriesInput>;
}

export interface UserUpdateManyMutationInput {
  contactNumber?: Maybe<Json>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isRoot?: Maybe<Boolean>;
  jobTitle?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  secondAuthEnabled?: Maybe<Boolean>;
}

export interface TimeSheetEntryUpdateOneInput {
  create?: Maybe<TimeSheetEntryCreateInput>;
  update?: Maybe<TimeSheetEntryUpdateDataInput>;
  upsert?: Maybe<TimeSheetEntryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TimeSheetEntryWhereUniqueInput>;
}

export interface InventoryOnHandWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  item?: Maybe<InventoryWhereInput>;
  pbsDrug?: Maybe<String>;
  pbsDrug_not?: Maybe<String>;
  pbsDrug_in?: Maybe<String[] | String>;
  pbsDrug_not_in?: Maybe<String[] | String>;
  pbsDrug_lt?: Maybe<String>;
  pbsDrug_lte?: Maybe<String>;
  pbsDrug_gt?: Maybe<String>;
  pbsDrug_gte?: Maybe<String>;
  pbsDrug_contains?: Maybe<String>;
  pbsDrug_not_contains?: Maybe<String>;
  pbsDrug_starts_with?: Maybe<String>;
  pbsDrug_not_starts_with?: Maybe<String>;
  pbsDrug_ends_with?: Maybe<String>;
  pbsDrug_not_ends_with?: Maybe<String>;
  onHandQty?: Maybe<Int>;
  onHandQty_not?: Maybe<Int>;
  onHandQty_in?: Maybe<Int[] | Int>;
  onHandQty_not_in?: Maybe<Int[] | Int>;
  onHandQty_lt?: Maybe<Int>;
  onHandQty_lte?: Maybe<Int>;
  onHandQty_gt?: Maybe<Int>;
  onHandQty_gte?: Maybe<Int>;
  purchaseOrder?: Maybe<PurchaseOrderWhereInput>;
  warehouse?: Maybe<WareHouseWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InventoryOnHandWhereInput[] | InventoryOnHandWhereInput>;
  OR?: Maybe<InventoryOnHandWhereInput[] | InventoryOnHandWhereInput>;
  NOT?: Maybe<InventoryOnHandWhereInput[] | InventoryOnHandWhereInput>;
}

export interface ProjectUpsertNestedInput {
  update: ProjectUpdateDataInput;
  create: ProjectCreateInput;
}

export interface TimeSheetEntryUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
}

export interface ProjectServiceUpdateManyDataInput {
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface TimeSheetUpdateManyMutationInput {
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
}

export type WareHouseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type InvoiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceUpdateManyWithWhereNestedInput {
  where: ProjectServiceScalarWhereInput;
  data: ProjectServiceUpdateManyDataInput;
}

export interface InvoiceItemEntryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  quantity?: Maybe<Float>;
  quantity_not?: Maybe<Float>;
  quantity_in?: Maybe<Float[] | Float>;
  quantity_not_in?: Maybe<Float[] | Float>;
  quantity_lt?: Maybe<Float>;
  quantity_lte?: Maybe<Float>;
  quantity_gt?: Maybe<Float>;
  quantity_gte?: Maybe<Float>;
  tax?: Maybe<Float>;
  tax_not?: Maybe<Float>;
  tax_in?: Maybe<Float[] | Float>;
  tax_not_in?: Maybe<Float[] | Float>;
  tax_lt?: Maybe<Float>;
  tax_lte?: Maybe<Float>;
  tax_gt?: Maybe<Float>;
  tax_gte?: Maybe<Float>;
  invoice?: Maybe<InvoiceWhereInput>;
  project?: Maybe<ProjectWhereInput>;
  service?: Maybe<ServiceWhereInput>;
  timeSheetEntry?: Maybe<TimeSheetEntryWhereInput>;
  timeSheet?: Maybe<TimeSheetWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InvoiceItemEntryWhereInput[] | InvoiceItemEntryWhereInput>;
  OR?: Maybe<InvoiceItemEntryWhereInput[] | InvoiceItemEntryWhereInput>;
  NOT?: Maybe<InvoiceItemEntryWhereInput[] | InvoiceItemEntryWhereInput>;
}

export interface ProjectServiceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ProjectServiceScalarWhereInput[] | ProjectServiceScalarWhereInput
  >;
  OR?: Maybe<ProjectServiceScalarWhereInput[] | ProjectServiceScalarWhereInput>;
  NOT?: Maybe<
    ProjectServiceScalarWhereInput[] | ProjectServiceScalarWhereInput
  >;
}

export type AssetGroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceUpsertWithWhereUniqueWithoutProjectInput {
  where: ProjectServiceWhereUniqueInput;
  update: ProjectServiceUpdateWithoutProjectDataInput;
  create: ProjectServiceCreateWithoutProjectInput;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  customer?: Maybe<CustomerWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  endsAt_not?: Maybe<DateTimeInput>;
  endsAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endsAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endsAt_lt?: Maybe<DateTimeInput>;
  endsAt_lte?: Maybe<DateTimeInput>;
  endsAt_gt?: Maybe<DateTimeInput>;
  endsAt_gte?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  projectService_every?: Maybe<ProjectServiceWhereInput>;
  projectService_some?: Maybe<ProjectServiceWhereInput>;
  projectService_none?: Maybe<ProjectServiceWhereInput>;
  startsAt?: Maybe<DateTimeInput>;
  startsAt_not?: Maybe<DateTimeInput>;
  startsAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startsAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startsAt_lt?: Maybe<DateTimeInput>;
  startsAt_lte?: Maybe<DateTimeInput>;
  startsAt_gt?: Maybe<DateTimeInput>;
  startsAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
  status_not?: Maybe<ProjectStatus>;
  status_in?: Maybe<ProjectStatus[] | ProjectStatus>;
  status_not_in?: Maybe<ProjectStatus[] | ProjectStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface ServiceUpsertNestedInput {
  update: ServiceUpdateDataInput;
  create: ServiceCreateInput;
}

export interface ProjectServiceRuleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  projectService?: Maybe<ProjectServiceWhereInput>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  percent?: Maybe<Float>;
  percent_not?: Maybe<Float>;
  percent_in?: Maybe<Float[] | Float>;
  percent_not_in?: Maybe<Float[] | Float>;
  percent_lt?: Maybe<Float>;
  percent_lte?: Maybe<Float>;
  percent_gt?: Maybe<Float>;
  percent_gte?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  type_not?: Maybe<ProjectServiceRuleType>;
  type_in?: Maybe<ProjectServiceRuleType[] | ProjectServiceRuleType>;
  type_not_in?: Maybe<ProjectServiceRuleType[] | ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
  isPercent_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectServiceRuleWhereInput[] | ProjectServiceRuleWhereInput>;
  OR?: Maybe<ProjectServiceRuleWhereInput[] | ProjectServiceRuleWhereInput>;
  NOT?: Maybe<ProjectServiceRuleWhereInput[] | ProjectServiceRuleWhereInput>;
}

export interface ServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  billingType?: Maybe<ServiceBillingType>;
  billingType_not?: Maybe<ServiceBillingType>;
  billingType_in?: Maybe<ServiceBillingType[] | ServiceBillingType>;
  billingType_not_in?: Maybe<ServiceBillingType[] | ServiceBillingType>;
  company?: Maybe<CompanyWhereInput>;
  includeConsTax?: Maybe<Boolean>;
  includeConsTax_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  isTemplate?: Maybe<Boolean>;
  isTemplate_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  timeBasedType?: Maybe<TimeBasedType>;
  timeBasedType_not?: Maybe<TimeBasedType>;
  timeBasedType_in?: Maybe<TimeBasedType[] | TimeBasedType>;
  timeBasedType_not_in?: Maybe<TimeBasedType[] | TimeBasedType>;
  totalAmount?: Maybe<Float>;
  totalAmount_not?: Maybe<Float>;
  totalAmount_in?: Maybe<Float[] | Float>;
  totalAmount_not_in?: Maybe<Float[] | Float>;
  totalAmount_lt?: Maybe<Float>;
  totalAmount_lte?: Maybe<Float>;
  totalAmount_gt?: Maybe<Float>;
  totalAmount_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  OR?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  NOT?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
}

export interface MainAccountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<MainAccountType>;
  type_not?: Maybe<MainAccountType>;
  type_in?: Maybe<MainAccountType[] | MainAccountType>;
  type_not_in?: Maybe<MainAccountType[] | MainAccountType>;
  ConsTaxFree?: Maybe<Boolean>;
  ConsTaxFree_not?: Maybe<Boolean>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MainAccountWhereInput[] | MainAccountWhereInput>;
  OR?: Maybe<MainAccountWhereInput[] | MainAccountWhereInput>;
  NOT?: Maybe<MainAccountWhereInput[] | MainAccountWhereInput>;
}

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postCode?: Maybe<String>;
  latitude?: Maybe<String>;
  longitude?: Maybe<String>;
}

export interface TimeSheetEntryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  isInvoiced_not?: Maybe<Boolean>;
  project?: Maybe<ProjectWhereInput>;
  service?: Maybe<ServiceWhereInput>;
  timeSheet?: Maybe<TimeSheetWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TimeSheetEntryWhereInput[] | TimeSheetEntryWhereInput>;
  OR?: Maybe<TimeSheetEntryWhereInput[] | TimeSheetEntryWhereInput>;
  NOT?: Maybe<TimeSheetEntryWhereInput[] | TimeSheetEntryWhereInput>;
}

export interface AddressUpdateInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postCode?: Maybe<String>;
  latitude?: Maybe<String>;
  longitude?: Maybe<String>;
}

export interface AssetWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  assetGroup?: Maybe<AssetGroupWhereInput>;
  dateOfAquisition?: Maybe<DateTimeInput>;
  dateOfAquisition_not?: Maybe<DateTimeInput>;
  dateOfAquisition_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfAquisition_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfAquisition_lt?: Maybe<DateTimeInput>;
  dateOfAquisition_lte?: Maybe<DateTimeInput>;
  dateOfAquisition_gt?: Maybe<DateTimeInput>;
  dateOfAquisition_gte?: Maybe<DateTimeInput>;
  aquisitionPrice?: Maybe<Float>;
  aquisitionPrice_not?: Maybe<Float>;
  aquisitionPrice_in?: Maybe<Float[] | Float>;
  aquisitionPrice_not_in?: Maybe<Float[] | Float>;
  aquisitionPrice_lt?: Maybe<Float>;
  aquisitionPrice_lte?: Maybe<Float>;
  aquisitionPrice_gt?: Maybe<Float>;
  aquisitionPrice_gte?: Maybe<Float>;
  netBookValue?: Maybe<Float>;
  netBookValue_not?: Maybe<Float>;
  netBookValue_in?: Maybe<Float[] | Float>;
  netBookValue_not_in?: Maybe<Float[] | Float>;
  netBookValue_lt?: Maybe<Float>;
  netBookValue_lte?: Maybe<Float>;
  netBookValue_gt?: Maybe<Float>;
  netBookValue_gte?: Maybe<Float>;
  depreciation?: Maybe<Float>;
  depreciation_not?: Maybe<Float>;
  depreciation_in?: Maybe<Float[] | Float>;
  depreciation_not_in?: Maybe<Float[] | Float>;
  depreciation_lt?: Maybe<Float>;
  depreciation_lte?: Maybe<Float>;
  depreciation_gt?: Maybe<Float>;
  depreciation_gte?: Maybe<Float>;
  salvageValue?: Maybe<Float>;
  salvageValue_not?: Maybe<Float>;
  salvageValue_in?: Maybe<Float[] | Float>;
  salvageValue_not_in?: Maybe<Float[] | Float>;
  salvageValue_lt?: Maybe<Float>;
  salvageValue_lte?: Maybe<Float>;
  salvageValue_gt?: Maybe<Float>;
  salvageValue_gte?: Maybe<Float>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AssetWhereInput[] | AssetWhereInput>;
  OR?: Maybe<AssetWhereInput[] | AssetWhereInput>;
  NOT?: Maybe<AssetWhereInput[] | AssetWhereInput>;
}

export interface AddressUpdateManyMutationInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postCode?: Maybe<String>;
  latitude?: Maybe<String>;
  longitude?: Maybe<String>;
}

export interface ServiceUpdateManyMutationInput {
  billingType?: Maybe<ServiceBillingType>;
  includeConsTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isTemplate?: Maybe<Boolean>;
  name?: Maybe<String>;
  timeBasedType?: Maybe<TimeBasedType>;
  totalAmount?: Maybe<Float>;
}

export interface ServiceUpdateDataInput {
  billingType?: Maybe<ServiceBillingType>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  includeConsTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isTemplate?: Maybe<Boolean>;
  name?: Maybe<String>;
  timeBasedType?: Maybe<TimeBasedType>;
  totalAmount?: Maybe<Float>;
}

export interface SalesOrderLineUpdateManyMutationInput {
  qty?: Maybe<Int>;
  price?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ServiceUpdateOneInput {
  create?: Maybe<ServiceCreateInput>;
  update?: Maybe<ServiceUpdateDataInput>;
  upsert?: Maybe<ServiceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface SalesOrderUpdateDataInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  transactionDate?: Maybe<DateTimeInput>;
  currency?: Maybe<Currency>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ApInvoiceCreateInput {
  id?: Maybe<ID_Input>;
  status?: Maybe<ApInvoiceStatus>;
  invoiceNumber?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface SalesOrderLineUpdateInput {
  salesOrder?: Maybe<SalesOrderUpdateOneInput>;
  inventory?: Maybe<InventoryUpdateOneInput>;
  qty?: Maybe<Int>;
  price?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PurchaseOrderCreateOneInput {
  create?: Maybe<PurchaseOrderCreateInput>;
  connect?: Maybe<PurchaseOrderWhereUniqueInput>;
}

export interface SalesOrderLineCreateInput {
  id?: Maybe<ID_Input>;
  salesOrder?: Maybe<SalesOrderCreateOneInput>;
  inventory?: Maybe<InventoryCreateOneInput>;
  qty?: Maybe<Int>;
  price?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PurchaseOrderCreateInput {
  id?: Maybe<ID_Input>;
  pbsOrganisation?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  orderer?: Maybe<UserCreateOneInput>;
  status?: Maybe<PoStatus>;
  supplier?: Maybe<SupplierCreateOneInput>;
  isPbsPO?: Maybe<Boolean>;
  poNumber: Int;
  preview?: Maybe<AttachmentCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface SalesOrderUpdateManyMutationInput {
  transactionDate?: Maybe<DateTimeInput>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SalesOrderCreateInput {
  id?: Maybe<ID_Input>;
  customer?: Maybe<CustomerCreateOneInput>;
  transactionDate?: Maybe<DateTimeInput>;
  currency?: Maybe<Currency>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  contactNumber?: Maybe<Json>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isRoot?: Maybe<Boolean>;
  jobTitle?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  secondAuthEnabled?: Maybe<Boolean>;
}

export type InvoiceItemEntryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SupplierCreateOneInput {
  create?: Maybe<SupplierCreateInput>;
  connect?: Maybe<SupplierWhereUniqueInput>;
}

export interface PoReceiptUpdateDataInput {
  receiptNumber?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderUpdateOneInput>;
  receiptDate?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface SupplierCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  address?: Maybe<AddressCreateManyInput>;
  termsOfPayment?: Maybe<SupplierTermsOfPayment>;
  bankAccount?: Maybe<Json>;
  emailAddressForRemittance?: Maybe<String>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type LedgerJournalWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressCreateManyInput {
  create?: Maybe<AddressCreateInput[] | AddressCreateInput>;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
}

export interface PoReceiptCreateOneInput {
  create?: Maybe<PoReceiptCreateInput>;
  connect?: Maybe<PoReceiptWhereUniqueInput>;
}

export interface CompanyCreateOneInput {
  create?: Maybe<CompanyCreateInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface PurchaseOrderUpdateManyMutationInput {
  pbsOrganisation?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  status?: Maybe<PoStatus>;
  isPbsPO?: Maybe<Boolean>;
  poNumber?: Maybe<Int>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency: Currency;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName: String;
  logo?: Maybe<AttachmentCreateOneInput>;
  name: String;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyInput>;
  contacts?: Maybe<ContactCreateManyInput>;
  companyMembers?: Maybe<CompanyMemberCreateManyWithoutCompanyInput>;
  activePlan?: Maybe<PlanCreateOneWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface PurchaseOrderUpdateInput {
  pbsOrganisation?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  orderer?: Maybe<UserUpdateOneInput>;
  status?: Maybe<PoStatus>;
  supplier?: Maybe<SupplierUpdateOneInput>;
  isPbsPO?: Maybe<Boolean>;
  poNumber?: Maybe<Int>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AttachmentCreateOneInput {
  create?: Maybe<AttachmentCreateInput>;
  connect?: Maybe<AttachmentWhereUniqueInput>;
}

export interface LedgerPostingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  postingType?: Maybe<PostingType>;
  postingType_not?: Maybe<PostingType>;
  postingType_in?: Maybe<PostingType[] | PostingType>;
  postingType_not_in?: Maybe<PostingType[] | PostingType>;
  mainAccount?: Maybe<MainAccountWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LedgerPostingWhereInput[] | LedgerPostingWhereInput>;
  OR?: Maybe<LedgerPostingWhereInput[] | LedgerPostingWhereInput>;
  NOT?: Maybe<LedgerPostingWhereInput[] | LedgerPostingWhereInput>;
}

export interface AttachmentCreateInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  fileName?: Maybe<String>;
  label?: Maybe<String>;
  url?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Key?: Maybe<String>;
}

export interface ProjectServiceUpsertWithoutRulesInput {
  update: ProjectServiceUpdateWithoutRulesDataInput;
  create: ProjectServiceCreateWithoutRulesInput;
}

export interface ContactCreateManyInput {
  create?: Maybe<ContactCreateInput[] | ContactCreateInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
}

export interface ProjectServiceUpdateOneWithoutRulesInput {
  create?: Maybe<ProjectServiceCreateWithoutRulesInput>;
  update?: Maybe<ProjectServiceUpdateWithoutRulesDataInput>;
  upsert?: Maybe<ProjectServiceUpsertWithoutRulesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectServiceWhereUniqueInput>;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  surname?: Maybe<String>;
  email?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineNumber?: Maybe<String>;
}

export interface ProjectServiceRuleUpdateInput {
  projectService?: Maybe<ProjectServiceUpdateOneWithoutRulesInput>;
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export interface CompanyMemberCreateManyWithoutCompanyInput {
  create?: Maybe<
    | CompanyMemberCreateWithoutCompanyInput[]
    | CompanyMemberCreateWithoutCompanyInput
  >;
  connect?: Maybe<
    CompanyMemberWhereUniqueInput[] | CompanyMemberWhereUniqueInput
  >;
}

export interface LedgerTransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  mainAccount?: Maybe<MainAccountWhereInput>;
  ledgerJournal?: Maybe<LedgerJournalWhereInput>;
  drcr?: Maybe<DrCr>;
  drcr_not?: Maybe<DrCr>;
  drcr_in?: Maybe<DrCr[] | DrCr>;
  drcr_not_in?: Maybe<DrCr[] | DrCr>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<LedgerTransactionWhereInput[] | LedgerTransactionWhereInput>;
  OR?: Maybe<LedgerTransactionWhereInput[] | LedgerTransactionWhereInput>;
  NOT?: Maybe<LedgerTransactionWhereInput[] | LedgerTransactionWhereInput>;
}

export interface CompanyMemberCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  user?: Maybe<UserCreateOneInput>;
}

export interface ProjectServiceCreateWithoutRulesInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  project?: Maybe<ProjectCreateOneWithoutProjectServiceInput>;
  service?: Maybe<ServiceCreateOneInput>;
}

export interface PlanCreateOneWithoutCompanyInput {
  create?: Maybe<PlanCreateWithoutCompanyInput>;
  connect?: Maybe<PlanWhereUniqueInput>;
}

export interface ProjectServiceRuleCreateInput {
  id?: Maybe<ID_Input>;
  projectService?: Maybe<ProjectServiceCreateOneWithoutRulesInput>;
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export interface PlanCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  price?: Maybe<Float>;
  type?: Maybe<PlanType>;
  currency: Currency;
}

export interface ProjectServiceUpdateManyMutationInput {
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ApInvoiceUpdateInput {
  status?: Maybe<ApInvoiceStatus>;
  invoiceNumber?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectUpdateWithoutProjectServiceDataInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneInput>;
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export interface PurchaseOrderUpdateOneInput {
  create?: Maybe<PurchaseOrderCreateInput>;
  update?: Maybe<PurchaseOrderUpdateDataInput>;
  upsert?: Maybe<PurchaseOrderUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PurchaseOrderWhereUniqueInput>;
}

export type MeansTestLimitsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PurchaseOrderUpdateDataInput {
  pbsOrganisation?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  orderer?: Maybe<UserUpdateOneInput>;
  status?: Maybe<PoStatus>;
  supplier?: Maybe<SupplierUpdateOneInput>;
  isPbsPO?: Maybe<Boolean>;
  poNumber?: Maybe<Int>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MeansTestLimitsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  annual?: Maybe<Float>;
  annual_not?: Maybe<Float>;
  annual_in?: Maybe<Float[] | Float>;
  annual_not_in?: Maybe<Float[] | Float>;
  annual_lt?: Maybe<Float>;
  annual_lte?: Maybe<Float>;
  annual_gt?: Maybe<Float>;
  annual_gte?: Maybe<Float>;
  lifetime?: Maybe<Float>;
  lifetime_not?: Maybe<Float>;
  lifetime_in?: Maybe<Float[] | Float>;
  lifetime_not_in?: Maybe<Float[] | Float>;
  lifetime_lt?: Maybe<Float>;
  lifetime_lte?: Maybe<Float>;
  lifetime_gt?: Maybe<Float>;
  lifetime_gte?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateFrom_not?: Maybe<DateTimeInput>;
  dateFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_lt?: Maybe<DateTimeInput>;
  dateFrom_lte?: Maybe<DateTimeInput>;
  dateFrom_gt?: Maybe<DateTimeInput>;
  dateFrom_gte?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  dateTo_not?: Maybe<DateTimeInput>;
  dateTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_lt?: Maybe<DateTimeInput>;
  dateTo_lte?: Maybe<DateTimeInput>;
  dateTo_gt?: Maybe<DateTimeInput>;
  dateTo_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MeansTestLimitsWhereInput[] | MeansTestLimitsWhereInput>;
  OR?: Maybe<MeansTestLimitsWhereInput[] | MeansTestLimitsWhereInput>;
  NOT?: Maybe<MeansTestLimitsWhereInput[] | MeansTestLimitsWhereInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProjectCreateOneWithoutProjectServiceInput {
  create?: Maybe<ProjectCreateWithoutProjectServiceInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  contactNumber?: Maybe<Json>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isRoot?: Maybe<Boolean>;
  jobTitle?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  secondAuthEnabled?: Maybe<Boolean>;
}

export interface ProjectUpdateManyMutationInput {
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  isRoot?: Maybe<Boolean>;
  isRoot_not?: Maybe<Boolean>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  secondAuthEnabled?: Maybe<Boolean>;
  secondAuthEnabled_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface SupplierUpdateOneInput {
  create?: Maybe<SupplierCreateInput>;
  update?: Maybe<SupplierUpdateDataInput>;
  upsert?: Maybe<SupplierUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SupplierWhereUniqueInput>;
}

export interface PredictedSalesValueByCompanyUpdateManyMutationInput {
  datePredictionRun?: Maybe<DateTimeInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface SupplierUpdateDataInput {
  name?: Maybe<String>;
  address?: Maybe<AddressUpdateManyInput>;
  termsOfPayment?: Maybe<SupplierTermsOfPayment>;
  bankAccount?: Maybe<Json>;
  emailAddressForRemittance?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type MedicareServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressUpdateManyInput {
  create?: Maybe<AddressCreateInput[] | AddressCreateInput>;
  update?: Maybe<
    | AddressUpdateWithWhereUniqueNestedInput[]
    | AddressUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AddressUpsertWithWhereUniqueNestedInput[]
    | AddressUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  connect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  set?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  disconnect?: Maybe<AddressWhereUniqueInput[] | AddressWhereUniqueInput>;
  deleteMany?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  updateMany?: Maybe<
    | AddressUpdateManyWithWhereNestedInput[]
    | AddressUpdateManyWithWhereNestedInput
  >;
}

export interface MedicareServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  MBSScheduleFee?: Maybe<Float>;
  MBSScheduleFee_not?: Maybe<Float>;
  MBSScheduleFee_in?: Maybe<Float[] | Float>;
  MBSScheduleFee_not_in?: Maybe<Float[] | Float>;
  MBSScheduleFee_lt?: Maybe<Float>;
  MBSScheduleFee_lte?: Maybe<Float>;
  MBSScheduleFee_gt?: Maybe<Float>;
  MBSScheduleFee_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MedicareServiceWhereInput[] | MedicareServiceWhereInput>;
  OR?: Maybe<MedicareServiceWhereInput[] | MedicareServiceWhereInput>;
  NOT?: Maybe<MedicareServiceWhereInput[] | MedicareServiceWhereInput>;
}

export interface AddressUpdateWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput;
  data: AddressUpdateDataInput;
}

export interface PredictedSalesQuantityOfItemsByCompanyUpdateInput {
  datePredictionRun?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  inventory?: Maybe<InventoryUpdateOneInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface AddressUpdateDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postCode?: Maybe<String>;
  latitude?: Maybe<String>;
  longitude?: Maybe<String>;
}

export interface PoReceiptUpdateManyMutationInput {
  receiptNumber?: Maybe<String>;
  receiptDate?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AddressUpsertWithWhereUniqueNestedInput {
  where: AddressWhereUniqueInput;
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface PoReceiptUpdateInput {
  receiptNumber?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderUpdateOneInput>;
  receiptDate?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AddressScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  postCode?: Maybe<String>;
  postCode_not?: Maybe<String>;
  postCode_in?: Maybe<String[] | String>;
  postCode_not_in?: Maybe<String[] | String>;
  postCode_lt?: Maybe<String>;
  postCode_lte?: Maybe<String>;
  postCode_gt?: Maybe<String>;
  postCode_gte?: Maybe<String>;
  postCode_contains?: Maybe<String>;
  postCode_not_contains?: Maybe<String>;
  postCode_starts_with?: Maybe<String>;
  postCode_not_starts_with?: Maybe<String>;
  postCode_ends_with?: Maybe<String>;
  postCode_not_ends_with?: Maybe<String>;
  latitude?: Maybe<String>;
  latitude_not?: Maybe<String>;
  latitude_in?: Maybe<String[] | String>;
  latitude_not_in?: Maybe<String[] | String>;
  latitude_lt?: Maybe<String>;
  latitude_lte?: Maybe<String>;
  latitude_gt?: Maybe<String>;
  latitude_gte?: Maybe<String>;
  latitude_contains?: Maybe<String>;
  latitude_not_contains?: Maybe<String>;
  latitude_starts_with?: Maybe<String>;
  latitude_not_starts_with?: Maybe<String>;
  latitude_ends_with?: Maybe<String>;
  latitude_not_ends_with?: Maybe<String>;
  longitude?: Maybe<String>;
  longitude_not?: Maybe<String>;
  longitude_in?: Maybe<String[] | String>;
  longitude_not_in?: Maybe<String[] | String>;
  longitude_lt?: Maybe<String>;
  longitude_lte?: Maybe<String>;
  longitude_gt?: Maybe<String>;
  longitude_gte?: Maybe<String>;
  longitude_contains?: Maybe<String>;
  longitude_not_contains?: Maybe<String>;
  longitude_starts_with?: Maybe<String>;
  longitude_not_starts_with?: Maybe<String>;
  longitude_ends_with?: Maybe<String>;
  longitude_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  OR?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
  NOT?: Maybe<AddressScalarWhereInput[] | AddressScalarWhereInput>;
}

export interface PlanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  type?: Maybe<PlanType>;
  type_not?: Maybe<PlanType>;
  type_in?: Maybe<PlanType[] | PlanType>;
  type_not_in?: Maybe<PlanType[] | PlanType>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlanWhereInput[] | PlanWhereInput>;
  OR?: Maybe<PlanWhereInput[] | PlanWhereInput>;
  NOT?: Maybe<PlanWhereInput[] | PlanWhereInput>;
}

export interface AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput;
  data: AddressUpdateManyDataInput;
}

export interface PlanUpdateManyMutationInput {
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  price?: Maybe<Float>;
  type?: Maybe<PlanType>;
  currency?: Maybe<Currency>;
}

export interface AddressUpdateManyDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postCode?: Maybe<String>;
  latitude?: Maybe<String>;
  longitude?: Maybe<String>;
}

export type PatientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyUpdateOneRequiredInput {
  create?: Maybe<CompanyCreateInput>;
  update?: Maybe<CompanyUpdateDataInput>;
  upsert?: Maybe<CompanyUpsertNestedInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface AttachmentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  fileName?: Maybe<String>;
  fileName_not?: Maybe<String>;
  fileName_in?: Maybe<String[] | String>;
  fileName_not_in?: Maybe<String[] | String>;
  fileName_lt?: Maybe<String>;
  fileName_lte?: Maybe<String>;
  fileName_gt?: Maybe<String>;
  fileName_gte?: Maybe<String>;
  fileName_contains?: Maybe<String>;
  fileName_not_contains?: Maybe<String>;
  fileName_starts_with?: Maybe<String>;
  fileName_not_starts_with?: Maybe<String>;
  fileName_ends_with?: Maybe<String>;
  fileName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Bucket_not?: Maybe<String>;
  s3Bucket_in?: Maybe<String[] | String>;
  s3Bucket_not_in?: Maybe<String[] | String>;
  s3Bucket_lt?: Maybe<String>;
  s3Bucket_lte?: Maybe<String>;
  s3Bucket_gt?: Maybe<String>;
  s3Bucket_gte?: Maybe<String>;
  s3Bucket_contains?: Maybe<String>;
  s3Bucket_not_contains?: Maybe<String>;
  s3Bucket_starts_with?: Maybe<String>;
  s3Bucket_not_starts_with?: Maybe<String>;
  s3Bucket_ends_with?: Maybe<String>;
  s3Bucket_not_ends_with?: Maybe<String>;
  s3Key?: Maybe<String>;
  s3Key_not?: Maybe<String>;
  s3Key_in?: Maybe<String[] | String>;
  s3Key_not_in?: Maybe<String[] | String>;
  s3Key_lt?: Maybe<String>;
  s3Key_lte?: Maybe<String>;
  s3Key_gt?: Maybe<String>;
  s3Key_gte?: Maybe<String>;
  s3Key_contains?: Maybe<String>;
  s3Key_not_contains?: Maybe<String>;
  s3Key_starts_with?: Maybe<String>;
  s3Key_not_starts_with?: Maybe<String>;
  s3Key_ends_with?: Maybe<String>;
  s3Key_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AttachmentWhereInput[] | AttachmentWhereInput>;
  OR?: Maybe<AttachmentWhereInput[] | AttachmentWhereInput>;
  NOT?: Maybe<AttachmentWhereInput[] | AttachmentWhereInput>;
}

export interface CompanyUpdateDataInput {
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName?: Maybe<String>;
  logo?: Maybe<AttachmentUpdateOneInput>;
  name?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  companyMembers?: Maybe<CompanyMemberUpdateManyWithoutCompanyInput>;
  activePlan?: Maybe<PlanUpdateOneWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface PatientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  names_every?: Maybe<NameWhereInput>;
  names_some?: Maybe<NameWhereInput>;
  names_none?: Maybe<NameWhereInput>;
  address?: Maybe<AddressWhereInput>;
  birthAddress?: Maybe<AddressWhereInput>;
  dateOfBirth?: Maybe<DateTimeInput>;
  dateOfBirth_not?: Maybe<DateTimeInput>;
  dateOfBirth_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_lt?: Maybe<DateTimeInput>;
  dateOfBirth_lte?: Maybe<DateTimeInput>;
  dateOfBirth_gt?: Maybe<DateTimeInput>;
  dateOfBirth_gte?: Maybe<DateTimeInput>;
  customer?: Maybe<CustomerWhereInput>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  dvaCardType?: Maybe<DVACardType>;
  dvaCardType_not?: Maybe<DVACardType>;
  dvaCardType_in?: Maybe<DVACardType[] | DVACardType>;
  dvaCardType_not_in?: Maybe<DVACardType[] | DVACardType>;
  aboriginalStatus?: Maybe<AboriginalStatus>;
  aboriginalStatus_not?: Maybe<AboriginalStatus>;
  aboriginalStatus_in?: Maybe<AboriginalStatus[] | AboriginalStatus>;
  aboriginalStatus_not_in?: Maybe<AboriginalStatus[] | AboriginalStatus>;
  pensionerConcession?: Maybe<String>;
  pensionerConcession_not?: Maybe<String>;
  pensionerConcession_in?: Maybe<String[] | String>;
  pensionerConcession_not_in?: Maybe<String[] | String>;
  pensionerConcession_lt?: Maybe<String>;
  pensionerConcession_lte?: Maybe<String>;
  pensionerConcession_gt?: Maybe<String>;
  pensionerConcession_gte?: Maybe<String>;
  pensionerConcession_contains?: Maybe<String>;
  pensionerConcession_not_contains?: Maybe<String>;
  pensionerConcession_starts_with?: Maybe<String>;
  pensionerConcession_not_starts_with?: Maybe<String>;
  pensionerConcession_ends_with?: Maybe<String>;
  pensionerConcession_not_ends_with?: Maybe<String>;
  commonwealthSeniors?: Maybe<String>;
  commonwealthSeniors_not?: Maybe<String>;
  commonwealthSeniors_in?: Maybe<String[] | String>;
  commonwealthSeniors_not_in?: Maybe<String[] | String>;
  commonwealthSeniors_lt?: Maybe<String>;
  commonwealthSeniors_lte?: Maybe<String>;
  commonwealthSeniors_gt?: Maybe<String>;
  commonwealthSeniors_gte?: Maybe<String>;
  commonwealthSeniors_contains?: Maybe<String>;
  commonwealthSeniors_not_contains?: Maybe<String>;
  commonwealthSeniors_starts_with?: Maybe<String>;
  commonwealthSeniors_not_starts_with?: Maybe<String>;
  commonwealthSeniors_ends_with?: Maybe<String>;
  commonwealthSeniors_not_ends_with?: Maybe<String>;
  healthcareConcession?: Maybe<String>;
  healthcareConcession_not?: Maybe<String>;
  healthcareConcession_in?: Maybe<String[] | String>;
  healthcareConcession_not_in?: Maybe<String[] | String>;
  healthcareConcession_lt?: Maybe<String>;
  healthcareConcession_lte?: Maybe<String>;
  healthcareConcession_gt?: Maybe<String>;
  healthcareConcession_gte?: Maybe<String>;
  healthcareConcession_contains?: Maybe<String>;
  healthcareConcession_not_contains?: Maybe<String>;
  healthcareConcession_starts_with?: Maybe<String>;
  healthcareConcession_not_starts_with?: Maybe<String>;
  healthcareConcession_ends_with?: Maybe<String>;
  healthcareConcession_not_ends_with?: Maybe<String>;
  safetyNetConcession?: Maybe<Float>;
  safetyNetConcession_not?: Maybe<Float>;
  safetyNetConcession_in?: Maybe<Float[] | Float>;
  safetyNetConcession_not_in?: Maybe<Float[] | Float>;
  safetyNetConcession_lt?: Maybe<Float>;
  safetyNetConcession_lte?: Maybe<Float>;
  safetyNetConcession_gt?: Maybe<Float>;
  safetyNetConcession_gte?: Maybe<Float>;
  medicareNumber?: Maybe<String>;
  medicareNumber_not?: Maybe<String>;
  medicareNumber_in?: Maybe<String[] | String>;
  medicareNumber_not_in?: Maybe<String[] | String>;
  medicareNumber_lt?: Maybe<String>;
  medicareNumber_lte?: Maybe<String>;
  medicareNumber_gt?: Maybe<String>;
  medicareNumber_gte?: Maybe<String>;
  medicareNumber_contains?: Maybe<String>;
  medicareNumber_not_contains?: Maybe<String>;
  medicareNumber_starts_with?: Maybe<String>;
  medicareNumber_not_starts_with?: Maybe<String>;
  medicareNumber_ends_with?: Maybe<String>;
  medicareNumber_not_ends_with?: Maybe<String>;
  DVA?: Maybe<String>;
  DVA_not?: Maybe<String>;
  DVA_in?: Maybe<String[] | String>;
  DVA_not_in?: Maybe<String[] | String>;
  DVA_lt?: Maybe<String>;
  DVA_lte?: Maybe<String>;
  DVA_gt?: Maybe<String>;
  DVA_gte?: Maybe<String>;
  DVA_contains?: Maybe<String>;
  DVA_not_contains?: Maybe<String>;
  DVA_starts_with?: Maybe<String>;
  DVA_not_starts_with?: Maybe<String>;
  DVA_ends_with?: Maybe<String>;
  DVA_not_ends_with?: Maybe<String>;
  potentialDuplicate?: Maybe<Boolean>;
  potentialDuplicate_not?: Maybe<Boolean>;
  oneName?: Maybe<Boolean>;
  oneName_not?: Maybe<Boolean>;
  ihi?: Maybe<String>;
  ihi_not?: Maybe<String>;
  ihi_in?: Maybe<String[] | String>;
  ihi_not_in?: Maybe<String[] | String>;
  ihi_lt?: Maybe<String>;
  ihi_lte?: Maybe<String>;
  ihi_gt?: Maybe<String>;
  ihi_gte?: Maybe<String>;
  ihi_contains?: Maybe<String>;
  ihi_not_contains?: Maybe<String>;
  ihi_starts_with?: Maybe<String>;
  ihi_not_starts_with?: Maybe<String>;
  ihi_ends_with?: Maybe<String>;
  ihi_not_ends_with?: Maybe<String>;
  ihiValidatedDate?: Maybe<DateTimeInput>;
  ihiValidatedDate_not?: Maybe<DateTimeInput>;
  ihiValidatedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ihiValidatedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  ihiValidatedDate_lt?: Maybe<DateTimeInput>;
  ihiValidatedDate_lte?: Maybe<DateTimeInput>;
  ihiValidatedDate_gt?: Maybe<DateTimeInput>;
  ihiValidatedDate_gte?: Maybe<DateTimeInput>;
  noOfBirths?: Maybe<Int>;
  noOfBirths_not?: Maybe<Int>;
  noOfBirths_in?: Maybe<Int[] | Int>;
  noOfBirths_not_in?: Maybe<Int[] | Int>;
  noOfBirths_lt?: Maybe<Int>;
  noOfBirths_lte?: Maybe<Int>;
  noOfBirths_gt?: Maybe<Int>;
  noOfBirths_gte?: Maybe<Int>;
  deceasedDate?: Maybe<DateTimeInput>;
  deceasedDate_not?: Maybe<DateTimeInput>;
  deceasedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deceasedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deceasedDate_lt?: Maybe<DateTimeInput>;
  deceasedDate_lte?: Maybe<DateTimeInput>;
  deceasedDate_gt?: Maybe<DateTimeInput>;
  deceasedDate_gte?: Maybe<DateTimeInput>;
  basicDailyFee_every?: Maybe<BasicDailyFeeWhereInput>;
  basicDailyFee_some?: Maybe<BasicDailyFeeWhereInput>;
  basicDailyFee_none?: Maybe<BasicDailyFeeWhereInput>;
  levelOfCare?: Maybe<LevelOfCare>;
  levelOfCare_not?: Maybe<LevelOfCare>;
  levelOfCare_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  levelOfCare_not_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  dateEnteredAgedCare?: Maybe<DateTimeInput>;
  dateEnteredAgedCare_not?: Maybe<DateTimeInput>;
  dateEnteredAgedCare_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateEnteredAgedCare_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateEnteredAgedCare_lt?: Maybe<DateTimeInput>;
  dateEnteredAgedCare_lte?: Maybe<DateTimeInput>;
  dateEnteredAgedCare_gt?: Maybe<DateTimeInput>;
  dateEnteredAgedCare_gte?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  OR?: Maybe<PatientWhereInput[] | PatientWhereInput>;
  NOT?: Maybe<PatientWhereInput[] | PatientWhereInput>;
}

export interface AttachmentUpdateOneInput {
  create?: Maybe<AttachmentCreateInput>;
  update?: Maybe<AttachmentUpdateDataInput>;
  upsert?: Maybe<AttachmentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AttachmentWhereUniqueInput>;
}

export interface CompanyUpdateOneRequiredWithoutActivePlanInput {
  create?: Maybe<CompanyCreateWithoutActivePlanInput>;
  update?: Maybe<CompanyUpdateWithoutActivePlanDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutActivePlanInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface AttachmentUpdateDataInput {
  description?: Maybe<String>;
  fileName?: Maybe<String>;
  label?: Maybe<String>;
  url?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Key?: Maybe<String>;
}

export interface CompanyCreateWithoutActivePlanInput {
  id?: Maybe<ID_Input>;
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency: Currency;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName: String;
  logo?: Maybe<AttachmentCreateOneInput>;
  name: String;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyInput>;
  contacts?: Maybe<ContactCreateManyInput>;
  companyMembers?: Maybe<CompanyMemberCreateManyWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface AttachmentUpsertNestedInput {
  update: AttachmentUpdateDataInput;
  create: AttachmentCreateInput;
}

export interface CompanyCreateOneWithoutActivePlanInput {
  create?: Maybe<CompanyCreateWithoutActivePlanInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface ContactUpdateManyInput {
  create?: Maybe<ContactCreateInput[] | ContactCreateInput>;
  update?: Maybe<
    | ContactUpdateWithWhereUniqueNestedInput[]
    | ContactUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ContactUpsertWithWhereUniqueNestedInput[]
    | ContactUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  set?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  disconnect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  deleteMany?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  updateMany?: Maybe<
    | ContactUpdateManyWithWhereNestedInput[]
    | ContactUpdateManyWithWhereNestedInput
  >;
}

export interface PlanCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneWithoutActivePlanInput;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  price?: Maybe<Float>;
  type?: Maybe<PlanType>;
  currency: Currency;
}

export interface ContactUpdateWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput;
  data: ContactUpdateDataInput;
}

export interface PbsOrganisationUpsertNestedInput {
  update: PbsOrganisationUpdateDataInput;
  create: PbsOrganisationCreateInput;
}

export interface ContactUpdateDataInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  email?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineNumber?: Maybe<String>;
}

export type PbsTPPWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactUpsertWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput;
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  surname?: Maybe<String>;
  surname_not?: Maybe<String>;
  surname_in?: Maybe<String[] | String>;
  surname_not_in?: Maybe<String[] | String>;
  surname_lt?: Maybe<String>;
  surname_lte?: Maybe<String>;
  surname_gt?: Maybe<String>;
  surname_gte?: Maybe<String>;
  surname_contains?: Maybe<String>;
  surname_not_contains?: Maybe<String>;
  surname_starts_with?: Maybe<String>;
  surname_not_starts_with?: Maybe<String>;
  surname_ends_with?: Maybe<String>;
  surname_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileCode_not?: Maybe<String>;
  mobileCode_in?: Maybe<String[] | String>;
  mobileCode_not_in?: Maybe<String[] | String>;
  mobileCode_lt?: Maybe<String>;
  mobileCode_lte?: Maybe<String>;
  mobileCode_gt?: Maybe<String>;
  mobileCode_gte?: Maybe<String>;
  mobileCode_contains?: Maybe<String>;
  mobileCode_not_contains?: Maybe<String>;
  mobileCode_starts_with?: Maybe<String>;
  mobileCode_not_starts_with?: Maybe<String>;
  mobileCode_ends_with?: Maybe<String>;
  mobileCode_not_ends_with?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  mobileNumber_not?: Maybe<String>;
  mobileNumber_in?: Maybe<String[] | String>;
  mobileNumber_not_in?: Maybe<String[] | String>;
  mobileNumber_lt?: Maybe<String>;
  mobileNumber_lte?: Maybe<String>;
  mobileNumber_gt?: Maybe<String>;
  mobileNumber_gte?: Maybe<String>;
  mobileNumber_contains?: Maybe<String>;
  mobileNumber_not_contains?: Maybe<String>;
  mobileNumber_starts_with?: Maybe<String>;
  mobileNumber_not_starts_with?: Maybe<String>;
  mobileNumber_ends_with?: Maybe<String>;
  mobileNumber_not_ends_with?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineCode_not?: Maybe<String>;
  landlineCode_in?: Maybe<String[] | String>;
  landlineCode_not_in?: Maybe<String[] | String>;
  landlineCode_lt?: Maybe<String>;
  landlineCode_lte?: Maybe<String>;
  landlineCode_gt?: Maybe<String>;
  landlineCode_gte?: Maybe<String>;
  landlineCode_contains?: Maybe<String>;
  landlineCode_not_contains?: Maybe<String>;
  landlineCode_starts_with?: Maybe<String>;
  landlineCode_not_starts_with?: Maybe<String>;
  landlineCode_ends_with?: Maybe<String>;
  landlineCode_not_ends_with?: Maybe<String>;
  landlineNumber?: Maybe<String>;
  landlineNumber_not?: Maybe<String>;
  landlineNumber_in?: Maybe<String[] | String>;
  landlineNumber_not_in?: Maybe<String[] | String>;
  landlineNumber_lt?: Maybe<String>;
  landlineNumber_lte?: Maybe<String>;
  landlineNumber_gt?: Maybe<String>;
  landlineNumber_gte?: Maybe<String>;
  landlineNumber_contains?: Maybe<String>;
  landlineNumber_not_contains?: Maybe<String>;
  landlineNumber_starts_with?: Maybe<String>;
  landlineNumber_not_starts_with?: Maybe<String>;
  landlineNumber_ends_with?: Maybe<String>;
  landlineNumber_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface ContactScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  surname?: Maybe<String>;
  surname_not?: Maybe<String>;
  surname_in?: Maybe<String[] | String>;
  surname_not_in?: Maybe<String[] | String>;
  surname_lt?: Maybe<String>;
  surname_lte?: Maybe<String>;
  surname_gt?: Maybe<String>;
  surname_gte?: Maybe<String>;
  surname_contains?: Maybe<String>;
  surname_not_contains?: Maybe<String>;
  surname_starts_with?: Maybe<String>;
  surname_not_starts_with?: Maybe<String>;
  surname_ends_with?: Maybe<String>;
  surname_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileCode_not?: Maybe<String>;
  mobileCode_in?: Maybe<String[] | String>;
  mobileCode_not_in?: Maybe<String[] | String>;
  mobileCode_lt?: Maybe<String>;
  mobileCode_lte?: Maybe<String>;
  mobileCode_gt?: Maybe<String>;
  mobileCode_gte?: Maybe<String>;
  mobileCode_contains?: Maybe<String>;
  mobileCode_not_contains?: Maybe<String>;
  mobileCode_starts_with?: Maybe<String>;
  mobileCode_not_starts_with?: Maybe<String>;
  mobileCode_ends_with?: Maybe<String>;
  mobileCode_not_ends_with?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  mobileNumber_not?: Maybe<String>;
  mobileNumber_in?: Maybe<String[] | String>;
  mobileNumber_not_in?: Maybe<String[] | String>;
  mobileNumber_lt?: Maybe<String>;
  mobileNumber_lte?: Maybe<String>;
  mobileNumber_gt?: Maybe<String>;
  mobileNumber_gte?: Maybe<String>;
  mobileNumber_contains?: Maybe<String>;
  mobileNumber_not_contains?: Maybe<String>;
  mobileNumber_starts_with?: Maybe<String>;
  mobileNumber_not_starts_with?: Maybe<String>;
  mobileNumber_ends_with?: Maybe<String>;
  mobileNumber_not_ends_with?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineCode_not?: Maybe<String>;
  landlineCode_in?: Maybe<String[] | String>;
  landlineCode_not_in?: Maybe<String[] | String>;
  landlineCode_lt?: Maybe<String>;
  landlineCode_lte?: Maybe<String>;
  landlineCode_gt?: Maybe<String>;
  landlineCode_gte?: Maybe<String>;
  landlineCode_contains?: Maybe<String>;
  landlineCode_not_contains?: Maybe<String>;
  landlineCode_starts_with?: Maybe<String>;
  landlineCode_not_starts_with?: Maybe<String>;
  landlineCode_ends_with?: Maybe<String>;
  landlineCode_not_ends_with?: Maybe<String>;
  landlineNumber?: Maybe<String>;
  landlineNumber_not?: Maybe<String>;
  landlineNumber_in?: Maybe<String[] | String>;
  landlineNumber_not_in?: Maybe<String[] | String>;
  landlineNumber_lt?: Maybe<String>;
  landlineNumber_lte?: Maybe<String>;
  landlineNumber_gt?: Maybe<String>;
  landlineNumber_gte?: Maybe<String>;
  landlineNumber_contains?: Maybe<String>;
  landlineNumber_not_contains?: Maybe<String>;
  landlineNumber_starts_with?: Maybe<String>;
  landlineNumber_not_starts_with?: Maybe<String>;
  landlineNumber_ends_with?: Maybe<String>;
  landlineNumber_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  OR?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  NOT?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
}

export interface PbsTPPUpdateInput {
  snomedCode?: Maybe<String>;
  clinicalPreferredTerm?: Maybe<String>;
  packSize?: Maybe<Int>;
  brandName?: Maybe<String>;
  exManufacturerPrice?: Maybe<Float>;
  pricingModel?: Maybe<PBSPricingModel>;
  mpp_id?: Maybe<String>;
  organisation_id?: Maybe<PbsOrganisationUpdateOneInput>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ContactUpdateManyWithWhereNestedInput {
  where: ContactScalarWhereInput;
  data: ContactUpdateManyDataInput;
}

export interface PbsTPPCreateInput {
  id?: Maybe<ID_Input>;
  snomedCode?: Maybe<String>;
  clinicalPreferredTerm?: Maybe<String>;
  packSize?: Maybe<Int>;
  brandName?: Maybe<String>;
  exManufacturerPrice?: Maybe<Float>;
  pricingModel?: Maybe<PBSPricingModel>;
  mpp_id?: Maybe<String>;
  organisation_id?: Maybe<PbsOrganisationCreateOneInput>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ContactUpdateManyDataInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  email?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineNumber?: Maybe<String>;
}

export type PlanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyMemberUpdateManyWithoutCompanyInput {
  create?: Maybe<
    | CompanyMemberCreateWithoutCompanyInput[]
    | CompanyMemberCreateWithoutCompanyInput
  >;
  delete?: Maybe<
    CompanyMemberWhereUniqueInput[] | CompanyMemberWhereUniqueInput
  >;
  connect?: Maybe<
    CompanyMemberWhereUniqueInput[] | CompanyMemberWhereUniqueInput
  >;
  set?: Maybe<CompanyMemberWhereUniqueInput[] | CompanyMemberWhereUniqueInput>;
  disconnect?: Maybe<
    CompanyMemberWhereUniqueInput[] | CompanyMemberWhereUniqueInput
  >;
  update?: Maybe<
    | CompanyMemberUpdateWithWhereUniqueWithoutCompanyInput[]
    | CompanyMemberUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | CompanyMemberUpsertWithWhereUniqueWithoutCompanyInput[]
    | CompanyMemberUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<
    CompanyMemberScalarWhereInput[] | CompanyMemberScalarWhereInput
  >;
  updateMany?: Maybe<
    | CompanyMemberUpdateManyWithWhereNestedInput[]
    | CompanyMemberUpdateManyWithWhereNestedInput
  >;
}

export interface PbsOrganisationCreateInput {
  id?: Maybe<ID_Input>;
  code?: Maybe<String>;
  title?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  stateAddress?: Maybe<String>;
  postcode?: Maybe<String>;
  phone?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface CompanyMemberUpdateWithWhereUniqueWithoutCompanyInput {
  where: CompanyMemberWhereUniqueInput;
  data: CompanyMemberUpdateWithoutCompanyDataInput;
}

export interface BasicDailyFeeUpdateManyDataInput {
  level?: Maybe<LevelOfCare>;
  rate?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
}

export interface CompanyMemberUpdateWithoutCompanyDataInput {
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface BasicDailyFeeUpdateManyWithWhereNestedInput {
  where: BasicDailyFeeScalarWhereInput;
  data: BasicDailyFeeUpdateManyDataInput;
}

export interface CompanyMemberUpsertWithWhereUniqueWithoutCompanyInput {
  where: CompanyMemberWhereUniqueInput;
  update: CompanyMemberUpdateWithoutCompanyDataInput;
  create: CompanyMemberCreateWithoutCompanyInput;
}

export interface BasicDailyFeeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  level?: Maybe<LevelOfCare>;
  level_not?: Maybe<LevelOfCare>;
  level_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  level_not_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  rate?: Maybe<Float>;
  rate_not?: Maybe<Float>;
  rate_in?: Maybe<Float[] | Float>;
  rate_not_in?: Maybe<Float[] | Float>;
  rate_lt?: Maybe<Float>;
  rate_lte?: Maybe<Float>;
  rate_gt?: Maybe<Float>;
  rate_gte?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateFrom_not?: Maybe<DateTimeInput>;
  dateFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_lt?: Maybe<DateTimeInput>;
  dateFrom_lte?: Maybe<DateTimeInput>;
  dateFrom_gt?: Maybe<DateTimeInput>;
  dateFrom_gte?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  dateTo_not?: Maybe<DateTimeInput>;
  dateTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_lt?: Maybe<DateTimeInput>;
  dateTo_lte?: Maybe<DateTimeInput>;
  dateTo_gt?: Maybe<DateTimeInput>;
  dateTo_gte?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
  rechargeable_not?: Maybe<Float>;
  rechargeable_in?: Maybe<Float[] | Float>;
  rechargeable_not_in?: Maybe<Float[] | Float>;
  rechargeable_lt?: Maybe<Float>;
  rechargeable_lte?: Maybe<Float>;
  rechargeable_gt?: Maybe<Float>;
  rechargeable_gte?: Maybe<Float>;
  AND?: Maybe<BasicDailyFeeScalarWhereInput[] | BasicDailyFeeScalarWhereInput>;
  OR?: Maybe<BasicDailyFeeScalarWhereInput[] | BasicDailyFeeScalarWhereInput>;
  NOT?: Maybe<BasicDailyFeeScalarWhereInput[] | BasicDailyFeeScalarWhereInput>;
}

export interface CompanyMemberScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  role_not?: Maybe<CompanyMemberRole>;
  role_in?: Maybe<CompanyMemberRole[] | CompanyMemberRole>;
  role_not_in?: Maybe<CompanyMemberRole[] | CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  status_not?: Maybe<CompanyMemberStatus>;
  status_in?: Maybe<CompanyMemberStatus[] | CompanyMemberStatus>;
  status_not_in?: Maybe<CompanyMemberStatus[] | CompanyMemberStatus>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyMemberScalarWhereInput[] | CompanyMemberScalarWhereInput>;
  OR?: Maybe<CompanyMemberScalarWhereInput[] | CompanyMemberScalarWhereInput>;
  NOT?: Maybe<CompanyMemberScalarWhereInput[] | CompanyMemberScalarWhereInput>;
}

export interface BasicDailyFeeUpdateWithWhereUniqueNestedInput {
  where: BasicDailyFeeWhereUniqueInput;
  data: BasicDailyFeeUpdateDataInput;
}

export interface CompanyMemberUpdateManyWithWhereNestedInput {
  where: CompanyMemberScalarWhereInput;
  data: CompanyMemberUpdateManyDataInput;
}

export type PredictedSalesQuantityOfItemsByCompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CompanyMemberUpdateManyDataInput {
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
}

export interface PredictedSalesQuantityOfItemsByCompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  datePredictionRun?: Maybe<DateTimeInput>;
  datePredictionRun_not?: Maybe<DateTimeInput>;
  datePredictionRun_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePredictionRun_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePredictionRun_lt?: Maybe<DateTimeInput>;
  datePredictionRun_lte?: Maybe<DateTimeInput>;
  datePredictionRun_gt?: Maybe<DateTimeInput>;
  datePredictionRun_gte?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyWhereInput>;
  inventory?: Maybe<InventoryWhereInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedSalesValue_not?: Maybe<Float>;
  predictedSalesValue_in?: Maybe<Float[] | Float>;
  predictedSalesValue_not_in?: Maybe<Float[] | Float>;
  predictedSalesValue_lt?: Maybe<Float>;
  predictedSalesValue_lte?: Maybe<Float>;
  predictedSalesValue_gt?: Maybe<Float>;
  predictedSalesValue_gte?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
  predictedDate_not?: Maybe<DateTimeInput>;
  predictedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  predictedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  predictedDate_lt?: Maybe<DateTimeInput>;
  predictedDate_lte?: Maybe<DateTimeInput>;
  predictedDate_gt?: Maybe<DateTimeInput>;
  predictedDate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanyWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanyWhereInput
  >;
  OR?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanyWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanyWhereInput
  >;
  NOT?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanyWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanyWhereInput
  >;
}

export interface PlanUpdateOneWithoutCompanyInput {
  create?: Maybe<PlanCreateWithoutCompanyInput>;
  update?: Maybe<PlanUpdateWithoutCompanyDataInput>;
  upsert?: Maybe<PlanUpsertWithoutCompanyInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PlanWhereUniqueInput>;
}

export interface NameScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isPrimary_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NameScalarWhereInput[] | NameScalarWhereInput>;
  OR?: Maybe<NameScalarWhereInput[] | NameScalarWhereInput>;
  NOT?: Maybe<NameScalarWhereInput[] | NameScalarWhereInput>;
}

export interface PlanUpdateWithoutCompanyDataInput {
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  price?: Maybe<Float>;
  type?: Maybe<PlanType>;
  currency?: Maybe<Currency>;
}

export interface NameUpdateDataInput {
  name?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PlanUpsertWithoutCompanyInput {
  update: PlanUpdateWithoutCompanyDataInput;
  create: PlanCreateWithoutCompanyInput;
}

export interface NameUpdateWithWhereUniqueNestedInput {
  where: NameWhereUniqueInput;
  data: NameUpdateDataInput;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface NameUpdateManyInput {
  create?: Maybe<NameCreateInput[] | NameCreateInput>;
  update?: Maybe<
    | NameUpdateWithWhereUniqueNestedInput[]
    | NameUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | NameUpsertWithWhereUniqueNestedInput[]
    | NameUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<NameWhereUniqueInput[] | NameWhereUniqueInput>;
  connect?: Maybe<NameWhereUniqueInput[] | NameWhereUniqueInput>;
  set?: Maybe<NameWhereUniqueInput[] | NameWhereUniqueInput>;
  disconnect?: Maybe<NameWhereUniqueInput[] | NameWhereUniqueInput>;
  deleteMany?: Maybe<NameScalarWhereInput[] | NameScalarWhereInput>;
  updateMany?: Maybe<
    NameUpdateManyWithWhereNestedInput[] | NameUpdateManyWithWhereNestedInput
  >;
}

export interface SupplierUpsertNestedInput {
  update: SupplierUpdateDataInput;
  create: SupplierCreateInput;
}

export interface BasicDailyFeeCreateManyInput {
  create?: Maybe<BasicDailyFeeCreateInput[] | BasicDailyFeeCreateInput>;
  connect?: Maybe<
    BasicDailyFeeWhereUniqueInput[] | BasicDailyFeeWhereUniqueInput
  >;
}

export interface ProjectServiceRuleUpdateManyDataInput {
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ApInvoiceUpdateManyMutationInput {
  status?: Maybe<ApInvoiceStatus>;
  invoiceNumber?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface NameUpdateManyMutationInput {
  name?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  assetGroup?: Maybe<AssetGroupCreateOneInput>;
  dateOfAquisition?: Maybe<DateTimeInput>;
  aquisitionPrice?: Maybe<Float>;
  netBookValue?: Maybe<Float>;
  depreciation?: Maybe<Float>;
  salvageValue?: Maybe<Float>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface NameCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetGroupCreateOneInput {
  create?: Maybe<AssetGroupCreateInput>;
  connect?: Maybe<AssetGroupWhereUniqueInput>;
}

export interface MedicareServiceUpdateManyMutationInput {
  MBSScheduleFee?: Maybe<Float>;
  description?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetGroupCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  depreciationType?: Maybe<AssetGroupDepreciationType>;
  usefulLife?: Maybe<Int>;
  deprMainAccount?: Maybe<MainAccountCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MedicareServiceCreateInput {
  id?: Maybe<ID_Input>;
  MBSScheduleFee?: Maybe<Float>;
  description?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MainAccountCreateOneInput {
  create?: Maybe<MainAccountCreateInput>;
  connect?: Maybe<MainAccountWhereUniqueInput>;
}

export interface MeansTestedFeeUpdateManyMutationInput {
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
}

export interface MainAccountCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  name: String;
  description?: Maybe<String>;
  type: MainAccountType;
  ConsTaxFree?: Maybe<Boolean>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MeansTestLimitsUpdateManyMutationInput {
  annual?: Maybe<Float>;
  lifetime?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
}

export interface AssetUpdateInput {
  name?: Maybe<String>;
  assetGroup?: Maybe<AssetGroupUpdateOneInput>;
  dateOfAquisition?: Maybe<DateTimeInput>;
  aquisitionPrice?: Maybe<Float>;
  netBookValue?: Maybe<Float>;
  depreciation?: Maybe<Float>;
  salvageValue?: Maybe<Float>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MeansTestLimitsUpdateInput {
  annual?: Maybe<Float>;
  lifetime?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
}

export interface AssetGroupUpdateOneInput {
  create?: Maybe<AssetGroupCreateInput>;
  update?: Maybe<AssetGroupUpdateDataInput>;
  upsert?: Maybe<AssetGroupUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AssetGroupWhereUniqueInput>;
}

export interface MainAccountUpdateManyMutationInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<MainAccountType>;
  ConsTaxFree?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetGroupUpdateDataInput {
  name?: Maybe<String>;
  depreciationType?: Maybe<AssetGroupDepreciationType>;
  usefulLife?: Maybe<Int>;
  deprMainAccount?: Maybe<MainAccountUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type PurchaseOrderLineWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MainAccountUpdateOneInput {
  create?: Maybe<MainAccountCreateInput>;
  update?: Maybe<MainAccountUpdateDataInput>;
  upsert?: Maybe<MainAccountUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MainAccountWhereUniqueInput>;
}

export interface PurchaseOrderLineWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  item?: Maybe<InventoryWhereInput>;
  pbsDrug?: Maybe<String>;
  pbsDrug_not?: Maybe<String>;
  pbsDrug_in?: Maybe<String[] | String>;
  pbsDrug_not_in?: Maybe<String[] | String>;
  pbsDrug_lt?: Maybe<String>;
  pbsDrug_lte?: Maybe<String>;
  pbsDrug_gt?: Maybe<String>;
  pbsDrug_gte?: Maybe<String>;
  pbsDrug_contains?: Maybe<String>;
  pbsDrug_not_contains?: Maybe<String>;
  pbsDrug_starts_with?: Maybe<String>;
  pbsDrug_not_starts_with?: Maybe<String>;
  pbsDrug_ends_with?: Maybe<String>;
  pbsDrug_not_ends_with?: Maybe<String>;
  qty?: Maybe<Int>;
  qty_not?: Maybe<Int>;
  qty_in?: Maybe<Int[] | Int>;
  qty_not_in?: Maybe<Int[] | Int>;
  qty_lt?: Maybe<Int>;
  qty_lte?: Maybe<Int>;
  qty_gt?: Maybe<Int>;
  qty_gte?: Maybe<Int>;
  unit?: Maybe<UOM>;
  unit_not?: Maybe<UOM>;
  unit_in?: Maybe<UOM[] | UOM>;
  unit_not_in?: Maybe<UOM[] | UOM>;
  unitPrice?: Maybe<Float>;
  unitPrice_not?: Maybe<Float>;
  unitPrice_in?: Maybe<Float[] | Float>;
  unitPrice_not_in?: Maybe<Float[] | Float>;
  unitPrice_lt?: Maybe<Float>;
  unitPrice_lte?: Maybe<Float>;
  unitPrice_gt?: Maybe<Float>;
  unitPrice_gte?: Maybe<Float>;
  site?: Maybe<WareHouseWhereInput>;
  purchaseOrder?: Maybe<PurchaseOrderWhereInput>;
  poReceipt?: Maybe<PoReceiptWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseOrderLineWhereInput[] | PurchaseOrderLineWhereInput>;
  OR?: Maybe<PurchaseOrderLineWhereInput[] | PurchaseOrderLineWhereInput>;
  NOT?: Maybe<PurchaseOrderLineWhereInput[] | PurchaseOrderLineWhereInput>;
}

export interface MainAccountUpdateDataInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<MainAccountType>;
  ConsTaxFree?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface LedgerJournalUpdateOneRequiredInput {
  create?: Maybe<LedgerJournalCreateInput>;
  update?: Maybe<LedgerJournalUpdateDataInput>;
  upsert?: Maybe<LedgerJournalUpsertNestedInput>;
  connect?: Maybe<LedgerJournalWhereUniqueInput>;
}

export interface MainAccountUpsertNestedInput {
  update: MainAccountUpdateDataInput;
  create: MainAccountCreateInput;
}

export interface LedgerTransactionUpdateInput {
  mainAccount?: Maybe<MainAccountUpdateOneRequiredInput>;
  ledgerJournal?: Maybe<LedgerJournalUpdateOneRequiredInput>;
  drcr?: Maybe<DrCr>;
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  date?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetGroupUpsertNestedInput {
  update: AssetGroupUpdateDataInput;
  create: AssetGroupCreateInput;
}

export interface LedgerTransactionCreateInput {
  id?: Maybe<ID_Input>;
  mainAccount: MainAccountCreateOneInput;
  ledgerJournal: LedgerJournalCreateOneInput;
  drcr: DrCr;
  amount: Float;
  currency: Currency;
  date: DateTimeInput;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AssetUpdateManyMutationInput {
  name?: Maybe<String>;
  dateOfAquisition?: Maybe<DateTimeInput>;
  aquisitionPrice?: Maybe<Float>;
  netBookValue?: Maybe<Float>;
  depreciation?: Maybe<Float>;
  salvageValue?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface WareHouseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WareHouseWhereInput>;
  AND?: Maybe<
    WareHouseSubscriptionWhereInput[] | WareHouseSubscriptionWhereInput
  >;
  OR?: Maybe<
    WareHouseSubscriptionWhereInput[] | WareHouseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    WareHouseSubscriptionWhereInput[] | WareHouseSubscriptionWhereInput
  >;
}

export interface AssetGroupUpdateInput {
  name?: Maybe<String>;
  depreciationType?: Maybe<AssetGroupDepreciationType>;
  usefulLife?: Maybe<Int>;
  deprMainAccount?: Maybe<MainAccountUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface BasicDailyFeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  level?: Maybe<LevelOfCare>;
  level_not?: Maybe<LevelOfCare>;
  level_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  level_not_in?: Maybe<LevelOfCare[] | LevelOfCare>;
  rate?: Maybe<Float>;
  rate_not?: Maybe<Float>;
  rate_in?: Maybe<Float[] | Float>;
  rate_not_in?: Maybe<Float[] | Float>;
  rate_lt?: Maybe<Float>;
  rate_lte?: Maybe<Float>;
  rate_gt?: Maybe<Float>;
  rate_gte?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateFrom_not?: Maybe<DateTimeInput>;
  dateFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_lt?: Maybe<DateTimeInput>;
  dateFrom_lte?: Maybe<DateTimeInput>;
  dateFrom_gt?: Maybe<DateTimeInput>;
  dateFrom_gte?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  dateTo_not?: Maybe<DateTimeInput>;
  dateTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_lt?: Maybe<DateTimeInput>;
  dateTo_lte?: Maybe<DateTimeInput>;
  dateTo_gt?: Maybe<DateTimeInput>;
  dateTo_gte?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
  rechargeable_not?: Maybe<Float>;
  rechargeable_in?: Maybe<Float[] | Float>;
  rechargeable_not_in?: Maybe<Float[] | Float>;
  rechargeable_lt?: Maybe<Float>;
  rechargeable_lte?: Maybe<Float>;
  rechargeable_gt?: Maybe<Float>;
  rechargeable_gte?: Maybe<Float>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<BasicDailyFeeWhereInput[] | BasicDailyFeeWhereInput>;
  OR?: Maybe<BasicDailyFeeWhereInput[] | BasicDailyFeeWhereInput>;
  NOT?: Maybe<BasicDailyFeeWhereInput[] | BasicDailyFeeWhereInput>;
}

export interface AssetGroupUpdateManyMutationInput {
  name?: Maybe<String>;
  depreciationType?: Maybe<AssetGroupDepreciationType>;
  usefulLife?: Maybe<Int>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface TimeSheetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TimeSheetWhereInput>;
  AND?: Maybe<
    TimeSheetSubscriptionWhereInput[] | TimeSheetSubscriptionWhereInput
  >;
  OR?: Maybe<
    TimeSheetSubscriptionWhereInput[] | TimeSheetSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TimeSheetSubscriptionWhereInput[] | TimeSheetSubscriptionWhereInput
  >;
}

export interface AttachmentUpdateInput {
  description?: Maybe<String>;
  fileName?: Maybe<String>;
  label?: Maybe<String>;
  url?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Key?: Maybe<String>;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceWhereInput>;
  AND?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  OR?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  NOT?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
}

export interface AttachmentUpdateManyMutationInput {
  description?: Maybe<String>;
  fileName?: Maybe<String>;
  label?: Maybe<String>;
  url?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Key?: Maybe<String>;
}

export interface PurchaseOrderLineSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PurchaseOrderLineWhereInput>;
  AND?: Maybe<
    | PurchaseOrderLineSubscriptionWhereInput[]
    | PurchaseOrderLineSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PurchaseOrderLineSubscriptionWhereInput[]
    | PurchaseOrderLineSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PurchaseOrderLineSubscriptionWhereInput[]
    | PurchaseOrderLineSubscriptionWhereInput
  >;
}

export interface BankCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  institution?: Maybe<String>;
  bsb?: Maybe<String>;
  accountNumber?: Maybe<String>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectServiceWhereInput>;
  AND?: Maybe<
    | ProjectServiceSubscriptionWhereInput[]
    | ProjectServiceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProjectServiceSubscriptionWhereInput[]
    | ProjectServiceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProjectServiceSubscriptionWhereInput[]
    | ProjectServiceSubscriptionWhereInput
  >;
}

export interface BankUpdateInput {
  name?: Maybe<String>;
  institution?: Maybe<String>;
  bsb?: Maybe<String>;
  accountNumber?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PredictedSalesQuantityOfItemsByCompanyWhereInput>;
  AND?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput
  >;
  OR?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput[]
    | PredictedSalesQuantityOfItemsByCompanySubscriptionWhereInput
  >;
}

export interface BankUpdateManyMutationInput {
  name?: Maybe<String>;
  institution?: Maybe<String>;
  bsb?: Maybe<String>;
  accountNumber?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PlanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlanWhereInput>;
  AND?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
  OR?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
  NOT?: Maybe<PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput>;
}

export interface BankTransactionCreateInput {
  id?: Maybe<ID_Input>;
  transactionDate: DateTimeInput;
  amount: Float;
  description?: Maybe<String>;
  posted?: Maybe<Boolean>;
  ledgerJournal?: Maybe<LedgerJournalCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PatientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PatientWhereInput>;
  AND?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  OR?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
  NOT?: Maybe<PatientSubscriptionWhereInput[] | PatientSubscriptionWhereInput>;
}

export interface LedgerJournalCreateOneInput {
  create?: Maybe<LedgerJournalCreateInput>;
  connect?: Maybe<LedgerJournalWhereUniqueInput>;
}

export interface MedicareServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MedicareServiceWhereInput>;
  AND?: Maybe<
    | MedicareServiceSubscriptionWhereInput[]
    | MedicareServiceSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MedicareServiceSubscriptionWhereInput[]
    | MedicareServiceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MedicareServiceSubscriptionWhereInput[]
    | MedicareServiceSubscriptionWhereInput
  >;
}

export interface LedgerJournalCreateInput {
  id?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  description?: Maybe<String>;
  currency: Currency;
  includeConsTax: Boolean;
  posted: Boolean;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MainAccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MainAccountWhereInput>;
  AND?: Maybe<
    MainAccountSubscriptionWhereInput[] | MainAccountSubscriptionWhereInput
  >;
  OR?: Maybe<
    MainAccountSubscriptionWhereInput[] | MainAccountSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MainAccountSubscriptionWhereInput[] | MainAccountSubscriptionWhereInput
  >;
}

export interface BankTransactionUpdateInput {
  transactionDate?: Maybe<DateTimeInput>;
  amount?: Maybe<Float>;
  description?: Maybe<String>;
  posted?: Maybe<Boolean>;
  ledgerJournal?: Maybe<LedgerJournalUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface LedgerJournalSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LedgerJournalWhereInput>;
  AND?: Maybe<
    LedgerJournalSubscriptionWhereInput[] | LedgerJournalSubscriptionWhereInput
  >;
  OR?: Maybe<
    LedgerJournalSubscriptionWhereInput[] | LedgerJournalSubscriptionWhereInput
  >;
  NOT?: Maybe<
    LedgerJournalSubscriptionWhereInput[] | LedgerJournalSubscriptionWhereInput
  >;
}

export interface LedgerJournalUpdateOneInput {
  create?: Maybe<LedgerJournalCreateInput>;
  update?: Maybe<LedgerJournalUpdateDataInput>;
  upsert?: Maybe<LedgerJournalUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LedgerJournalWhereUniqueInput>;
}

export interface InventoryOnHandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InventoryOnHandWhereInput>;
  AND?: Maybe<
    | InventoryOnHandSubscriptionWhereInput[]
    | InventoryOnHandSubscriptionWhereInput
  >;
  OR?: Maybe<
    | InventoryOnHandSubscriptionWhereInput[]
    | InventoryOnHandSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | InventoryOnHandSubscriptionWhereInput[]
    | InventoryOnHandSubscriptionWhereInput
  >;
}

export interface LedgerJournalUpdateDataInput {
  total?: Maybe<Float>;
  description?: Maybe<String>;
  currency?: Maybe<Currency>;
  includeConsTax?: Maybe<Boolean>;
  posted?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface IntegrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IntegrationWhereInput>;
  AND?: Maybe<
    IntegrationSubscriptionWhereInput[] | IntegrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    IntegrationSubscriptionWhereInput[] | IntegrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    IntegrationSubscriptionWhereInput[] | IntegrationSubscriptionWhereInput
  >;
}

export interface LedgerJournalUpsertNestedInput {
  update: LedgerJournalUpdateDataInput;
  create: LedgerJournalCreateInput;
}

export interface HILogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HILogWhereInput>;
  AND?: Maybe<HILogSubscriptionWhereInput[] | HILogSubscriptionWhereInput>;
  OR?: Maybe<HILogSubscriptionWhereInput[] | HILogSubscriptionWhereInput>;
  NOT?: Maybe<HILogSubscriptionWhereInput[] | HILogSubscriptionWhereInput>;
}

export interface BankTransactionUpdateManyMutationInput {
  transactionDate?: Maybe<DateTimeInput>;
  amount?: Maybe<Float>;
  description?: Maybe<String>;
  posted?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface VaccineBrandWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<VaccineBrandWhereInput[] | VaccineBrandWhereInput>;
  OR?: Maybe<VaccineBrandWhereInput[] | VaccineBrandWhereInput>;
  NOT?: Maybe<VaccineBrandWhereInput[] | VaccineBrandWhereInput>;
}

export interface BasicDailyFeeCreateInput {
  id?: Maybe<ID_Input>;
  level?: Maybe<LevelOfCare>;
  rate?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
  company?: Maybe<CompanyCreateOneInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface BasicDailyFeeUpdateInput {
  level?: Maybe<LevelOfCare>;
  rate?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
  company?: Maybe<CompanyUpdateOneInput>;
}

export interface IntegrationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  type?: Maybe<IntegrationType>;
  type_not?: Maybe<IntegrationType>;
  type_in?: Maybe<IntegrationType[] | IntegrationType>;
  type_not_in?: Maybe<IntegrationType[] | IntegrationType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<IntegrationWhereInput[] | IntegrationWhereInput>;
  OR?: Maybe<IntegrationWhereInput[] | IntegrationWhereInput>;
  NOT?: Maybe<IntegrationWhereInput[] | IntegrationWhereInput>;
}

export interface CompanyUpdateOneInput {
  create?: Maybe<CompanyCreateInput>;
  update?: Maybe<CompanyUpdateDataInput>;
  upsert?: Maybe<CompanyUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface AssetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AssetWhereInput>;
  AND?: Maybe<AssetSubscriptionWhereInput[] | AssetSubscriptionWhereInput>;
  OR?: Maybe<AssetSubscriptionWhereInput[] | AssetSubscriptionWhereInput>;
  NOT?: Maybe<AssetSubscriptionWhereInput[] | AssetSubscriptionWhereInput>;
}

export interface BasicDailyFeeUpdateManyMutationInput {
  level?: Maybe<LevelOfCare>;
  rate?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface CompanyUpdateInput {
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName?: Maybe<String>;
  logo?: Maybe<AttachmentUpdateOneInput>;
  name?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  companyMembers?: Maybe<CompanyMemberUpdateManyWithoutCompanyInput>;
  activePlan?: Maybe<PlanUpdateOneWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface VaccineBrandUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CompanyUpdateManyMutationInput {
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName?: Maybe<String>;
  name?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  stripeCustomerId?: Maybe<String>;
}

export interface UserUpdateInput {
  contactNumber?: Maybe<Json>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isRoot?: Maybe<Boolean>;
  jobTitle?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  secondAuthEnabled?: Maybe<Boolean>;
}

export interface CompanyMemberCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneWithoutCompanyMembersInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  user?: Maybe<UserCreateOneInput>;
}

export interface TimeSheetEntryUpdateInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  project?: Maybe<ProjectUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneInput>;
  timeSheet?: Maybe<TimeSheetUpdateOneWithoutTimeSheetEntriesInput>;
}

export interface CompanyCreateOneWithoutCompanyMembersInput {
  create?: Maybe<CompanyCreateWithoutCompanyMembersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface SupplierUpdateManyMutationInput {
  name?: Maybe<String>;
  termsOfPayment?: Maybe<SupplierTermsOfPayment>;
  bankAccount?: Maybe<Json>;
  emailAddressForRemittance?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface CompanyCreateWithoutCompanyMembersInput {
  id?: Maybe<ID_Input>;
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency: Currency;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName: String;
  logo?: Maybe<AttachmentCreateOneInput>;
  name: String;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressCreateManyInput>;
  contacts?: Maybe<ContactCreateManyInput>;
  activePlan?: Maybe<PlanCreateOneWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface SupplierUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<AddressUpdateManyInput>;
  termsOfPayment?: Maybe<SupplierTermsOfPayment>;
  bankAccount?: Maybe<Json>;
  emailAddressForRemittance?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface CompanyMemberUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutCompanyMembersInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface SessionUpdateManyMutationInput {
  expires_at?: Maybe<DateTimeInput>;
  is_active?: Maybe<Boolean>;
  is_archived?: Maybe<Boolean>;
  is_deleted?: Maybe<Boolean>;
  signed_at?: Maybe<DateTimeInput>;
}

export interface CompanyUpdateOneRequiredWithoutCompanyMembersInput {
  create?: Maybe<CompanyCreateWithoutCompanyMembersInput>;
  update?: Maybe<CompanyUpdateWithoutCompanyMembersDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutCompanyMembersInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface AssetGroupWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  depreciationType?: Maybe<AssetGroupDepreciationType>;
  depreciationType_not?: Maybe<AssetGroupDepreciationType>;
  depreciationType_in?: Maybe<
    AssetGroupDepreciationType[] | AssetGroupDepreciationType
  >;
  depreciationType_not_in?: Maybe<
    AssetGroupDepreciationType[] | AssetGroupDepreciationType
  >;
  usefulLife?: Maybe<Int>;
  usefulLife_not?: Maybe<Int>;
  usefulLife_in?: Maybe<Int[] | Int>;
  usefulLife_not_in?: Maybe<Int[] | Int>;
  usefulLife_lt?: Maybe<Int>;
  usefulLife_lte?: Maybe<Int>;
  usefulLife_gt?: Maybe<Int>;
  usefulLife_gte?: Maybe<Int>;
  deprMainAccount?: Maybe<MainAccountWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AssetGroupWhereInput[] | AssetGroupWhereInput>;
  OR?: Maybe<AssetGroupWhereInput[] | AssetGroupWhereInput>;
  NOT?: Maybe<AssetGroupWhereInput[] | AssetGroupWhereInput>;
}

export interface CompanyUpdateWithoutCompanyMembersDataInput {
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName?: Maybe<String>;
  logo?: Maybe<AttachmentUpdateOneInput>;
  name?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  activePlan?: Maybe<PlanUpdateOneWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface SessionCreateInput {
  id?: Maybe<ID_Input>;
  expires_at?: Maybe<DateTimeInput>;
  is_active?: Maybe<Boolean>;
  is_archived?: Maybe<Boolean>;
  is_deleted?: Maybe<Boolean>;
  signed_at?: Maybe<DateTimeInput>;
  user?: Maybe<UserCreateOneInput>;
}

export interface ProjectServiceRuleUpdateManyWithWhereNestedInput {
  where: ProjectServiceRuleScalarWhereInput;
  data: ProjectServiceRuleUpdateManyDataInput;
}

export interface SalesOrderUpsertNestedInput {
  update: SalesOrderUpdateDataInput;
  create: SalesOrderCreateInput;
}

export interface CompanyMemberUpdateManyMutationInput {
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
}

export interface SalesOrderCreateOneInput {
  create?: Maybe<SalesOrderCreateInput>;
  connect?: Maybe<SalesOrderWhereUniqueInput>;
}

export interface ContactUpdateInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  email?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineNumber?: Maybe<String>;
}

export interface SalesOrderUpdateInput {
  customer?: Maybe<CustomerUpdateOneInput>;
  transactionDate?: Maybe<DateTimeInput>;
  currency?: Maybe<Currency>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ContactUpdateManyMutationInput {
  name?: Maybe<String>;
  surname?: Maybe<String>;
  email?: Maybe<String>;
  mobileCode?: Maybe<String>;
  mobileNumber?: Maybe<String>;
  landlineCode?: Maybe<String>;
  landlineNumber?: Maybe<String>;
}

export interface PoReceiptUpsertNestedInput {
  update: PoReceiptUpdateDataInput;
  create: PoReceiptCreateInput;
}

export interface CustomerCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneInput;
  description?: Maybe<String>;
  govNumber?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  billingFrequency?: Maybe<SupplierTermsOfPayment>;
  meansTestedFee?: Maybe<MeansTestedFeeCreateOneInput>;
  basicDailyFee?: Maybe<BasicDailyFeeCreateOneInput>;
  contacts?: Maybe<ContactCreateManyInput>;
  addresses?: Maybe<AddressCreateManyInput>;
}

export interface PurchaseOrderLineUpdateInput {
  item?: Maybe<InventoryUpdateOneInput>;
  pbsDrug?: Maybe<String>;
  qty?: Maybe<Int>;
  unit?: Maybe<UOM>;
  unitPrice?: Maybe<Float>;
  site?: Maybe<WareHouseUpdateOneInput>;
  purchaseOrder?: Maybe<PurchaseOrderUpdateOneInput>;
  poReceipt?: Maybe<PoReceiptUpdateOneInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface MeansTestedFeeCreateOneInput {
  create?: Maybe<MeansTestedFeeCreateInput>;
  connect?: Maybe<MeansTestedFeeWhereUniqueInput>;
}

export type LedgerPostingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MeansTestedFeeCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyCreateOneInput>;
}

export interface SupplierWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address_every?: Maybe<AddressWhereInput>;
  address_some?: Maybe<AddressWhereInput>;
  address_none?: Maybe<AddressWhereInput>;
  termsOfPayment?: Maybe<SupplierTermsOfPayment>;
  termsOfPayment_not?: Maybe<SupplierTermsOfPayment>;
  termsOfPayment_in?: Maybe<SupplierTermsOfPayment[] | SupplierTermsOfPayment>;
  termsOfPayment_not_in?: Maybe<
    SupplierTermsOfPayment[] | SupplierTermsOfPayment
  >;
  emailAddressForRemittance?: Maybe<String>;
  emailAddressForRemittance_not?: Maybe<String>;
  emailAddressForRemittance_in?: Maybe<String[] | String>;
  emailAddressForRemittance_not_in?: Maybe<String[] | String>;
  emailAddressForRemittance_lt?: Maybe<String>;
  emailAddressForRemittance_lte?: Maybe<String>;
  emailAddressForRemittance_gt?: Maybe<String>;
  emailAddressForRemittance_gte?: Maybe<String>;
  emailAddressForRemittance_contains?: Maybe<String>;
  emailAddressForRemittance_not_contains?: Maybe<String>;
  emailAddressForRemittance_starts_with?: Maybe<String>;
  emailAddressForRemittance_not_starts_with?: Maybe<String>;
  emailAddressForRemittance_ends_with?: Maybe<String>;
  emailAddressForRemittance_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
  OR?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
  NOT?: Maybe<SupplierWhereInput[] | SupplierWhereInput>;
}

export interface BasicDailyFeeCreateOneInput {
  create?: Maybe<BasicDailyFeeCreateInput>;
  connect?: Maybe<BasicDailyFeeWhereUniqueInput>;
}

export type LedgerTransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  description?: Maybe<String>;
  govNumber?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  billingFrequency?: Maybe<SupplierTermsOfPayment>;
  meansTestedFee?: Maybe<MeansTestedFeeUpdateOneInput>;
  basicDailyFee?: Maybe<BasicDailyFeeUpdateOneInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  addresses?: Maybe<AddressUpdateManyInput>;
}

export interface ApInvoiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<ApInvoiceStatus>;
  status_not?: Maybe<ApInvoiceStatus>;
  status_in?: Maybe<ApInvoiceStatus[] | ApInvoiceStatus>;
  status_not_in?: Maybe<ApInvoiceStatus[] | ApInvoiceStatus>;
  invoiceNumber?: Maybe<String>;
  invoiceNumber_not?: Maybe<String>;
  invoiceNumber_in?: Maybe<String[] | String>;
  invoiceNumber_not_in?: Maybe<String[] | String>;
  invoiceNumber_lt?: Maybe<String>;
  invoiceNumber_lte?: Maybe<String>;
  invoiceNumber_gt?: Maybe<String>;
  invoiceNumber_gte?: Maybe<String>;
  invoiceNumber_contains?: Maybe<String>;
  invoiceNumber_not_contains?: Maybe<String>;
  invoiceNumber_starts_with?: Maybe<String>;
  invoiceNumber_not_starts_with?: Maybe<String>;
  invoiceNumber_ends_with?: Maybe<String>;
  invoiceNumber_not_ends_with?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ApInvoiceWhereInput[] | ApInvoiceWhereInput>;
  OR?: Maybe<ApInvoiceWhereInput[] | ApInvoiceWhereInput>;
  NOT?: Maybe<ApInvoiceWhereInput[] | ApInvoiceWhereInput>;
}

export interface MeansTestedFeeUpdateOneInput {
  create?: Maybe<MeansTestedFeeCreateInput>;
  update?: Maybe<MeansTestedFeeUpdateDataInput>;
  upsert?: Maybe<MeansTestedFeeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MeansTestedFeeWhereUniqueInput>;
}

export type MainAccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MeansTestedFeeUpdateDataInput {
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneInput>;
}

export interface ProjectUpdateOneWithoutProjectServiceInput {
  create?: Maybe<ProjectCreateWithoutProjectServiceInput>;
  update?: Maybe<ProjectUpdateWithoutProjectServiceDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutProjectServiceInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface MeansTestedFeeUpsertNestedInput {
  update: MeansTestedFeeUpdateDataInput;
  create: MeansTestedFeeCreateInput;
}

export interface ProjectCreateWithoutProjectServiceInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneInput;
  customer?: Maybe<CustomerCreateOneInput>;
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export interface BasicDailyFeeUpdateOneInput {
  create?: Maybe<BasicDailyFeeCreateInput>;
  update?: Maybe<BasicDailyFeeUpdateDataInput>;
  upsert?: Maybe<BasicDailyFeeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BasicDailyFeeWhereUniqueInput>;
}

export type MeansTestedFeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BasicDailyFeeUpdateDataInput {
  level?: Maybe<LevelOfCare>;
  rate?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  rechargeable?: Maybe<Float>;
  company?: Maybe<CompanyUpdateOneInput>;
}

export interface PredictedSalesValueByCompanyUpdateInput {
  datePredictionRun?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface BasicDailyFeeUpsertNestedInput {
  update: BasicDailyFeeUpdateDataInput;
  create: BasicDailyFeeCreateInput;
}

export interface PredictedSalesQuantityOfItemsByCompanyUpdateManyMutationInput {
  datePredictionRun?: Maybe<DateTimeInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface CustomerUpdateManyMutationInput {
  description?: Maybe<String>;
  govNumber?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  billingFrequency?: Maybe<SupplierTermsOfPayment>;
}

export type NameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DiseaseCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface PoReceiptCreateInput {
  id?: Maybe<ID_Input>;
  receiptNumber?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderCreateOneInput>;
  receiptDate?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface DiseaseUpdateInput {
  name?: Maybe<String>;
}

export interface CompanyUpdateWithoutActivePlanDataInput {
  bankAccount?: Maybe<Json>;
  businessType?: Maybe<BusinessType>;
  country?: Maybe<Country>;
  govNumber?: Maybe<String>;
  currency?: Maybe<Currency>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  legalName?: Maybe<String>;
  logo?: Maybe<AttachmentUpdateOneInput>;
  name?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  timeSheetSettings?: Maybe<Json>;
  websiteURL?: Maybe<String>;
  addresses?: Maybe<AddressUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  companyMembers?: Maybe<CompanyMemberUpdateManyWithoutCompanyInput>;
  stripeCustomerId?: Maybe<String>;
}

export interface DiseaseUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CompanyMemberWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  role?: Maybe<CompanyMemberRole>;
  role_not?: Maybe<CompanyMemberRole>;
  role_in?: Maybe<CompanyMemberRole[] | CompanyMemberRole>;
  role_not_in?: Maybe<CompanyMemberRole[] | CompanyMemberRole>;
  status?: Maybe<CompanyMemberStatus>;
  status_not?: Maybe<CompanyMemberStatus>;
  status_in?: Maybe<CompanyMemberStatus[] | CompanyMemberStatus>;
  status_not_in?: Maybe<CompanyMemberStatus[] | CompanyMemberStatus>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyMemberWhereInput[] | CompanyMemberWhereInput>;
  OR?: Maybe<CompanyMemberWhereInput[] | CompanyMemberWhereInput>;
  NOT?: Maybe<CompanyMemberWhereInput[] | CompanyMemberWhereInput>;
}

export interface HILogCreateInput {
  id?: Maybe<ID_Input>;
  hpio?: Maybe<String>;
  hpii?: Maybe<String>;
  ihi?: Maybe<String>;
  timeWaitedForSalus?: Maybe<Int>;
  csp?: Maybe<String>;
  hiWebServiceUsed?: Maybe<String>;
  hiWebServiceVersion?: Maybe<String>;
  hiNumberStatus?: Maybe<HINumberStatus>;
  recordStatus?: Maybe<String>;
  salusResponse?: Maybe<SalusResponse>;
  failureMessage?: Maybe<String>;
}

export type PbsOrganisationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HILogUpdateInput {
  hpio?: Maybe<String>;
  hpii?: Maybe<String>;
  ihi?: Maybe<String>;
  timeWaitedForSalus?: Maybe<Int>;
  csp?: Maybe<String>;
  hiWebServiceUsed?: Maybe<String>;
  hiWebServiceVersion?: Maybe<String>;
  hiNumberStatus?: Maybe<HINumberStatus>;
  recordStatus?: Maybe<String>;
  salusResponse?: Maybe<SalusResponse>;
  failureMessage?: Maybe<String>;
}

export interface PbsTPPUpdateManyMutationInput {
  snomedCode?: Maybe<String>;
  clinicalPreferredTerm?: Maybe<String>;
  packSize?: Maybe<Int>;
  brandName?: Maybe<String>;
  exManufacturerPrice?: Maybe<Float>;
  pricingModel?: Maybe<PBSPricingModel>;
  mpp_id?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface HILogUpdateManyMutationInput {
  hpio?: Maybe<String>;
  hpii?: Maybe<String>;
  ihi?: Maybe<String>;
  timeWaitedForSalus?: Maybe<Int>;
  csp?: Maybe<String>;
  hiWebServiceUsed?: Maybe<String>;
  hiWebServiceVersion?: Maybe<String>;
  hiNumberStatus?: Maybe<HINumberStatus>;
  recordStatus?: Maybe<String>;
  salusResponse?: Maybe<SalusResponse>;
  failureMessage?: Maybe<String>;
}

export interface PbsOrganisationUpdateOneInput {
  create?: Maybe<PbsOrganisationCreateInput>;
  update?: Maybe<PbsOrganisationUpdateDataInput>;
  upsert?: Maybe<PbsOrganisationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PbsOrganisationWhereUniqueInput>;
}

export interface HealthcareProviderCreateInput {
  id?: Maybe<ID_Input>;
  occupation?: Maybe<String>;
  hpii?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  dateOfBirth?: Maybe<DateTimeInput>;
  emailAddress?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<AddressCreateOneInput>;
  company?: Maybe<CompanyCreateOneInput>;
  ahpraNumber?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PbsOrganisationCreateOneInput {
  create?: Maybe<PbsOrganisationCreateInput>;
  connect?: Maybe<PbsOrganisationWhereUniqueInput>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface PbsOrganisationUpdateInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  stateAddress?: Maybe<String>;
  postcode?: Maybe<String>;
  phone?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface HealthcareProviderUpdateInput {
  occupation?: Maybe<String>;
  hpii?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  dateOfBirth?: Maybe<DateTimeInput>;
  emailAddress?: Maybe<String>;
  gender?: Maybe<Gender>;
  address?: Maybe<AddressUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneInput>;
  ahpraNumber?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export type PoReceiptWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressUpdateOneInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface BasicDailyFeeUpsertWithWhereUniqueNestedInput {
  where: BasicDailyFeeWhereUniqueInput;
  update: BasicDailyFeeUpdateDataInput;
  create: BasicDailyFeeCreateInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface NameUpdateManyDataInput {
  name?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface HealthcareProviderUpdateManyMutationInput {
  occupation?: Maybe<String>;
  hpii?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  dateOfBirth?: Maybe<DateTimeInput>;
  emailAddress?: Maybe<String>;
  gender?: Maybe<Gender>;
  ahpraNumber?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface NameUpsertWithWhereUniqueNestedInput {
  where: NameWhereUniqueInput;
  update: NameUpdateDataInput;
  create: NameCreateInput;
}

export interface ImmunisationScheduleCreateInput {
  id?: Maybe<ID_Input>;
  ageNumber?: Maybe<Int>;
  agePeriod?: Maybe<PeriodUnit>;
  disease?: Maybe<DiseaseCreateOneInput>;
  vaccineBrand?: Maybe<VaccineBrandCreateOneInput>;
}

export interface PredictedSalesValueByCompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  datePredictionRun?: Maybe<DateTimeInput>;
  datePredictionRun_not?: Maybe<DateTimeInput>;
  datePredictionRun_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePredictionRun_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  datePredictionRun_lt?: Maybe<DateTimeInput>;
  datePredictionRun_lte?: Maybe<DateTimeInput>;
  datePredictionRun_gt?: Maybe<DateTimeInput>;
  datePredictionRun_gte?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyWhereInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedSalesValue_not?: Maybe<Float>;
  predictedSalesValue_in?: Maybe<Float[] | Float>;
  predictedSalesValue_not_in?: Maybe<Float[] | Float>;
  predictedSalesValue_lt?: Maybe<Float>;
  predictedSalesValue_lte?: Maybe<Float>;
  predictedSalesValue_gt?: Maybe<Float>;
  predictedSalesValue_gte?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
  predictedDate_not?: Maybe<DateTimeInput>;
  predictedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  predictedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  predictedDate_lt?: Maybe<DateTimeInput>;
  predictedDate_lte?: Maybe<DateTimeInput>;
  predictedDate_gt?: Maybe<DateTimeInput>;
  predictedDate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | PredictedSalesValueByCompanyWhereInput[]
    | PredictedSalesValueByCompanyWhereInput
  >;
  OR?: Maybe<
    | PredictedSalesValueByCompanyWhereInput[]
    | PredictedSalesValueByCompanyWhereInput
  >;
  NOT?: Maybe<
    | PredictedSalesValueByCompanyWhereInput[]
    | PredictedSalesValueByCompanyWhereInput
  >;
}

export interface DiseaseCreateOneInput {
  create?: Maybe<DiseaseCreateInput>;
  connect?: Maybe<DiseaseWhereUniqueInput>;
}

export interface NameCreateManyInput {
  create?: Maybe<NameCreateInput[] | NameCreateInput>;
  connect?: Maybe<NameWhereUniqueInput[] | NameWhereUniqueInput>;
}

export interface VaccineBrandCreateOneInput {
  create?: Maybe<VaccineBrandCreateInput>;
  connect?: Maybe<VaccineBrandWhereUniqueInput>;
}

export interface NameUpdateInput {
  name?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface VaccineBrandCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
}

export interface MedicareServiceUpdateInput {
  MBSScheduleFee?: Maybe<Float>;
  description?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ImmunisationScheduleUpdateInput {
  ageNumber?: Maybe<Int>;
  agePeriod?: Maybe<PeriodUnit>;
  disease?: Maybe<DiseaseUpdateOneInput>;
  vaccineBrand?: Maybe<VaccineBrandUpdateOneInput>;
}

export interface MeansTestedFeeUpdateInput {
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneInput>;
}

export interface DiseaseUpdateOneInput {
  create?: Maybe<DiseaseCreateInput>;
  update?: Maybe<DiseaseUpdateDataInput>;
  upsert?: Maybe<DiseaseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DiseaseWhereUniqueInput>;
}

export interface MeansTestLimitsCreateInput {
  id?: Maybe<ID_Input>;
  annual?: Maybe<Float>;
  lifetime?: Maybe<Float>;
  dateFrom?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
}

export interface DiseaseUpdateDataInput {
  name?: Maybe<String>;
}

export interface LedgerTransactionUpdateManyMutationInput {
  drcr?: Maybe<DrCr>;
  amount?: Maybe<Float>;
  currency?: Maybe<Currency>;
  date?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface DiseaseUpsertNestedInput {
  update: DiseaseUpdateDataInput;
  create: DiseaseCreateInput;
}

export interface MainAccountUpdateOneRequiredInput {
  create?: Maybe<MainAccountCreateInput>;
  update?: Maybe<MainAccountUpdateDataInput>;
  upsert?: Maybe<MainAccountUpsertNestedInput>;
  connect?: Maybe<MainAccountWhereUniqueInput>;
}

export interface VaccineBrandUpdateOneInput {
  create?: Maybe<VaccineBrandCreateInput>;
  update?: Maybe<VaccineBrandUpdateDataInput>;
  upsert?: Maybe<VaccineBrandUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VaccineBrandWhereUniqueInput>;
}

export interface SalesOrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer?: Maybe<CustomerWhereInput>;
  transactionDate?: Maybe<DateTimeInput>;
  transactionDate_not?: Maybe<DateTimeInput>;
  transactionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  transactionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  transactionDate_lt?: Maybe<DateTimeInput>;
  transactionDate_lte?: Maybe<DateTimeInput>;
  transactionDate_gt?: Maybe<DateTimeInput>;
  transactionDate_gte?: Maybe<DateTimeInput>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SalesOrderWhereInput[] | SalesOrderWhereInput>;
  OR?: Maybe<SalesOrderWhereInput[] | SalesOrderWhereInput>;
  NOT?: Maybe<SalesOrderWhereInput[] | SalesOrderWhereInput>;
}

export interface VaccineBrandUpdateDataInput {
  name?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface VaccineBrandUpsertNestedInput {
  update: VaccineBrandUpdateDataInput;
  create: VaccineBrandCreateInput;
}

export type CompanyMemberWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImmunisationScheduleUpdateManyMutationInput {
  ageNumber?: Maybe<Int>;
  agePeriod?: Maybe<PeriodUnit>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IntegrationCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneInput;
  data?: Maybe<Json>;
  type?: Maybe<IntegrationType>;
}

export interface PbsOrganisationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PbsOrganisationWhereInput>;
  AND?: Maybe<
    | PbsOrganisationSubscriptionWhereInput[]
    | PbsOrganisationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PbsOrganisationSubscriptionWhereInput[]
    | PbsOrganisationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PbsOrganisationSubscriptionWhereInput[]
    | PbsOrganisationSubscriptionWhereInput
  >;
}

export interface IntegrationUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  data?: Maybe<Json>;
  type?: Maybe<IntegrationType>;
}

export type HILogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IntegrationUpdateManyMutationInput {
  data?: Maybe<Json>;
  type?: Maybe<IntegrationType>;
}

export interface InvoiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvoiceWhereInput>;
  AND?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  OR?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
  NOT?: Maybe<InvoiceSubscriptionWhereInput[] | InvoiceSubscriptionWhereInput>;
}

export interface InventoryCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  inventoryModel?: Maybe<InventoryModel>;
  uom?: Maybe<UOM>;
  price?: Maybe<Float>;
  SellingPrice?: Maybe<Float>;
  Barcode?: Maybe<String>;
  Taxable?: Maybe<Boolean>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface HealthcareProviderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HealthcareProviderWhereInput>;
  AND?: Maybe<
    | HealthcareProviderSubscriptionWhereInput[]
    | HealthcareProviderSubscriptionWhereInput
  >;
  OR?: Maybe<
    | HealthcareProviderSubscriptionWhereInput[]
    | HealthcareProviderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | HealthcareProviderSubscriptionWhereInput[]
    | HealthcareProviderSubscriptionWhereInput
  >;
}

export interface InventoryUpdateInput {
  name?: Maybe<String>;
  inventoryModel?: Maybe<InventoryModel>;
  uom?: Maybe<UOM>;
  price?: Maybe<Float>;
  SellingPrice?: Maybe<Float>;
  Barcode?: Maybe<String>;
  Taxable?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface InventoryUpdateManyMutationInput {
  name?: Maybe<String>;
  inventoryModel?: Maybe<InventoryModel>;
  uom?: Maybe<UOM>;
  price?: Maybe<Float>;
  SellingPrice?: Maybe<Float>;
  Barcode?: Maybe<String>;
  Taxable?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AttachmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AttachmentWhereInput>;
  AND?: Maybe<
    AttachmentSubscriptionWhereInput[] | AttachmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    AttachmentSubscriptionWhereInput[] | AttachmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AttachmentSubscriptionWhereInput[] | AttachmentSubscriptionWhereInput
  >;
}

export interface InventoryOnHandCreateInput {
  id?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  item?: Maybe<InventoryCreateOneInput>;
  pbsDrug?: Maybe<String>;
  onHandQty?: Maybe<Int>;
  purchaseOrder?: Maybe<PurchaseOrderCreateOneInput>;
  warehouse?: Maybe<WareHouseCreateOneInput>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface WareHouseUpdateManyMutationInput {
  name?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface InventoryCreateOneInput {
  create?: Maybe<InventoryCreateInput>;
  connect?: Maybe<InventoryWhereUniqueInput>;
}

export interface WareHouseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<WareHouseWhereInput[] | WareHouseWhereInput>;
  OR?: Maybe<WareHouseWhereInput[] | WareHouseWhereInput>;
  NOT?: Maybe<WareHouseWhereInput[] | WareHouseWhereInput>;
}

export interface WareHouseCreateOneInput {
  create?: Maybe<WareHouseCreateInput>;
  connect?: Maybe<WareHouseWhereUniqueInput>;
}

export interface InvoiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  attachments_every?: Maybe<AttachmentWhereInput>;
  attachments_some?: Maybe<AttachmentWhereInput>;
  attachments_none?: Maybe<AttachmentWhereInput>;
  buyer?: Maybe<CustomerWhereInput>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  invoiceDate_not?: Maybe<DateTimeInput>;
  invoiceDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  invoiceDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  invoiceDate_lt?: Maybe<DateTimeInput>;
  invoiceDate_lte?: Maybe<DateTimeInput>;
  invoiceDate_gt?: Maybe<DateTimeInput>;
  invoiceDate_gte?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  dueDate_not?: Maybe<DateTimeInput>;
  dueDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dueDate_lt?: Maybe<DateTimeInput>;
  dueDate_lte?: Maybe<DateTimeInput>;
  dueDate_gt?: Maybe<DateTimeInput>;
  dueDate_gte?: Maybe<DateTimeInput>;
  preview?: Maybe<AttachmentWhereInput>;
  items_every?: Maybe<InvoiceItemEntryWhereInput>;
  items_some?: Maybe<InvoiceItemEntryWhereInput>;
  items_none?: Maybe<InvoiceItemEntryWhereInput>;
  seller?: Maybe<CompanyWhereInput>;
  status?: Maybe<InvoiceStatus>;
  status_not?: Maybe<InvoiceStatus>;
  status_in?: Maybe<InvoiceStatus[] | InvoiceStatus>;
  status_not_in?: Maybe<InvoiceStatus[] | InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  type_not?: Maybe<InvoiceType>;
  type_in?: Maybe<InvoiceType[] | InvoiceType>;
  type_not_in?: Maybe<InvoiceType[] | InvoiceType>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  OR?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
  NOT?: Maybe<InvoiceWhereInput[] | InvoiceWhereInput>;
}

export interface WareHouseCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  company: CompanyCreateOneInput;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface SessionUpdateInput {
  expires_at?: Maybe<DateTimeInput>;
  is_active?: Maybe<Boolean>;
  is_archived?: Maybe<Boolean>;
  is_deleted?: Maybe<Boolean>;
  signed_at?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface InventoryOnHandUpdateInput {
  date?: Maybe<DateTimeInput>;
  item?: Maybe<InventoryUpdateOneInput>;
  pbsDrug?: Maybe<String>;
  onHandQty?: Maybe<Int>;
  purchaseOrder?: Maybe<PurchaseOrderUpdateOneInput>;
  warehouse?: Maybe<WareHouseUpdateOneInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ServiceUpdateInput {
  billingType?: Maybe<ServiceBillingType>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  includeConsTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isTemplate?: Maybe<Boolean>;
  name?: Maybe<String>;
  timeBasedType?: Maybe<TimeBasedType>;
  totalAmount?: Maybe<Float>;
}

export interface InventoryUpdateOneInput {
  create?: Maybe<InventoryCreateInput>;
  update?: Maybe<InventoryUpdateDataInput>;
  upsert?: Maybe<InventoryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<InventoryWhereUniqueInput>;
}

export type AssetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InventoryUpdateDataInput {
  name?: Maybe<String>;
  inventoryModel?: Maybe<InventoryModel>;
  uom?: Maybe<UOM>;
  price?: Maybe<Float>;
  SellingPrice?: Maybe<Float>;
  Barcode?: Maybe<String>;
  Taxable?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PoReceiptUpdateOneInput {
  create?: Maybe<PoReceiptCreateInput>;
  update?: Maybe<PoReceiptUpdateDataInput>;
  upsert?: Maybe<PoReceiptUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PoReceiptWhereUniqueInput>;
}

export interface InventoryUpsertNestedInput {
  update: InventoryUpdateDataInput;
  create: InventoryCreateInput;
}

export interface ProjectServiceRuleUpdateManyMutationInput {
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export interface WareHouseUpdateOneInput {
  create?: Maybe<WareHouseCreateInput>;
  update?: Maybe<WareHouseUpdateDataInput>;
  upsert?: Maybe<WareHouseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WareHouseWhereUniqueInput>;
}

export interface PurchaseOrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  pbsOrganisation?: Maybe<String>;
  pbsOrganisation_not?: Maybe<String>;
  pbsOrganisation_in?: Maybe<String[] | String>;
  pbsOrganisation_not_in?: Maybe<String[] | String>;
  pbsOrganisation_lt?: Maybe<String>;
  pbsOrganisation_lte?: Maybe<String>;
  pbsOrganisation_gt?: Maybe<String>;
  pbsOrganisation_gte?: Maybe<String>;
  pbsOrganisation_contains?: Maybe<String>;
  pbsOrganisation_not_contains?: Maybe<String>;
  pbsOrganisation_starts_with?: Maybe<String>;
  pbsOrganisation_not_starts_with?: Maybe<String>;
  pbsOrganisation_ends_with?: Maybe<String>;
  pbsOrganisation_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  orderer?: Maybe<UserWhereInput>;
  status?: Maybe<PoStatus>;
  status_not?: Maybe<PoStatus>;
  status_in?: Maybe<PoStatus[] | PoStatus>;
  status_not_in?: Maybe<PoStatus[] | PoStatus>;
  supplier?: Maybe<SupplierWhereInput>;
  isPbsPO?: Maybe<Boolean>;
  isPbsPO_not?: Maybe<Boolean>;
  poNumber?: Maybe<Int>;
  poNumber_not?: Maybe<Int>;
  poNumber_in?: Maybe<Int[] | Int>;
  poNumber_not_in?: Maybe<Int[] | Int>;
  poNumber_lt?: Maybe<Int>;
  poNumber_lte?: Maybe<Int>;
  poNumber_gt?: Maybe<Int>;
  poNumber_gte?: Maybe<Int>;
  preview?: Maybe<AttachmentWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseOrderWhereInput[] | PurchaseOrderWhereInput>;
  OR?: Maybe<PurchaseOrderWhereInput[] | PurchaseOrderWhereInput>;
  NOT?: Maybe<PurchaseOrderWhereInput[] | PurchaseOrderWhereInput>;
}

export interface WareHouseUpdateDataInput {
  name?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectUpsertWithoutProjectServiceInput {
  update: ProjectUpdateWithoutProjectServiceDataInput;
  create: ProjectCreateWithoutProjectServiceInput;
}

export interface WareHouseUpsertNestedInput {
  update: WareHouseUpdateDataInput;
  create: WareHouseCreateInput;
}

export interface ProjectServiceCreateInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  project?: Maybe<ProjectCreateOneWithoutProjectServiceInput>;
  rules?: Maybe<ProjectServiceRuleCreateManyWithoutProjectServiceInput>;
  service?: Maybe<ServiceCreateOneInput>;
}

export interface InventoryOnHandUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  pbsDrug?: Maybe<String>;
  onHandQty?: Maybe<Int>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PredictedSalesValueByCompanyCreateInput {
  id?: Maybe<ID_Input>;
  datePredictionRun?: Maybe<DateTimeInput>;
  company: CompanyCreateOneInput;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface InvoiceCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  attachments?: Maybe<AttachmentCreateManyInput>;
  buyer?: Maybe<CustomerCreateOneInput>;
  number?: Maybe<Int>;
  description?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  preview?: Maybe<AttachmentCreateOneInput>;
  items?: Maybe<InvoiceItemEntryCreateManyWithoutInvoiceInput>;
  seller: CompanyCreateOneInput;
  status?: Maybe<InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  total?: Maybe<Float>;
}

export interface NameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  isPrimary?: Maybe<Boolean>;
  isPrimary_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NameWhereInput[] | NameWhereInput>;
  OR?: Maybe<NameWhereInput[] | NameWhereInput>;
  NOT?: Maybe<NameWhereInput[] | NameWhereInput>;
}

export interface AttachmentCreateManyInput {
  create?: Maybe<AttachmentCreateInput[] | AttachmentCreateInput>;
  connect?: Maybe<AttachmentWhereUniqueInput[] | AttachmentWhereUniqueInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  businessType?: Maybe<BusinessType>;
  businessType_not?: Maybe<BusinessType>;
  businessType_in?: Maybe<BusinessType[] | BusinessType>;
  businessType_not_in?: Maybe<BusinessType[] | BusinessType>;
  country?: Maybe<Country>;
  country_not?: Maybe<Country>;
  country_in?: Maybe<Country[] | Country>;
  country_not_in?: Maybe<Country[] | Country>;
  govNumber?: Maybe<String>;
  govNumber_not?: Maybe<String>;
  govNumber_in?: Maybe<String[] | String>;
  govNumber_not_in?: Maybe<String[] | String>;
  govNumber_lt?: Maybe<String>;
  govNumber_lte?: Maybe<String>;
  govNumber_gt?: Maybe<String>;
  govNumber_gte?: Maybe<String>;
  govNumber_contains?: Maybe<String>;
  govNumber_not_contains?: Maybe<String>;
  govNumber_starts_with?: Maybe<String>;
  govNumber_not_starts_with?: Maybe<String>;
  govNumber_ends_with?: Maybe<String>;
  govNumber_not_ends_with?: Maybe<String>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  HPIO?: Maybe<String>;
  HPIO_not?: Maybe<String>;
  HPIO_in?: Maybe<String[] | String>;
  HPIO_not_in?: Maybe<String[] | String>;
  HPIO_lt?: Maybe<String>;
  HPIO_lte?: Maybe<String>;
  HPIO_gt?: Maybe<String>;
  HPIO_gte?: Maybe<String>;
  HPIO_contains?: Maybe<String>;
  HPIO_not_contains?: Maybe<String>;
  HPIO_starts_with?: Maybe<String>;
  HPIO_not_starts_with?: Maybe<String>;
  HPIO_ends_with?: Maybe<String>;
  HPIO_not_ends_with?: Maybe<String>;
  legalName?: Maybe<String>;
  legalName_not?: Maybe<String>;
  legalName_in?: Maybe<String[] | String>;
  legalName_not_in?: Maybe<String[] | String>;
  legalName_lt?: Maybe<String>;
  legalName_lte?: Maybe<String>;
  legalName_gt?: Maybe<String>;
  legalName_gte?: Maybe<String>;
  legalName_contains?: Maybe<String>;
  legalName_not_contains?: Maybe<String>;
  legalName_starts_with?: Maybe<String>;
  legalName_not_starts_with?: Maybe<String>;
  legalName_ends_with?: Maybe<String>;
  legalName_not_ends_with?: Maybe<String>;
  logo?: Maybe<AttachmentWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  salesTax_not?: Maybe<Boolean>;
  websiteURL?: Maybe<String>;
  websiteURL_not?: Maybe<String>;
  websiteURL_in?: Maybe<String[] | String>;
  websiteURL_not_in?: Maybe<String[] | String>;
  websiteURL_lt?: Maybe<String>;
  websiteURL_lte?: Maybe<String>;
  websiteURL_gt?: Maybe<String>;
  websiteURL_gte?: Maybe<String>;
  websiteURL_contains?: Maybe<String>;
  websiteURL_not_contains?: Maybe<String>;
  websiteURL_starts_with?: Maybe<String>;
  websiteURL_not_starts_with?: Maybe<String>;
  websiteURL_ends_with?: Maybe<String>;
  websiteURL_not_ends_with?: Maybe<String>;
  addresses_every?: Maybe<AddressWhereInput>;
  addresses_some?: Maybe<AddressWhereInput>;
  addresses_none?: Maybe<AddressWhereInput>;
  contacts_every?: Maybe<ContactWhereInput>;
  contacts_some?: Maybe<ContactWhereInput>;
  contacts_none?: Maybe<ContactWhereInput>;
  companyMembers_every?: Maybe<CompanyMemberWhereInput>;
  companyMembers_some?: Maybe<CompanyMemberWhereInput>;
  companyMembers_none?: Maybe<CompanyMemberWhereInput>;
  activePlan?: Maybe<PlanWhereInput>;
  stripeCustomerId?: Maybe<String>;
  stripeCustomerId_not?: Maybe<String>;
  stripeCustomerId_in?: Maybe<String[] | String>;
  stripeCustomerId_not_in?: Maybe<String[] | String>;
  stripeCustomerId_lt?: Maybe<String>;
  stripeCustomerId_lte?: Maybe<String>;
  stripeCustomerId_gt?: Maybe<String>;
  stripeCustomerId_gte?: Maybe<String>;
  stripeCustomerId_contains?: Maybe<String>;
  stripeCustomerId_not_contains?: Maybe<String>;
  stripeCustomerId_starts_with?: Maybe<String>;
  stripeCustomerId_not_starts_with?: Maybe<String>;
  stripeCustomerId_ends_with?: Maybe<String>;
  stripeCustomerId_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface PbsOrganisationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  stateAddress?: Maybe<String>;
  stateAddress_not?: Maybe<String>;
  stateAddress_in?: Maybe<String[] | String>;
  stateAddress_not_in?: Maybe<String[] | String>;
  stateAddress_lt?: Maybe<String>;
  stateAddress_lte?: Maybe<String>;
  stateAddress_gt?: Maybe<String>;
  stateAddress_gte?: Maybe<String>;
  stateAddress_contains?: Maybe<String>;
  stateAddress_not_contains?: Maybe<String>;
  stateAddress_starts_with?: Maybe<String>;
  stateAddress_not_starts_with?: Maybe<String>;
  stateAddress_ends_with?: Maybe<String>;
  stateAddress_not_ends_with?: Maybe<String>;
  postcode?: Maybe<String>;
  postcode_not?: Maybe<String>;
  postcode_in?: Maybe<String[] | String>;
  postcode_not_in?: Maybe<String[] | String>;
  postcode_lt?: Maybe<String>;
  postcode_lte?: Maybe<String>;
  postcode_gt?: Maybe<String>;
  postcode_gte?: Maybe<String>;
  postcode_contains?: Maybe<String>;
  postcode_not_contains?: Maybe<String>;
  postcode_starts_with?: Maybe<String>;
  postcode_not_starts_with?: Maybe<String>;
  postcode_ends_with?: Maybe<String>;
  postcode_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveFrom_not?: Maybe<DateTimeInput>;
  effectiveFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveFrom_lt?: Maybe<DateTimeInput>;
  effectiveFrom_lte?: Maybe<DateTimeInput>;
  effectiveFrom_gt?: Maybe<DateTimeInput>;
  effectiveFrom_gte?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  effectiveTo_not?: Maybe<DateTimeInput>;
  effectiveTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveTo_lt?: Maybe<DateTimeInput>;
  effectiveTo_lte?: Maybe<DateTimeInput>;
  effectiveTo_gt?: Maybe<DateTimeInput>;
  effectiveTo_gte?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PbsOrganisationWhereInput[] | PbsOrganisationWhereInput>;
  OR?: Maybe<PbsOrganisationWhereInput[] | PbsOrganisationWhereInput>;
  NOT?: Maybe<PbsOrganisationWhereInput[] | PbsOrganisationWhereInput>;
}

export interface InvoiceItemEntryCreateManyWithoutInvoiceInput {
  create?: Maybe<
    | InvoiceItemEntryCreateWithoutInvoiceInput[]
    | InvoiceItemEntryCreateWithoutInvoiceInput
  >;
  connect?: Maybe<
    InvoiceItemEntryWhereUniqueInput[] | InvoiceItemEntryWhereUniqueInput
  >;
}

export interface PbsTPPWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  snomedCode?: Maybe<String>;
  snomedCode_not?: Maybe<String>;
  snomedCode_in?: Maybe<String[] | String>;
  snomedCode_not_in?: Maybe<String[] | String>;
  snomedCode_lt?: Maybe<String>;
  snomedCode_lte?: Maybe<String>;
  snomedCode_gt?: Maybe<String>;
  snomedCode_gte?: Maybe<String>;
  snomedCode_contains?: Maybe<String>;
  snomedCode_not_contains?: Maybe<String>;
  snomedCode_starts_with?: Maybe<String>;
  snomedCode_not_starts_with?: Maybe<String>;
  snomedCode_ends_with?: Maybe<String>;
  snomedCode_not_ends_with?: Maybe<String>;
  clinicalPreferredTerm?: Maybe<String>;
  clinicalPreferredTerm_not?: Maybe<String>;
  clinicalPreferredTerm_in?: Maybe<String[] | String>;
  clinicalPreferredTerm_not_in?: Maybe<String[] | String>;
  clinicalPreferredTerm_lt?: Maybe<String>;
  clinicalPreferredTerm_lte?: Maybe<String>;
  clinicalPreferredTerm_gt?: Maybe<String>;
  clinicalPreferredTerm_gte?: Maybe<String>;
  clinicalPreferredTerm_contains?: Maybe<String>;
  clinicalPreferredTerm_not_contains?: Maybe<String>;
  clinicalPreferredTerm_starts_with?: Maybe<String>;
  clinicalPreferredTerm_not_starts_with?: Maybe<String>;
  clinicalPreferredTerm_ends_with?: Maybe<String>;
  clinicalPreferredTerm_not_ends_with?: Maybe<String>;
  packSize?: Maybe<Int>;
  packSize_not?: Maybe<Int>;
  packSize_in?: Maybe<Int[] | Int>;
  packSize_not_in?: Maybe<Int[] | Int>;
  packSize_lt?: Maybe<Int>;
  packSize_lte?: Maybe<Int>;
  packSize_gt?: Maybe<Int>;
  packSize_gte?: Maybe<Int>;
  brandName?: Maybe<String>;
  brandName_not?: Maybe<String>;
  brandName_in?: Maybe<String[] | String>;
  brandName_not_in?: Maybe<String[] | String>;
  brandName_lt?: Maybe<String>;
  brandName_lte?: Maybe<String>;
  brandName_gt?: Maybe<String>;
  brandName_gte?: Maybe<String>;
  brandName_contains?: Maybe<String>;
  brandName_not_contains?: Maybe<String>;
  brandName_starts_with?: Maybe<String>;
  brandName_not_starts_with?: Maybe<String>;
  brandName_ends_with?: Maybe<String>;
  brandName_not_ends_with?: Maybe<String>;
  exManufacturerPrice?: Maybe<Float>;
  exManufacturerPrice_not?: Maybe<Float>;
  exManufacturerPrice_in?: Maybe<Float[] | Float>;
  exManufacturerPrice_not_in?: Maybe<Float[] | Float>;
  exManufacturerPrice_lt?: Maybe<Float>;
  exManufacturerPrice_lte?: Maybe<Float>;
  exManufacturerPrice_gt?: Maybe<Float>;
  exManufacturerPrice_gte?: Maybe<Float>;
  pricingModel?: Maybe<PBSPricingModel>;
  pricingModel_not?: Maybe<PBSPricingModel>;
  pricingModel_in?: Maybe<PBSPricingModel[] | PBSPricingModel>;
  pricingModel_not_in?: Maybe<PBSPricingModel[] | PBSPricingModel>;
  mpp_id?: Maybe<String>;
  mpp_id_not?: Maybe<String>;
  mpp_id_in?: Maybe<String[] | String>;
  mpp_id_not_in?: Maybe<String[] | String>;
  mpp_id_lt?: Maybe<String>;
  mpp_id_lte?: Maybe<String>;
  mpp_id_gt?: Maybe<String>;
  mpp_id_gte?: Maybe<String>;
  mpp_id_contains?: Maybe<String>;
  mpp_id_not_contains?: Maybe<String>;
  mpp_id_starts_with?: Maybe<String>;
  mpp_id_not_starts_with?: Maybe<String>;
  mpp_id_ends_with?: Maybe<String>;
  mpp_id_not_ends_with?: Maybe<String>;
  organisation_id?: Maybe<PbsOrganisationWhereInput>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveFrom_not?: Maybe<DateTimeInput>;
  effectiveFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveFrom_lt?: Maybe<DateTimeInput>;
  effectiveFrom_lte?: Maybe<DateTimeInput>;
  effectiveFrom_gt?: Maybe<DateTimeInput>;
  effectiveFrom_gte?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  effectiveTo_not?: Maybe<DateTimeInput>;
  effectiveTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  effectiveTo_lt?: Maybe<DateTimeInput>;
  effectiveTo_lte?: Maybe<DateTimeInput>;
  effectiveTo_gt?: Maybe<DateTimeInput>;
  effectiveTo_gte?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PbsTPPWhereInput[] | PbsTPPWhereInput>;
  OR?: Maybe<PbsTPPWhereInput[] | PbsTPPWhereInput>;
  NOT?: Maybe<PbsTPPWhereInput[] | PbsTPPWhereInput>;
}

export interface InvoiceItemEntryCreateWithoutInvoiceInput {
  id?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
  project?: Maybe<ProjectCreateOneInput>;
  service?: Maybe<ServiceCreateOneInput>;
  timeSheetEntry?: Maybe<TimeSheetEntryCreateOneInput>;
  timeSheet?: Maybe<TimeSheetCreateOneInput>;
}

export interface PatientUpdateManyMutationInput {
  title?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  dateOfBirth?: Maybe<DateTimeInput>;
  gender?: Maybe<Gender>;
  dvaCardType?: Maybe<DVACardType>;
  aboriginalStatus?: Maybe<AboriginalStatus>;
  pensionerConcession?: Maybe<String>;
  commonwealthSeniors?: Maybe<String>;
  healthcareConcession?: Maybe<String>;
  safetyNetConcession?: Maybe<Float>;
  medicareNumber?: Maybe<String>;
  DVA?: Maybe<String>;
  potentialDuplicate?: Maybe<Boolean>;
  oneName?: Maybe<Boolean>;
  ihi?: Maybe<String>;
  ihiValidatedDate?: Maybe<DateTimeInput>;
  noOfBirths?: Maybe<Int>;
  deceasedDate?: Maybe<DateTimeInput>;
  levelOfCare?: Maybe<LevelOfCare>;
  dateEnteredAgedCare?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectCreateOneInput {
  create?: Maybe<ProjectCreateInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface BasicDailyFeeUpdateManyInput {
  create?: Maybe<BasicDailyFeeCreateInput[] | BasicDailyFeeCreateInput>;
  update?: Maybe<
    | BasicDailyFeeUpdateWithWhereUniqueNestedInput[]
    | BasicDailyFeeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BasicDailyFeeUpsertWithWhereUniqueNestedInput[]
    | BasicDailyFeeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    BasicDailyFeeWhereUniqueInput[] | BasicDailyFeeWhereUniqueInput
  >;
  connect?: Maybe<
    BasicDailyFeeWhereUniqueInput[] | BasicDailyFeeWhereUniqueInput
  >;
  set?: Maybe<BasicDailyFeeWhereUniqueInput[] | BasicDailyFeeWhereUniqueInput>;
  disconnect?: Maybe<
    BasicDailyFeeWhereUniqueInput[] | BasicDailyFeeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    BasicDailyFeeScalarWhereInput[] | BasicDailyFeeScalarWhereInput
  >;
  updateMany?: Maybe<
    | BasicDailyFeeUpdateManyWithWhereNestedInput[]
    | BasicDailyFeeUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneInput;
  customer?: Maybe<CustomerCreateOneInput>;
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  projectService?: Maybe<ProjectServiceCreateManyWithoutProjectInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export type PredictedSalesValueByCompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceCreateManyWithoutProjectInput {
  create?: Maybe<
    | ProjectServiceCreateWithoutProjectInput[]
    | ProjectServiceCreateWithoutProjectInput
  >;
  connect?: Maybe<
    ProjectServiceWhereUniqueInput[] | ProjectServiceWhereUniqueInput
  >;
}

export interface PatientCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  names?: Maybe<NameCreateManyInput>;
  address?: Maybe<AddressCreateOneInput>;
  birthAddress?: Maybe<AddressCreateOneInput>;
  dateOfBirth?: Maybe<DateTimeInput>;
  customer?: Maybe<CustomerCreateOneInput>;
  gender?: Maybe<Gender>;
  dvaCardType?: Maybe<DVACardType>;
  aboriginalStatus?: Maybe<AboriginalStatus>;
  pensionerConcession?: Maybe<String>;
  commonwealthSeniors?: Maybe<String>;
  healthcareConcession?: Maybe<String>;
  safetyNetConcession?: Maybe<Float>;
  medicareNumber?: Maybe<String>;
  DVA?: Maybe<String>;
  potentialDuplicate?: Maybe<Boolean>;
  oneName?: Maybe<Boolean>;
  ihi?: Maybe<String>;
  ihiValidatedDate?: Maybe<DateTimeInput>;
  noOfBirths?: Maybe<Int>;
  deceasedDate?: Maybe<DateTimeInput>;
  basicDailyFee?: Maybe<BasicDailyFeeCreateManyInput>;
  levelOfCare?: Maybe<LevelOfCare>;
  dateEnteredAgedCare?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyCreateOneInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectServiceCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  rules?: Maybe<ProjectServiceRuleCreateManyWithoutProjectServiceInput>;
  service?: Maybe<ServiceCreateOneInput>;
}

export type ProjectServiceRuleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceRuleCreateManyWithoutProjectServiceInput {
  create?: Maybe<
    | ProjectServiceRuleCreateWithoutProjectServiceInput[]
    | ProjectServiceRuleCreateWithoutProjectServiceInput
  >;
  connect?: Maybe<
    ProjectServiceRuleWhereUniqueInput[] | ProjectServiceRuleWhereUniqueInput
  >;
}

export interface MainAccountUpdateInput {
  code?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<MainAccountType>;
  ConsTaxFree?: Maybe<Boolean>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectServiceRuleCreateWithoutProjectServiceInput {
  id?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export type SalesOrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ServiceCreateOneInput {
  create?: Maybe<ServiceCreateInput>;
  connect?: Maybe<ServiceWhereUniqueInput>;
}

export interface SupplierSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SupplierWhereInput>;
  AND?: Maybe<
    SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput
  >;
  OR?: Maybe<SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput>;
  NOT?: Maybe<
    SupplierSubscriptionWhereInput[] | SupplierSubscriptionWhereInput
  >;
}

export interface ServiceCreateInput {
  id?: Maybe<ID_Input>;
  billingType: ServiceBillingType;
  company: CompanyCreateOneInput;
  includeConsTax: Boolean;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isTemplate?: Maybe<Boolean>;
  name: String;
  timeBasedType?: Maybe<TimeBasedType>;
  totalAmount: Float;
}

export interface MeansTestedFeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  dateFrom?: Maybe<DateTimeInput>;
  dateFrom_not?: Maybe<DateTimeInput>;
  dateFrom_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateFrom_lt?: Maybe<DateTimeInput>;
  dateFrom_lte?: Maybe<DateTimeInput>;
  dateFrom_gt?: Maybe<DateTimeInput>;
  dateFrom_gte?: Maybe<DateTimeInput>;
  dateTo?: Maybe<DateTimeInput>;
  dateTo_not?: Maybe<DateTimeInput>;
  dateTo_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateTo_lt?: Maybe<DateTimeInput>;
  dateTo_lte?: Maybe<DateTimeInput>;
  dateTo_gt?: Maybe<DateTimeInput>;
  dateTo_gte?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<MeansTestedFeeWhereInput[] | MeansTestedFeeWhereInput>;
  OR?: Maybe<MeansTestedFeeWhereInput[] | MeansTestedFeeWhereInput>;
  NOT?: Maybe<MeansTestedFeeWhereInput[] | MeansTestedFeeWhereInput>;
}

export interface TimeSheetEntryCreateOneInput {
  create?: Maybe<TimeSheetEntryCreateInput>;
  connect?: Maybe<TimeSheetEntryWhereUniqueInput>;
}

export interface HILogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  hpio?: Maybe<String>;
  hpio_not?: Maybe<String>;
  hpio_in?: Maybe<String[] | String>;
  hpio_not_in?: Maybe<String[] | String>;
  hpio_lt?: Maybe<String>;
  hpio_lte?: Maybe<String>;
  hpio_gt?: Maybe<String>;
  hpio_gte?: Maybe<String>;
  hpio_contains?: Maybe<String>;
  hpio_not_contains?: Maybe<String>;
  hpio_starts_with?: Maybe<String>;
  hpio_not_starts_with?: Maybe<String>;
  hpio_ends_with?: Maybe<String>;
  hpio_not_ends_with?: Maybe<String>;
  hpii?: Maybe<String>;
  hpii_not?: Maybe<String>;
  hpii_in?: Maybe<String[] | String>;
  hpii_not_in?: Maybe<String[] | String>;
  hpii_lt?: Maybe<String>;
  hpii_lte?: Maybe<String>;
  hpii_gt?: Maybe<String>;
  hpii_gte?: Maybe<String>;
  hpii_contains?: Maybe<String>;
  hpii_not_contains?: Maybe<String>;
  hpii_starts_with?: Maybe<String>;
  hpii_not_starts_with?: Maybe<String>;
  hpii_ends_with?: Maybe<String>;
  hpii_not_ends_with?: Maybe<String>;
  ihi?: Maybe<String>;
  ihi_not?: Maybe<String>;
  ihi_in?: Maybe<String[] | String>;
  ihi_not_in?: Maybe<String[] | String>;
  ihi_lt?: Maybe<String>;
  ihi_lte?: Maybe<String>;
  ihi_gt?: Maybe<String>;
  ihi_gte?: Maybe<String>;
  ihi_contains?: Maybe<String>;
  ihi_not_contains?: Maybe<String>;
  ihi_starts_with?: Maybe<String>;
  ihi_not_starts_with?: Maybe<String>;
  ihi_ends_with?: Maybe<String>;
  ihi_not_ends_with?: Maybe<String>;
  timeWaitedForSalus?: Maybe<Int>;
  timeWaitedForSalus_not?: Maybe<Int>;
  timeWaitedForSalus_in?: Maybe<Int[] | Int>;
  timeWaitedForSalus_not_in?: Maybe<Int[] | Int>;
  timeWaitedForSalus_lt?: Maybe<Int>;
  timeWaitedForSalus_lte?: Maybe<Int>;
  timeWaitedForSalus_gt?: Maybe<Int>;
  timeWaitedForSalus_gte?: Maybe<Int>;
  csp?: Maybe<String>;
  csp_not?: Maybe<String>;
  csp_in?: Maybe<String[] | String>;
  csp_not_in?: Maybe<String[] | String>;
  csp_lt?: Maybe<String>;
  csp_lte?: Maybe<String>;
  csp_gt?: Maybe<String>;
  csp_gte?: Maybe<String>;
  csp_contains?: Maybe<String>;
  csp_not_contains?: Maybe<String>;
  csp_starts_with?: Maybe<String>;
  csp_not_starts_with?: Maybe<String>;
  csp_ends_with?: Maybe<String>;
  csp_not_ends_with?: Maybe<String>;
  hiWebServiceUsed?: Maybe<String>;
  hiWebServiceUsed_not?: Maybe<String>;
  hiWebServiceUsed_in?: Maybe<String[] | String>;
  hiWebServiceUsed_not_in?: Maybe<String[] | String>;
  hiWebServiceUsed_lt?: Maybe<String>;
  hiWebServiceUsed_lte?: Maybe<String>;
  hiWebServiceUsed_gt?: Maybe<String>;
  hiWebServiceUsed_gte?: Maybe<String>;
  hiWebServiceUsed_contains?: Maybe<String>;
  hiWebServiceUsed_not_contains?: Maybe<String>;
  hiWebServiceUsed_starts_with?: Maybe<String>;
  hiWebServiceUsed_not_starts_with?: Maybe<String>;
  hiWebServiceUsed_ends_with?: Maybe<String>;
  hiWebServiceUsed_not_ends_with?: Maybe<String>;
  hiWebServiceVersion?: Maybe<String>;
  hiWebServiceVersion_not?: Maybe<String>;
  hiWebServiceVersion_in?: Maybe<String[] | String>;
  hiWebServiceVersion_not_in?: Maybe<String[] | String>;
  hiWebServiceVersion_lt?: Maybe<String>;
  hiWebServiceVersion_lte?: Maybe<String>;
  hiWebServiceVersion_gt?: Maybe<String>;
  hiWebServiceVersion_gte?: Maybe<String>;
  hiWebServiceVersion_contains?: Maybe<String>;
  hiWebServiceVersion_not_contains?: Maybe<String>;
  hiWebServiceVersion_starts_with?: Maybe<String>;
  hiWebServiceVersion_not_starts_with?: Maybe<String>;
  hiWebServiceVersion_ends_with?: Maybe<String>;
  hiWebServiceVersion_not_ends_with?: Maybe<String>;
  hiNumberStatus?: Maybe<HINumberStatus>;
  hiNumberStatus_not?: Maybe<HINumberStatus>;
  hiNumberStatus_in?: Maybe<HINumberStatus[] | HINumberStatus>;
  hiNumberStatus_not_in?: Maybe<HINumberStatus[] | HINumberStatus>;
  recordStatus?: Maybe<String>;
  recordStatus_not?: Maybe<String>;
  recordStatus_in?: Maybe<String[] | String>;
  recordStatus_not_in?: Maybe<String[] | String>;
  recordStatus_lt?: Maybe<String>;
  recordStatus_lte?: Maybe<String>;
  recordStatus_gt?: Maybe<String>;
  recordStatus_gte?: Maybe<String>;
  recordStatus_contains?: Maybe<String>;
  recordStatus_not_contains?: Maybe<String>;
  recordStatus_starts_with?: Maybe<String>;
  recordStatus_not_starts_with?: Maybe<String>;
  recordStatus_ends_with?: Maybe<String>;
  recordStatus_not_ends_with?: Maybe<String>;
  salusResponse?: Maybe<SalusResponse>;
  salusResponse_not?: Maybe<SalusResponse>;
  salusResponse_in?: Maybe<SalusResponse[] | SalusResponse>;
  salusResponse_not_in?: Maybe<SalusResponse[] | SalusResponse>;
  failureMessage?: Maybe<String>;
  failureMessage_not?: Maybe<String>;
  failureMessage_in?: Maybe<String[] | String>;
  failureMessage_not_in?: Maybe<String[] | String>;
  failureMessage_lt?: Maybe<String>;
  failureMessage_lte?: Maybe<String>;
  failureMessage_gt?: Maybe<String>;
  failureMessage_gte?: Maybe<String>;
  failureMessage_contains?: Maybe<String>;
  failureMessage_not_contains?: Maybe<String>;
  failureMessage_starts_with?: Maybe<String>;
  failureMessage_not_starts_with?: Maybe<String>;
  failureMessage_ends_with?: Maybe<String>;
  failureMessage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HILogWhereInput[] | HILogWhereInput>;
  OR?: Maybe<HILogWhereInput[] | HILogWhereInput>;
  NOT?: Maybe<HILogWhereInput[] | HILogWhereInput>;
}

export interface TimeSheetEntryCreateInput {
  id?: Maybe<ID_Input>;
  customer?: Maybe<CustomerCreateOneInput>;
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  project?: Maybe<ProjectCreateOneInput>;
  service?: Maybe<ServiceCreateOneInput>;
  timeSheet?: Maybe<TimeSheetCreateOneWithoutTimeSheetEntriesInput>;
}

export interface DiseaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DiseaseWhereInput>;
  AND?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
  OR?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
  NOT?: Maybe<DiseaseSubscriptionWhereInput[] | DiseaseSubscriptionWhereInput>;
}

export interface TimeSheetCreateOneWithoutTimeSheetEntriesInput {
  create?: Maybe<TimeSheetCreateWithoutTimeSheetEntriesInput>;
  connect?: Maybe<TimeSheetWhereUniqueInput>;
}

export interface ApInvoiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApInvoiceWhereInput>;
  AND?: Maybe<
    ApInvoiceSubscriptionWhereInput[] | ApInvoiceSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApInvoiceSubscriptionWhereInput[] | ApInvoiceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApInvoiceSubscriptionWhereInput[] | ApInvoiceSubscriptionWhereInput
  >;
}

export interface TimeSheetCreateWithoutTimeSheetEntriesInput {
  id?: Maybe<ID_Input>;
  attachments?: Maybe<AttachmentCreateManyInput>;
  company: CompanyCreateOneInput;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  preview?: Maybe<AttachmentCreateOneInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  user?: Maybe<UserCreateOneInput>;
}

export interface TimeSheetUpdateInput {
  attachments?: Maybe<AttachmentUpdateManyInput>;
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  timeSheetEntries?: Maybe<TimeSheetEntryUpdateManyWithoutTimeSheetInput>;
  user?: Maybe<UserUpdateOneInput>;
}

export interface TimeSheetCreateOneInput {
  create?: Maybe<TimeSheetCreateInput>;
  connect?: Maybe<TimeSheetWhereUniqueInput>;
}

export interface TimeSheetWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  attachments_every?: Maybe<AttachmentWhereInput>;
  attachments_some?: Maybe<AttachmentWhereInput>;
  attachments_none?: Maybe<AttachmentWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  endsAt?: Maybe<DateTimeInput>;
  endsAt_not?: Maybe<DateTimeInput>;
  endsAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endsAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endsAt_lt?: Maybe<DateTimeInput>;
  endsAt_lte?: Maybe<DateTimeInput>;
  endsAt_gt?: Maybe<DateTimeInput>;
  endsAt_gte?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  preview?: Maybe<AttachmentWhereInput>;
  startsAt?: Maybe<DateTimeInput>;
  startsAt_not?: Maybe<DateTimeInput>;
  startsAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startsAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startsAt_lt?: Maybe<DateTimeInput>;
  startsAt_lte?: Maybe<DateTimeInput>;
  startsAt_gt?: Maybe<DateTimeInput>;
  startsAt_gte?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  status_not?: Maybe<TimeSheetStatus>;
  status_in?: Maybe<TimeSheetStatus[] | TimeSheetStatus>;
  status_not_in?: Maybe<TimeSheetStatus[] | TimeSheetStatus>;
  timeSheetEntries_every?: Maybe<TimeSheetEntryWhereInput>;
  timeSheetEntries_some?: Maybe<TimeSheetEntryWhereInput>;
  timeSheetEntries_none?: Maybe<TimeSheetEntryWhereInput>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TimeSheetWhereInput[] | TimeSheetWhereInput>;
  OR?: Maybe<TimeSheetWhereInput[] | TimeSheetWhereInput>;
  NOT?: Maybe<TimeSheetWhereInput[] | TimeSheetWhereInput>;
}

export interface TimeSheetCreateInput {
  id?: Maybe<ID_Input>;
  attachments?: Maybe<AttachmentCreateManyInput>;
  company: CompanyCreateOneInput;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  number?: Maybe<Int>;
  preview?: Maybe<AttachmentCreateOneInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<TimeSheetStatus>;
  timeSheetEntries?: Maybe<TimeSheetEntryCreateManyWithoutTimeSheetInput>;
  user?: Maybe<UserCreateOneInput>;
}

export interface PurchaseOrderLineUpdateManyMutationInput {
  pbsDrug?: Maybe<String>;
  qty?: Maybe<Int>;
  unit?: Maybe<UOM>;
  unitPrice?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface TimeSheetEntryCreateManyWithoutTimeSheetInput {
  create?: Maybe<
    | TimeSheetEntryCreateWithoutTimeSheetInput[]
    | TimeSheetEntryCreateWithoutTimeSheetInput
  >;
  connect?: Maybe<
    TimeSheetEntryWhereUniqueInput[] | TimeSheetEntryWhereUniqueInput
  >;
}

export interface ProjectServiceUpdateWithoutRulesDataInput {
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  project?: Maybe<ProjectUpdateOneWithoutProjectServiceInput>;
  service?: Maybe<ServiceUpdateOneInput>;
}

export interface TimeSheetEntryCreateWithoutTimeSheetInput {
  id?: Maybe<ID_Input>;
  customer?: Maybe<CustomerCreateOneInput>;
  date?: Maybe<DateTimeInput>;
  duration?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isInvoiced?: Maybe<Boolean>;
  project?: Maybe<ProjectCreateOneInput>;
  service?: Maybe<ServiceCreateOneInput>;
}

export interface ProjectServiceUpdateInput {
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  project?: Maybe<ProjectUpdateOneWithoutProjectServiceInput>;
  rules?: Maybe<ProjectServiceRuleUpdateManyWithoutProjectServiceInput>;
  service?: Maybe<ServiceUpdateOneInput>;
}

export interface InvoiceUpdateInput {
  title?: Maybe<String>;
  attachments?: Maybe<AttachmentUpdateManyInput>;
  buyer?: Maybe<CustomerUpdateOneInput>;
  number?: Maybe<Int>;
  description?: Maybe<String>;
  invoiceDate?: Maybe<DateTimeInput>;
  dueDate?: Maybe<DateTimeInput>;
  preview?: Maybe<AttachmentUpdateOneInput>;
  items?: Maybe<InvoiceItemEntryUpdateManyWithoutInvoiceInput>;
  seller?: Maybe<CompanyUpdateOneRequiredInput>;
  status?: Maybe<InvoiceStatus>;
  type?: Maybe<InvoiceType>;
  total?: Maybe<Float>;
}

export interface PredictedSalesQuantityOfItemsByCompanyCreateInput {
  id?: Maybe<ID_Input>;
  datePredictionRun?: Maybe<DateTimeInput>;
  company: CompanyCreateOneInput;
  inventory?: Maybe<InventoryCreateOneInput>;
  predictedSalesValue?: Maybe<Float>;
  predictedDate?: Maybe<DateTimeInput>;
}

export interface AttachmentUpdateManyInput {
  create?: Maybe<AttachmentCreateInput[] | AttachmentCreateInput>;
  update?: Maybe<
    | AttachmentUpdateWithWhereUniqueNestedInput[]
    | AttachmentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | AttachmentUpsertWithWhereUniqueNestedInput[]
    | AttachmentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<AttachmentWhereUniqueInput[] | AttachmentWhereUniqueInput>;
  connect?: Maybe<AttachmentWhereUniqueInput[] | AttachmentWhereUniqueInput>;
  set?: Maybe<AttachmentWhereUniqueInput[] | AttachmentWhereUniqueInput>;
  disconnect?: Maybe<AttachmentWhereUniqueInput[] | AttachmentWhereUniqueInput>;
  deleteMany?: Maybe<AttachmentScalarWhereInput[] | AttachmentScalarWhereInput>;
  updateMany?: Maybe<
    | AttachmentUpdateManyWithWhereNestedInput[]
    | AttachmentUpdateManyWithWhereNestedInput
  >;
}

export interface PlanUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutActivePlanInput>;
  isActive?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  price?: Maybe<Float>;
  type?: Maybe<PlanType>;
  currency?: Maybe<Currency>;
}

export interface AttachmentUpdateWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput;
  data: AttachmentUpdateDataInput;
}

export interface PbsOrganisationUpdateManyMutationInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  stateAddress?: Maybe<String>;
  postcode?: Maybe<String>;
  phone?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface AttachmentUpsertWithWhereUniqueNestedInput {
  where: AttachmentWhereUniqueInput;
  update: AttachmentUpdateDataInput;
  create: AttachmentCreateInput;
}

export interface NameUpdateManyWithWhereNestedInput {
  where: NameScalarWhereInput;
  data: NameUpdateManyDataInput;
}

export interface AttachmentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  fileName?: Maybe<String>;
  fileName_not?: Maybe<String>;
  fileName_in?: Maybe<String[] | String>;
  fileName_not_in?: Maybe<String[] | String>;
  fileName_lt?: Maybe<String>;
  fileName_lte?: Maybe<String>;
  fileName_gt?: Maybe<String>;
  fileName_gte?: Maybe<String>;
  fileName_contains?: Maybe<String>;
  fileName_not_contains?: Maybe<String>;
  fileName_starts_with?: Maybe<String>;
  fileName_not_starts_with?: Maybe<String>;
  fileName_ends_with?: Maybe<String>;
  fileName_not_ends_with?: Maybe<String>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Bucket_not?: Maybe<String>;
  s3Bucket_in?: Maybe<String[] | String>;
  s3Bucket_not_in?: Maybe<String[] | String>;
  s3Bucket_lt?: Maybe<String>;
  s3Bucket_lte?: Maybe<String>;
  s3Bucket_gt?: Maybe<String>;
  s3Bucket_gte?: Maybe<String>;
  s3Bucket_contains?: Maybe<String>;
  s3Bucket_not_contains?: Maybe<String>;
  s3Bucket_starts_with?: Maybe<String>;
  s3Bucket_not_starts_with?: Maybe<String>;
  s3Bucket_ends_with?: Maybe<String>;
  s3Bucket_not_ends_with?: Maybe<String>;
  s3Key?: Maybe<String>;
  s3Key_not?: Maybe<String>;
  s3Key_in?: Maybe<String[] | String>;
  s3Key_not_in?: Maybe<String[] | String>;
  s3Key_lt?: Maybe<String>;
  s3Key_lte?: Maybe<String>;
  s3Key_gt?: Maybe<String>;
  s3Key_gte?: Maybe<String>;
  s3Key_contains?: Maybe<String>;
  s3Key_not_contains?: Maybe<String>;
  s3Key_starts_with?: Maybe<String>;
  s3Key_not_starts_with?: Maybe<String>;
  s3Key_ends_with?: Maybe<String>;
  s3Key_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AttachmentScalarWhereInput[] | AttachmentScalarWhereInput>;
  OR?: Maybe<AttachmentScalarWhereInput[] | AttachmentScalarWhereInput>;
  NOT?: Maybe<AttachmentScalarWhereInput[] | AttachmentScalarWhereInput>;
}

export type ProjectServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttachmentUpdateManyWithWhereNestedInput {
  where: AttachmentScalarWhereInput;
  data: AttachmentUpdateManyDataInput;
}

export type ApInvoiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AttachmentUpdateManyDataInput {
  description?: Maybe<String>;
  fileName?: Maybe<String>;
  label?: Maybe<String>;
  url?: Maybe<String>;
  s3Bucket?: Maybe<String>;
  s3Key?: Maybe<String>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerUpdateOneInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface HealthcareProviderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  occupation?: Maybe<String>;
  occupation_not?: Maybe<String>;
  occupation_in?: Maybe<String[] | String>;
  occupation_not_in?: Maybe<String[] | String>;
  occupation_lt?: Maybe<String>;
  occupation_lte?: Maybe<String>;
  occupation_gt?: Maybe<String>;
  occupation_gte?: Maybe<String>;
  occupation_contains?: Maybe<String>;
  occupation_not_contains?: Maybe<String>;
  occupation_starts_with?: Maybe<String>;
  occupation_not_starts_with?: Maybe<String>;
  occupation_ends_with?: Maybe<String>;
  occupation_not_ends_with?: Maybe<String>;
  hpii?: Maybe<String>;
  hpii_not?: Maybe<String>;
  hpii_in?: Maybe<String[] | String>;
  hpii_not_in?: Maybe<String[] | String>;
  hpii_lt?: Maybe<String>;
  hpii_lte?: Maybe<String>;
  hpii_gt?: Maybe<String>;
  hpii_gte?: Maybe<String>;
  hpii_contains?: Maybe<String>;
  hpii_not_contains?: Maybe<String>;
  hpii_starts_with?: Maybe<String>;
  hpii_not_starts_with?: Maybe<String>;
  hpii_ends_with?: Maybe<String>;
  hpii_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  dateOfBirth?: Maybe<DateTimeInput>;
  dateOfBirth_not?: Maybe<DateTimeInput>;
  dateOfBirth_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateOfBirth_lt?: Maybe<DateTimeInput>;
  dateOfBirth_lte?: Maybe<DateTimeInput>;
  dateOfBirth_gt?: Maybe<DateTimeInput>;
  dateOfBirth_gte?: Maybe<DateTimeInput>;
  emailAddress?: Maybe<String>;
  emailAddress_not?: Maybe<String>;
  emailAddress_in?: Maybe<String[] | String>;
  emailAddress_not_in?: Maybe<String[] | String>;
  emailAddress_lt?: Maybe<String>;
  emailAddress_lte?: Maybe<String>;
  emailAddress_gt?: Maybe<String>;
  emailAddress_gte?: Maybe<String>;
  emailAddress_contains?: Maybe<String>;
  emailAddress_not_contains?: Maybe<String>;
  emailAddress_starts_with?: Maybe<String>;
  emailAddress_not_starts_with?: Maybe<String>;
  emailAddress_ends_with?: Maybe<String>;
  emailAddress_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  address?: Maybe<AddressWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  ahpraNumber?: Maybe<String>;
  ahpraNumber_not?: Maybe<String>;
  ahpraNumber_in?: Maybe<String[] | String>;
  ahpraNumber_not_in?: Maybe<String[] | String>;
  ahpraNumber_lt?: Maybe<String>;
  ahpraNumber_lte?: Maybe<String>;
  ahpraNumber_gt?: Maybe<String>;
  ahpraNumber_gte?: Maybe<String>;
  ahpraNumber_contains?: Maybe<String>;
  ahpraNumber_not_contains?: Maybe<String>;
  ahpraNumber_starts_with?: Maybe<String>;
  ahpraNumber_not_starts_with?: Maybe<String>;
  ahpraNumber_ends_with?: Maybe<String>;
  ahpraNumber_not_ends_with?: Maybe<String>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HealthcareProviderWhereInput[] | HealthcareProviderWhereInput>;
  OR?: Maybe<HealthcareProviderWhereInput[] | HealthcareProviderWhereInput>;
  NOT?: Maybe<HealthcareProviderWhereInput[] | HealthcareProviderWhereInput>;
}

export interface CustomerUpdateDataInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  description?: Maybe<String>;
  govNumber?: Maybe<String>;
  salesTax?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  billingFrequency?: Maybe<SupplierTermsOfPayment>;
  meansTestedFee?: Maybe<MeansTestedFeeUpdateOneInput>;
  basicDailyFee?: Maybe<BasicDailyFeeUpdateOneInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
  addresses?: Maybe<AddressUpdateManyInput>;
}

export type InventoryOnHandWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface SalesOrderUpdateOneInput {
  create?: Maybe<SalesOrderCreateInput>;
  update?: Maybe<SalesOrderUpdateDataInput>;
  upsert?: Maybe<SalesOrderUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SalesOrderWhereUniqueInput>;
}

export interface InvoiceItemEntryUpdateManyWithoutInvoiceInput {
  create?: Maybe<
    | InvoiceItemEntryCreateWithoutInvoiceInput[]
    | InvoiceItemEntryCreateWithoutInvoiceInput
  >;
  delete?: Maybe<
    InvoiceItemEntryWhereUniqueInput[] | InvoiceItemEntryWhereUniqueInput
  >;
  connect?: Maybe<
    InvoiceItemEntryWhereUniqueInput[] | InvoiceItemEntryWhereUniqueInput
  >;
  set?: Maybe<
    InvoiceItemEntryWhereUniqueInput[] | InvoiceItemEntryWhereUniqueInput
  >;
  disconnect?: Maybe<
    InvoiceItemEntryWhereUniqueInput[] | InvoiceItemEntryWhereUniqueInput
  >;
  update?: Maybe<
    | InvoiceItemEntryUpdateWithWhereUniqueWithoutInvoiceInput[]
    | InvoiceItemEntryUpdateWithWhereUniqueWithoutInvoiceInput
  >;
  upsert?: Maybe<
    | InvoiceItemEntryUpsertWithWhereUniqueWithoutInvoiceInput[]
    | InvoiceItemEntryUpsertWithWhereUniqueWithoutInvoiceInput
  >;
  deleteMany?: Maybe<
    InvoiceItemEntryScalarWhereInput[] | InvoiceItemEntryScalarWhereInput
  >;
  updateMany?: Maybe<
    | InvoiceItemEntryUpdateManyWithWhereNestedInput[]
    | InvoiceItemEntryUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectServiceCreateOneWithoutRulesInput {
  create?: Maybe<ProjectServiceCreateWithoutRulesInput>;
  connect?: Maybe<ProjectServiceWhereUniqueInput>;
}

export interface InvoiceItemEntryUpdateWithWhereUniqueWithoutInvoiceInput {
  where: InvoiceItemEntryWhereUniqueInput;
  data: InvoiceItemEntryUpdateWithoutInvoiceDataInput;
}

export interface CompanyUpsertWithoutActivePlanInput {
  update: CompanyUpdateWithoutActivePlanDataInput;
  create: CompanyCreateWithoutActivePlanInput;
}

export interface InvoiceItemEntryUpdateWithoutInvoiceDataInput {
  order?: Maybe<Int>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  quantity?: Maybe<Float>;
  tax?: Maybe<Float>;
  project?: Maybe<ProjectUpdateOneInput>;
  service?: Maybe<ServiceUpdateOneInput>;
  timeSheetEntry?: Maybe<TimeSheetEntryUpdateOneInput>;
  timeSheet?: Maybe<TimeSheetUpdateOneInput>;
}

export interface PoReceiptWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  receiptNumber?: Maybe<String>;
  receiptNumber_not?: Maybe<String>;
  receiptNumber_in?: Maybe<String[] | String>;
  receiptNumber_not_in?: Maybe<String[] | String>;
  receiptNumber_lt?: Maybe<String>;
  receiptNumber_lte?: Maybe<String>;
  receiptNumber_gt?: Maybe<String>;
  receiptNumber_gte?: Maybe<String>;
  receiptNumber_contains?: Maybe<String>;
  receiptNumber_not_contains?: Maybe<String>;
  receiptNumber_starts_with?: Maybe<String>;
  receiptNumber_not_starts_with?: Maybe<String>;
  receiptNumber_ends_with?: Maybe<String>;
  receiptNumber_not_ends_with?: Maybe<String>;
  purchaseOrder?: Maybe<PurchaseOrderWhereInput>;
  receiptDate?: Maybe<DateTimeInput>;
  receiptDate_not?: Maybe<DateTimeInput>;
  receiptDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receiptDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  receiptDate_lt?: Maybe<DateTimeInput>;
  receiptDate_lte?: Maybe<DateTimeInput>;
  receiptDate_gt?: Maybe<DateTimeInput>;
  receiptDate_gte?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PoReceiptWhereInput[] | PoReceiptWhereInput>;
  OR?: Maybe<PoReceiptWhereInput[] | PoReceiptWhereInput>;
  NOT?: Maybe<PoReceiptWhereInput[] | PoReceiptWhereInput>;
}

export interface ProjectUpdateOneInput {
  create?: Maybe<ProjectCreateInput>;
  update?: Maybe<ProjectUpdateDataInput>;
  upsert?: Maybe<ProjectUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export type PurchaseOrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectUpdateDataInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneInput>;
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  projectService?: Maybe<ProjectServiceUpdateManyWithoutProjectInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export type BankTransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectServiceUpdateManyWithoutProjectInput {
  create?: Maybe<
    | ProjectServiceCreateWithoutProjectInput[]
    | ProjectServiceCreateWithoutProjectInput
  >;
  delete?: Maybe<
    ProjectServiceWhereUniqueInput[] | ProjectServiceWhereUniqueInput
  >;
  connect?: Maybe<
    ProjectServiceWhereUniqueInput[] | ProjectServiceWhereUniqueInput
  >;
  set?: Maybe<
    ProjectServiceWhereUniqueInput[] | ProjectServiceWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProjectServiceWhereUniqueInput[] | ProjectServiceWhereUniqueInput
  >;
  update?: Maybe<
    | ProjectServiceUpdateWithWhereUniqueWithoutProjectInput[]
    | ProjectServiceUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | ProjectServiceUpsertWithWhereUniqueWithoutProjectInput[]
    | ProjectServiceUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<
    ProjectServiceScalarWhereInput[] | ProjectServiceScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProjectServiceUpdateManyWithWhereNestedInput[]
    | ProjectServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  isDeleted_not?: Maybe<Boolean>;
  project?: Maybe<ProjectWhereInput>;
  rules_every?: Maybe<ProjectServiceRuleWhereInput>;
  rules_some?: Maybe<ProjectServiceRuleWhereInput>;
  rules_none?: Maybe<ProjectServiceRuleWhereInput>;
  service?: Maybe<ServiceWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectServiceWhereInput[] | ProjectServiceWhereInput>;
  OR?: Maybe<ProjectServiceWhereInput[] | ProjectServiceWhereInput>;
  NOT?: Maybe<ProjectServiceWhereInput[] | ProjectServiceWhereInput>;
}

export interface ProjectServiceUpdateWithWhereUniqueWithoutProjectInput {
  where: ProjectServiceWhereUniqueInput;
  data: ProjectServiceUpdateWithoutProjectDataInput;
}

export interface ProjectUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredInput>;
  customer?: Maybe<CustomerUpdateOneInput>;
  description?: Maybe<String>;
  endsAt?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  name?: Maybe<String>;
  projectService?: Maybe<ProjectServiceUpdateManyWithoutProjectInput>;
  startsAt?: Maybe<DateTimeInput>;
  status?: Maybe<ProjectStatus>;
}

export interface ProjectServiceUpdateWithoutProjectDataInput {
  amount?: Maybe<Float>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
  rules?: Maybe<ProjectServiceRuleUpdateManyWithoutProjectServiceInput>;
  service?: Maybe<ServiceUpdateOneInput>;
}

export interface PatientUpdateInput {
  title?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  names?: Maybe<NameUpdateManyInput>;
  address?: Maybe<AddressUpdateOneInput>;
  birthAddress?: Maybe<AddressUpdateOneInput>;
  dateOfBirth?: Maybe<DateTimeInput>;
  customer?: Maybe<CustomerUpdateOneInput>;
  gender?: Maybe<Gender>;
  dvaCardType?: Maybe<DVACardType>;
  aboriginalStatus?: Maybe<AboriginalStatus>;
  pensionerConcession?: Maybe<String>;
  commonwealthSeniors?: Maybe<String>;
  healthcareConcession?: Maybe<String>;
  safetyNetConcession?: Maybe<Float>;
  medicareNumber?: Maybe<String>;
  DVA?: Maybe<String>;
  potentialDuplicate?: Maybe<Boolean>;
  oneName?: Maybe<Boolean>;
  ihi?: Maybe<String>;
  ihiValidatedDate?: Maybe<DateTimeInput>;
  noOfBirths?: Maybe<Int>;
  deceasedDate?: Maybe<DateTimeInput>;
  basicDailyFee?: Maybe<BasicDailyFeeUpdateManyInput>;
  levelOfCare?: Maybe<LevelOfCare>;
  dateEnteredAgedCare?: Maybe<DateTimeInput>;
  company?: Maybe<CompanyUpdateOneInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface ProjectServiceRuleUpsertWithWhereUniqueWithoutProjectServiceInput {
  where: ProjectServiceRuleWhereUniqueInput;
  update: ProjectServiceRuleUpdateWithoutProjectServiceDataInput;
  create: ProjectServiceRuleCreateWithoutProjectServiceInput;
}

export interface ProjectServiceRuleUpdateWithoutProjectServiceDataInput {
  amount?: Maybe<Float>;
  percent?: Maybe<Float>;
  type?: Maybe<ProjectServiceRuleType>;
  isPercent?: Maybe<Boolean>;
}

export interface ProjectServiceRuleUpdateWithWhereUniqueWithoutProjectServiceInput {
  where: ProjectServiceRuleWhereUniqueInput;
  data: ProjectServiceRuleUpdateWithoutProjectServiceDataInput;
}

export interface ProjectServiceRuleUpdateManyWithoutProjectServiceInput {
  create?: Maybe<
    | ProjectServiceRuleCreateWithoutProjectServiceInput[]
    | ProjectServiceRuleCreateWithoutProjectServiceInput
  >;
  delete?: Maybe<
    ProjectServiceRuleWhereUniqueInput[] | ProjectServiceRuleWhereUniqueInput
  >;
  connect?: Maybe<
    ProjectServiceRuleWhereUniqueInput[] | ProjectServiceRuleWhereUniqueInput
  >;
  set?: Maybe<
    ProjectServiceRuleWhereUniqueInput[] | ProjectServiceRuleWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProjectServiceRuleWhereUniqueInput[] | ProjectServiceRuleWhereUniqueInput
  >;
  update?: Maybe<
    | ProjectServiceRuleUpdateWithWhereUniqueWithoutProjectServiceInput[]
    | ProjectServiceRuleUpdateWithWhereUniqueWithoutProjectServiceInput
  >;
  upsert?: Maybe<
    | ProjectServiceRuleUpsertWithWhereUniqueWithoutProjectServiceInput[]
    | ProjectServiceRuleUpsertWithWhereUniqueWithoutProjectServiceInput
  >;
  deleteMany?: Maybe<
    ProjectServiceRuleScalarWhereInput[] | ProjectServiceRuleScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProjectServiceRuleUpdateManyWithWhereNestedInput[]
    | ProjectServiceRuleUpdateManyWithWhereNestedInput
  >;
}

export interface VaccineBrandSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VaccineBrandWhereInput>;
  AND?: Maybe<
    VaccineBrandSubscriptionWhereInput[] | VaccineBrandSubscriptionWhereInput
  >;
  OR?: Maybe<
    VaccineBrandSubscriptionWhereInput[] | VaccineBrandSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VaccineBrandSubscriptionWhereInput[] | VaccineBrandSubscriptionWhereInput
  >;
}

export interface PbsOrganisationUpdateDataInput {
  code?: Maybe<String>;
  title?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  stateAddress?: Maybe<String>;
  postcode?: Maybe<String>;
  phone?: Maybe<String>;
  effectiveFrom?: Maybe<DateTimeInput>;
  effectiveTo?: Maybe<DateTimeInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface PurchaseOrderLineCreateInput {
  id?: Maybe<ID_Input>;
  item?: Maybe<InventoryCreateOneInput>;
  pbsDrug?: Maybe<String>;
  qty?: Maybe<Int>;
  unit?: Maybe<UOM>;
  unitPrice?: Maybe<Float>;
  site?: Maybe<WareHouseCreateOneInput>;
  purchaseOrder?: Maybe<PurchaseOrderCreateOneInput>;
  poReceipt?: Maybe<PoReceiptCreateOneInput>;
  isArchived?: Maybe<Boolean>;
  isDeleted?: Maybe<Boolean>;
}

export interface BasicDailyFeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BasicDailyFeeWhereInput>;
  AND?: Maybe<
    BasicDailyFeeSubscriptionWhereInput[] | BasicDailyFeeSubscriptionWhereInput
  >;
  OR?: Maybe<
    BasicDailyFeeSubscriptionWhereInput[] | BasicDailyFeeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    BasicDailyFeeSubscriptionWhereInput[] | BasicDailyFeeSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WareHousePreviousValues {
  id: ID_Output;
  name?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WareHousePreviousValuesPromise
  extends Promise<WareHousePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WareHousePreviousValuesSubscription
  extends Promise<AsyncIterator<WareHousePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankTransactionConnection {
  pageInfo: PageInfo;
  edges: BankTransactionEdge[];
}

export interface BankTransactionConnectionPromise
  extends Promise<BankTransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BankTransactionEdge>>() => T;
  aggregate: <T = AggregateBankTransactionPromise>() => T;
}

export interface BankTransactionConnectionSubscription
  extends Promise<AsyncIterator<BankTransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BankTransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBankTransactionSubscription>() => T;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BankTransactionEdge {
  node: BankTransaction;
  cursor: String;
}

export interface BankTransactionEdgePromise
  extends Promise<BankTransactionEdge>,
    Fragmentable {
  node: <T = BankTransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BankTransactionEdgeSubscription
  extends Promise<AsyncIterator<BankTransactionEdge>>,
    Fragmentable {
  node: <T = BankTransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface AggregateWareHouse {
  count: Int;
}

export interface AggregateWareHousePromise
  extends Promise<AggregateWareHouse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWareHouseSubscription
  extends Promise<AsyncIterator<AggregateWareHouse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AssetGroupEdge {
  node: AssetGroup;
  cursor: String;
}

export interface AssetGroupEdgePromise
  extends Promise<AssetGroupEdge>,
    Fragmentable {
  node: <T = AssetGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AssetGroupEdgeSubscription
  extends Promise<AsyncIterator<AssetGroupEdge>>,
    Fragmentable {
  node: <T = AssetGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WareHouseConnection {
  pageInfo: PageInfo;
  edges: WareHouseEdge[];
}

export interface WareHouseConnectionPromise
  extends Promise<WareHouseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WareHouseEdge>>() => T;
  aggregate: <T = AggregateWareHousePromise>() => T;
}

export interface WareHouseConnectionSubscription
  extends Promise<AsyncIterator<WareHouseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WareHouseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWareHouseSubscription>() => T;
}

export interface AggregateAssetGroup {
  count: Int;
}

export interface AggregateAssetGroupPromise
  extends Promise<AggregateAssetGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAssetGroupSubscription
  extends Promise<AsyncIterator<AggregateAssetGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateVaccineBrand {
  count: Int;
}

export interface AggregateVaccineBrandPromise
  extends Promise<AggregateVaccineBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVaccineBrandSubscription
  extends Promise<AsyncIterator<AggregateVaccineBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Address {
  id: ID_Output;
  street?: String;
  city?: String;
  state?: String;
  country?: String;
  postCode?: String;
  latitude?: String;
  longitude?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postCode: () => Promise<String>;
  latitude: () => Promise<String>;
  longitude: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postCode: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postCode: () => Promise<String>;
  latitude: () => Promise<String>;
  longitude: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VaccineBrandConnection {
  pageInfo: PageInfo;
  edges: VaccineBrandEdge[];
}

export interface VaccineBrandConnectionPromise
  extends Promise<VaccineBrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VaccineBrandEdge>>() => T;
  aggregate: <T = AggregateVaccineBrandPromise>() => T;
}

export interface VaccineBrandConnectionSubscription
  extends Promise<AsyncIterator<VaccineBrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VaccineBrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVaccineBrandSubscription>() => T;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressPreviousValues {
  id: ID_Output;
  street?: String;
  city?: String;
  state?: String;
  country?: String;
  postCode?: String;
  latitude?: String;
  longitude?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postCode: () => Promise<String>;
  latitude: () => Promise<String>;
  longitude: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postCode: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Inventory {
  id: ID_Output;
  name?: String;
  inventoryModel?: InventoryModel;
  uom?: UOM;
  price?: Float;
  SellingPrice?: Float;
  Barcode?: String;
  Taxable?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inventoryModel: () => Promise<InventoryModel>;
  uom: () => Promise<UOM>;
  price: () => Promise<Float>;
  SellingPrice: () => Promise<Float>;
  Barcode: () => Promise<String>;
  Taxable: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  inventoryModel: () => Promise<AsyncIterator<InventoryModel>>;
  uom: () => Promise<AsyncIterator<UOM>>;
  price: () => Promise<AsyncIterator<Float>>;
  SellingPrice: () => Promise<AsyncIterator<Float>>;
  Barcode: () => Promise<AsyncIterator<String>>;
  Taxable: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryNullablePromise
  extends Promise<Inventory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inventoryModel: () => Promise<InventoryModel>;
  uom: () => Promise<UOM>;
  price: () => Promise<Float>;
  SellingPrice: () => Promise<Float>;
  Barcode: () => Promise<String>;
  Taxable: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetEntryEdge {
  node: TimeSheetEntry;
  cursor: String;
}

export interface TimeSheetEntryEdgePromise
  extends Promise<TimeSheetEntryEdge>,
    Fragmentable {
  node: <T = TimeSheetEntryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeSheetEntryEdgeSubscription
  extends Promise<AsyncIterator<TimeSheetEntryEdge>>,
    Fragmentable {
  node: <T = TimeSheetEntrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ApInvoiceSubscriptionPayload {
  mutation: MutationType;
  node: ApInvoice;
  updatedFields: String[];
  previousValues: ApInvoicePreviousValues;
}

export interface ApInvoiceSubscriptionPayloadPromise
  extends Promise<ApInvoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApInvoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApInvoicePreviousValuesPromise>() => T;
}

export interface ApInvoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApInvoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApInvoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApInvoicePreviousValuesSubscription>() => T;
}

export interface AggregateTimeSheet {
  count: Int;
}

export interface AggregateTimeSheetPromise
  extends Promise<AggregateTimeSheet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeSheetSubscription
  extends Promise<AsyncIterator<AggregateTimeSheet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApInvoicePreviousValues {
  id: ID_Output;
  status?: ApInvoiceStatus;
  invoiceNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ApInvoicePreviousValuesPromise
  extends Promise<ApInvoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ApInvoiceStatus>;
  invoiceNumber: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ApInvoicePreviousValuesSubscription
  extends Promise<AsyncIterator<ApInvoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ApInvoiceStatus>>;
  invoiceNumber: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TimeSheetConnection {
  pageInfo: PageInfo;
  edges: TimeSheetEdge[];
}

export interface TimeSheetConnectionPromise
  extends Promise<TimeSheetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeSheetEdge>>() => T;
  aggregate: <T = AggregateTimeSheetPromise>() => T;
}

export interface TimeSheetConnectionSubscription
  extends Promise<AsyncIterator<TimeSheetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeSheetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeSheetSubscription>() => T;
}

export interface AggregateIntegration {
  count: Int;
}

export interface AggregateIntegrationPromise
  extends Promise<AggregateIntegration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIntegrationSubscription
  extends Promise<AsyncIterator<AggregateIntegration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSupplier {
  count: Int;
}

export interface AggregateSupplierPromise
  extends Promise<AggregateSupplier>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupplierSubscription
  extends Promise<AsyncIterator<AggregateSupplier>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AssetSubscriptionPayload {
  mutation: MutationType;
  node: Asset;
  updatedFields: String[];
  previousValues: AssetPreviousValues;
}

export interface AssetSubscriptionPayloadPromise
  extends Promise<AssetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AssetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AssetPreviousValuesPromise>() => T;
}

export interface AssetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AssetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AssetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AssetPreviousValuesSubscription>() => T;
}

export interface SupplierConnection {
  pageInfo: PageInfo;
  edges: SupplierEdge[];
}

export interface SupplierConnectionPromise
  extends Promise<SupplierConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupplierEdge>>() => T;
  aggregate: <T = AggregateSupplierPromise>() => T;
}

export interface SupplierConnectionSubscription
  extends Promise<AsyncIterator<SupplierConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SupplierEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSupplierSubscription>() => T;
}

export interface AssetPreviousValues {
  id: ID_Output;
  name?: String;
  dateOfAquisition?: DateTimeOutput;
  aquisitionPrice?: Float;
  netBookValue?: Float;
  depreciation?: Float;
  salvageValue?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AssetPreviousValuesPromise
  extends Promise<AssetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  dateOfAquisition: () => Promise<DateTimeOutput>;
  aquisitionPrice: () => Promise<Float>;
  netBookValue: () => Promise<Float>;
  depreciation: () => Promise<Float>;
  salvageValue: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AssetPreviousValuesSubscription
  extends Promise<AsyncIterator<AssetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  dateOfAquisition: () => Promise<AsyncIterator<DateTimeOutput>>;
  aquisitionPrice: () => Promise<AsyncIterator<Float>>;
  netBookValue: () => Promise<AsyncIterator<Float>>;
  depreciation: () => Promise<AsyncIterator<Float>>;
  salvageValue: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IntegrationEdge {
  node: Integration;
  cursor: String;
}

export interface IntegrationEdgePromise
  extends Promise<IntegrationEdge>,
    Fragmentable {
  node: <T = IntegrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IntegrationEdgeSubscription
  extends Promise<AsyncIterator<IntegrationEdge>>,
    Fragmentable {
  node: <T = IntegrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface AssetGroupSubscriptionPayload {
  mutation: MutationType;
  node: AssetGroup;
  updatedFields: String[];
  previousValues: AssetGroupPreviousValues;
}

export interface AssetGroupSubscriptionPayloadPromise
  extends Promise<AssetGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AssetGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AssetGroupPreviousValuesPromise>() => T;
}

export interface AssetGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AssetGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AssetGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AssetGroupPreviousValuesSubscription>() => T;
}

export interface Session {
  id: ID_Output;
  expires_at?: DateTimeOutput;
  is_active?: Boolean;
  is_archived?: Boolean;
  is_deleted?: Boolean;
  signed_at?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  expires_at: () => Promise<DateTimeOutput>;
  is_active: () => Promise<Boolean>;
  is_archived: () => Promise<Boolean>;
  is_deleted: () => Promise<Boolean>;
  signed_at: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expires_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  is_active: () => Promise<AsyncIterator<Boolean>>;
  is_archived: () => Promise<AsyncIterator<Boolean>>;
  is_deleted: () => Promise<AsyncIterator<Boolean>>;
  signed_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expires_at: () => Promise<DateTimeOutput>;
  is_active: () => Promise<Boolean>;
  is_archived: () => Promise<Boolean>;
  is_deleted: () => Promise<Boolean>;
  signed_at: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AssetGroupPreviousValues {
  id: ID_Output;
  name?: String;
  depreciationType?: AssetGroupDepreciationType;
  usefulLife?: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AssetGroupPreviousValuesPromise
  extends Promise<AssetGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  depreciationType: () => Promise<AssetGroupDepreciationType>;
  usefulLife: () => Promise<Int>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AssetGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<AssetGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  depreciationType: () => Promise<AsyncIterator<AssetGroupDepreciationType>>;
  usefulLife: () => Promise<AsyncIterator<Int>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IntegrationConnection {
  pageInfo: PageInfo;
  edges: IntegrationEdge[];
}

export interface IntegrationConnectionPromise
  extends Promise<IntegrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IntegrationEdge>>() => T;
  aggregate: <T = AggregateIntegrationPromise>() => T;
}

export interface IntegrationConnectionSubscription
  extends Promise<AsyncIterator<IntegrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IntegrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIntegrationSubscription>() => T;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface SalesOrderLineConnection {
  pageInfo: PageInfo;
  edges: SalesOrderLineEdge[];
}

export interface SalesOrderLineConnectionPromise
  extends Promise<SalesOrderLineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalesOrderLineEdge>>() => T;
  aggregate: <T = AggregateSalesOrderLinePromise>() => T;
}

export interface SalesOrderLineConnectionSubscription
  extends Promise<AsyncIterator<SalesOrderLineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalesOrderLineEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalesOrderLineSubscription>() => T;
}

export interface AggregateSalesOrderLine {
  count: Int;
}

export interface AggregateSalesOrderLinePromise
  extends Promise<AggregateSalesOrderLine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalesOrderLineSubscription
  extends Promise<AsyncIterator<AggregateSalesOrderLine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalesOrderLine {
  id: ID_Output;
  qty?: Int;
  price?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesOrderLinePromise
  extends Promise<SalesOrderLine>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  salesOrder: <T = SalesOrderPromise>() => T;
  inventory: <T = InventoryPromise>() => T;
  qty: () => Promise<Int>;
  price: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesOrderLineSubscription
  extends Promise<AsyncIterator<SalesOrderLine>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  salesOrder: <T = SalesOrderSubscription>() => T;
  inventory: <T = InventorySubscription>() => T;
  qty: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SalesOrderLineNullablePromise
  extends Promise<SalesOrderLine | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  salesOrder: <T = SalesOrderPromise>() => T;
  inventory: <T = InventoryPromise>() => T;
  qty: () => Promise<Int>;
  price: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AttachmentSubscriptionPayload {
  mutation: MutationType;
  node: Attachment;
  updatedFields: String[];
  previousValues: AttachmentPreviousValues;
}

export interface AttachmentSubscriptionPayloadPromise
  extends Promise<AttachmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttachmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttachmentPreviousValuesPromise>() => T;
}

export interface AttachmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttachmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttachmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttachmentPreviousValuesSubscription>() => T;
}

export interface SalesOrderEdge {
  node: SalesOrder;
  cursor: String;
}

export interface SalesOrderEdgePromise
  extends Promise<SalesOrderEdge>,
    Fragmentable {
  node: <T = SalesOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalesOrderEdgeSubscription
  extends Promise<AsyncIterator<SalesOrderEdge>>,
    Fragmentable {
  node: <T = SalesOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttachmentPreviousValues {
  id: ID_Output;
  description?: String;
  fileName?: String;
  label?: String;
  url?: String;
  s3Bucket?: String;
  s3Key?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AttachmentPreviousValuesPromise
  extends Promise<AttachmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  fileName: () => Promise<String>;
  label: () => Promise<String>;
  url: () => Promise<String>;
  s3Bucket: () => Promise<String>;
  s3Key: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AttachmentPreviousValuesSubscription
  extends Promise<AsyncIterator<AttachmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  s3Bucket: () => Promise<AsyncIterator<String>>;
  s3Key: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttachmentConnection {
  pageInfo: PageInfo;
  edges: AttachmentEdge[];
}

export interface AttachmentConnectionPromise
  extends Promise<AttachmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttachmentEdge>>() => T;
  aggregate: <T = AggregateAttachmentPromise>() => T;
}

export interface AttachmentConnectionSubscription
  extends Promise<AsyncIterator<AttachmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttachmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttachmentSubscription>() => T;
}

export interface AggregatePurchaseOrderLine {
  count: Int;
}

export interface AggregatePurchaseOrderLinePromise
  extends Promise<AggregatePurchaseOrderLine>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseOrderLineSubscription
  extends Promise<AsyncIterator<AggregatePurchaseOrderLine>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankSubscriptionPayload {
  mutation: MutationType;
  node: Bank;
  updatedFields: String[];
  previousValues: BankPreviousValues;
}

export interface BankSubscriptionPayloadPromise
  extends Promise<BankSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BankPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BankPreviousValuesPromise>() => T;
}

export interface BankSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BankSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BankSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BankPreviousValuesSubscription>() => T;
}

export interface PurchaseOrderLineConnection {
  pageInfo: PageInfo;
  edges: PurchaseOrderLineEdge[];
}

export interface PurchaseOrderLineConnectionPromise
  extends Promise<PurchaseOrderLineConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseOrderLineEdge>>() => T;
  aggregate: <T = AggregatePurchaseOrderLinePromise>() => T;
}

export interface PurchaseOrderLineConnectionSubscription
  extends Promise<AsyncIterator<PurchaseOrderLineConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseOrderLineEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseOrderLineSubscription>() => T;
}

export interface BankPreviousValues {
  id: ID_Output;
  name?: String;
  institution?: String;
  bsb?: String;
  accountNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BankPreviousValuesPromise
  extends Promise<BankPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  institution: () => Promise<String>;
  bsb: () => Promise<String>;
  accountNumber: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankPreviousValuesSubscription
  extends Promise<AsyncIterator<BankPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  institution: () => Promise<AsyncIterator<String>>;
  bsb: () => Promise<AsyncIterator<String>>;
  accountNumber: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePurchaseOrder {
  count: Int;
}

export interface AggregatePurchaseOrderPromise
  extends Promise<AggregatePurchaseOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseOrderSubscription
  extends Promise<AsyncIterator<AggregatePurchaseOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttachmentEdge {
  node: Attachment;
  cursor: String;
}

export interface AttachmentEdgePromise
  extends Promise<AttachmentEdge>,
    Fragmentable {
  node: <T = AttachmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttachmentEdgeSubscription
  extends Promise<AsyncIterator<AttachmentEdge>>,
    Fragmentable {
  node: <T = AttachmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PurchaseOrderConnection {
  pageInfo: PageInfo;
  edges: PurchaseOrderEdge[];
}

export interface PurchaseOrderConnectionPromise
  extends Promise<PurchaseOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseOrderEdge>>() => T;
  aggregate: <T = AggregatePurchaseOrderPromise>() => T;
}

export interface PurchaseOrderConnectionSubscription
  extends Promise<AsyncIterator<PurchaseOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseOrderSubscription>() => T;
}

export interface BankTransactionSubscriptionPayload {
  mutation: MutationType;
  node: BankTransaction;
  updatedFields: String[];
  previousValues: BankTransactionPreviousValues;
}

export interface BankTransactionSubscriptionPayloadPromise
  extends Promise<BankTransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BankTransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BankTransactionPreviousValuesPromise>() => T;
}

export interface BankTransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BankTransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BankTransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BankTransactionPreviousValuesSubscription>() => T;
}

export interface AggregateProjectServiceRule {
  count: Int;
}

export interface AggregateProjectServiceRulePromise
  extends Promise<AggregateProjectServiceRule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectServiceRuleSubscription
  extends Promise<AsyncIterator<AggregateProjectServiceRule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankTransactionPreviousValues {
  id: ID_Output;
  transactionDate: DateTimeOutput;
  amount: Float;
  description?: String;
  posted: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BankTransactionPreviousValuesPromise
  extends Promise<BankTransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transactionDate: () => Promise<DateTimeOutput>;
  amount: () => Promise<Float>;
  description: () => Promise<String>;
  posted: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankTransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<BankTransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transactionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  posted: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectServiceRuleConnection {
  pageInfo: PageInfo;
  edges: ProjectServiceRuleEdge[];
}

export interface ProjectServiceRuleConnectionPromise
  extends Promise<ProjectServiceRuleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectServiceRuleEdge>>() => T;
  aggregate: <T = AggregateProjectServiceRulePromise>() => T;
}

export interface ProjectServiceRuleConnectionSubscription
  extends Promise<AsyncIterator<ProjectServiceRuleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProjectServiceRuleEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProjectServiceRuleSubscription>() => T;
}

export interface Integration {
  id: ID_Output;
  data?: Json;
  type?: IntegrationType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface IntegrationPromise extends Promise<Integration>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  data: () => Promise<Json>;
  type: () => Promise<IntegrationType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IntegrationSubscription
  extends Promise<AsyncIterator<Integration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  data: () => Promise<AsyncIterator<Json>>;
  type: () => Promise<AsyncIterator<IntegrationType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface IntegrationNullablePromise
  extends Promise<Integration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  data: () => Promise<Json>;
  type: () => Promise<IntegrationType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServiceEdge {
  node: ProjectService;
  cursor: String;
}

export interface ProjectServiceEdgePromise
  extends Promise<ProjectServiceEdge>,
    Fragmentable {
  node: <T = ProjectServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectServiceEdgeSubscription
  extends Promise<AsyncIterator<ProjectServiceEdge>>,
    Fragmentable {
  node: <T = ProjectServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BasicDailyFeeSubscriptionPayload {
  mutation: MutationType;
  node: BasicDailyFee;
  updatedFields: String[];
  previousValues: BasicDailyFeePreviousValues;
}

export interface BasicDailyFeeSubscriptionPayloadPromise
  extends Promise<BasicDailyFeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BasicDailyFeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BasicDailyFeePreviousValuesPromise>() => T;
}

export interface BasicDailyFeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BasicDailyFeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BasicDailyFeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BasicDailyFeePreviousValuesSubscription>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BasicDailyFeePreviousValues {
  id: ID_Output;
  level?: LevelOfCare;
  rate?: Float;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
  rechargeable?: Float;
}

export interface BasicDailyFeePreviousValuesPromise
  extends Promise<BasicDailyFeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  level: () => Promise<LevelOfCare>;
  rate: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
  rechargeable: () => Promise<Float>;
}

export interface BasicDailyFeePreviousValuesSubscription
  extends Promise<AsyncIterator<BasicDailyFeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  level: () => Promise<AsyncIterator<LevelOfCare>>;
  rate: () => Promise<AsyncIterator<Float>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  rechargeable: () => Promise<AsyncIterator<Float>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface AggregateImmunisationSchedule {
  count: Int;
}

export interface AggregateImmunisationSchedulePromise
  extends Promise<AggregateImmunisationSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImmunisationScheduleSubscription
  extends Promise<AsyncIterator<AggregateImmunisationSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePredictedSalesValueByCompany {
  count: Int;
}

export interface AggregatePredictedSalesValueByCompanyPromise
  extends Promise<AggregatePredictedSalesValueByCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePredictedSalesValueByCompanySubscription
  extends Promise<AsyncIterator<AggregatePredictedSalesValueByCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface PredictedSalesValueByCompanyConnection {
  pageInfo: PageInfo;
  edges: PredictedSalesValueByCompanyEdge[];
}

export interface PredictedSalesValueByCompanyConnectionPromise
  extends Promise<PredictedSalesValueByCompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PredictedSalesValueByCompanyEdge>>() => T;
  aggregate: <T = AggregatePredictedSalesValueByCompanyPromise>() => T;
}

export interface PredictedSalesValueByCompanyConnectionSubscription
  extends Promise<AsyncIterator<PredictedSalesValueByCompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PredictedSalesValueByCompanyEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePredictedSalesValueByCompanySubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  bankAccount?: Json;
  businessType?: BusinessType;
  country: Country;
  govNumber?: String;
  currency: Currency;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  HPIO?: String;
  legalName: String;
  name: String;
  salesTax?: Boolean;
  timeSheetSettings?: Json;
  websiteURL?: String;
  stripeCustomerId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bankAccount: () => Promise<Json>;
  businessType: () => Promise<BusinessType>;
  country: () => Promise<Country>;
  govNumber: () => Promise<String>;
  currency: () => Promise<Currency>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  HPIO: () => Promise<String>;
  legalName: () => Promise<String>;
  name: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  timeSheetSettings: () => Promise<Json>;
  websiteURL: () => Promise<String>;
  stripeCustomerId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bankAccount: () => Promise<AsyncIterator<Json>>;
  businessType: () => Promise<AsyncIterator<BusinessType>>;
  country: () => Promise<AsyncIterator<Country>>;
  govNumber: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  HPIO: () => Promise<AsyncIterator<String>>;
  legalName: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  salesTax: () => Promise<AsyncIterator<Boolean>>;
  timeSheetSettings: () => Promise<AsyncIterator<Json>>;
  websiteURL: () => Promise<AsyncIterator<String>>;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PredictedSalesValueByCompany {
  id: ID_Output;
  datePredictionRun?: DateTimeOutput;
  predictedSalesValue?: Float;
  predictedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PredictedSalesValueByCompanyPromise
  extends Promise<PredictedSalesValueByCompany>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PredictedSalesValueByCompanySubscription
  extends Promise<AsyncIterator<PredictedSalesValueByCompany>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datePredictionRun: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  predictedSalesValue: () => Promise<AsyncIterator<Float>>;
  predictedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PredictedSalesValueByCompanyNullablePromise
  extends Promise<PredictedSalesValueByCompany | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImmunisationScheduleEdge {
  node: ImmunisationSchedule;
  cursor: String;
}

export interface ImmunisationScheduleEdgePromise
  extends Promise<ImmunisationScheduleEdge>,
    Fragmentable {
  node: <T = ImmunisationSchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImmunisationScheduleEdgeSubscription
  extends Promise<AsyncIterator<ImmunisationScheduleEdge>>,
    Fragmentable {
  node: <T = ImmunisationScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PredictedSalesQuantityOfItemsByCompanyEdge {
  node: PredictedSalesQuantityOfItemsByCompany;
  cursor: String;
}

export interface PredictedSalesQuantityOfItemsByCompanyEdgePromise
  extends Promise<PredictedSalesQuantityOfItemsByCompanyEdge>,
    Fragmentable {
  node: <T = PredictedSalesQuantityOfItemsByCompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PredictedSalesQuantityOfItemsByCompanyEdgeSubscription
  extends Promise<AsyncIterator<PredictedSalesQuantityOfItemsByCompanyEdge>>,
    Fragmentable {
  node: <T = PredictedSalesQuantityOfItemsByCompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyMemberSubscriptionPayload {
  mutation: MutationType;
  node: CompanyMember;
  updatedFields: String[];
  previousValues: CompanyMemberPreviousValues;
}

export interface CompanyMemberSubscriptionPayloadPromise
  extends Promise<CompanyMemberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyMemberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyMemberPreviousValuesPromise>() => T;
}

export interface CompanyMemberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanyMemberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanyMemberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyMemberPreviousValuesSubscription>() => T;
}

export interface WareHouseSubscriptionPayload {
  mutation: MutationType;
  node: WareHouse;
  updatedFields: String[];
  previousValues: WareHousePreviousValues;
}

export interface WareHouseSubscriptionPayloadPromise
  extends Promise<WareHouseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WareHousePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WareHousePreviousValuesPromise>() => T;
}

export interface WareHouseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WareHouseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WareHouseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WareHousePreviousValuesSubscription>() => T;
}

export interface CompanyMemberPreviousValues {
  id: ID_Output;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  role?: CompanyMemberRole;
  status?: CompanyMemberStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyMemberPreviousValuesPromise
  extends Promise<CompanyMemberPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  role: () => Promise<CompanyMemberRole>;
  status: () => Promise<CompanyMemberStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyMemberPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyMemberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<CompanyMemberRole>>;
  status: () => Promise<AsyncIterator<CompanyMemberStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePoReceipt {
  count: Int;
}

export interface AggregatePoReceiptPromise
  extends Promise<AggregatePoReceipt>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePoReceiptSubscription
  extends Promise<AsyncIterator<AggregatePoReceipt>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImmunisationScheduleConnection {
  pageInfo: PageInfo;
  edges: ImmunisationScheduleEdge[];
}

export interface ImmunisationScheduleConnectionPromise
  extends Promise<ImmunisationScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImmunisationScheduleEdge>>() => T;
  aggregate: <T = AggregateImmunisationSchedulePromise>() => T;
}

export interface ImmunisationScheduleConnectionSubscription
  extends Promise<AsyncIterator<ImmunisationScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ImmunisationScheduleEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateImmunisationScheduleSubscription>() => T;
}

export interface PoReceiptConnection {
  pageInfo: PageInfo;
  edges: PoReceiptEdge[];
}

export interface PoReceiptConnectionPromise
  extends Promise<PoReceiptConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PoReceiptEdge>>() => T;
  aggregate: <T = AggregatePoReceiptPromise>() => T;
}

export interface PoReceiptConnectionSubscription
  extends Promise<AsyncIterator<PoReceiptConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PoReceiptEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePoReceiptSubscription>() => T;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface PoReceipt {
  id: ID_Output;
  receiptNumber?: String;
  receiptDate?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PoReceiptPromise extends Promise<PoReceipt>, Fragmentable {
  id: () => Promise<ID_Output>;
  receiptNumber: () => Promise<String>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  receiptDate: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PoReceiptSubscription
  extends Promise<AsyncIterator<PoReceipt>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  receiptNumber: () => Promise<AsyncIterator<String>>;
  purchaseOrder: <T = PurchaseOrderSubscription>() => T;
  receiptDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PoReceiptNullablePromise
  extends Promise<PoReceipt | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  receiptNumber: () => Promise<String>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  receiptDate: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  name?: String;
  surname?: String;
  email?: String;
  mobileCode?: String;
  mobileNumber?: String;
  landlineCode?: String;
  landlineNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
  email: () => Promise<String>;
  mobileCode: () => Promise<String>;
  mobileNumber: () => Promise<String>;
  landlineCode: () => Promise<String>;
  landlineNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  surname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobileCode: () => Promise<AsyncIterator<String>>;
  mobileNumber: () => Promise<AsyncIterator<String>>;
  landlineCode: () => Promise<AsyncIterator<String>>;
  landlineNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanEdge {
  node: Plan;
  cursor: String;
}

export interface PlanEdgePromise extends Promise<PlanEdge>, Fragmentable {
  node: <T = PlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanEdgeSubscription
  extends Promise<AsyncIterator<PlanEdge>>,
    Fragmentable {
  node: <T = PlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttachment {
  count: Int;
}

export interface AggregateAttachmentPromise
  extends Promise<AggregateAttachment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttachmentSubscription
  extends Promise<AsyncIterator<AggregateAttachment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Company {
  id: ID_Output;
  bankAccount?: Json;
  businessType?: BusinessType;
  country: Country;
  govNumber?: String;
  currency: Currency;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  HPIO?: String;
  legalName: String;
  name: String;
  salesTax?: Boolean;
  timeSheetSettings?: Json;
  websiteURL?: String;
  stripeCustomerId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  bankAccount: () => Promise<Json>;
  businessType: () => Promise<BusinessType>;
  country: () => Promise<Country>;
  govNumber: () => Promise<String>;
  currency: () => Promise<Currency>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  HPIO: () => Promise<String>;
  legalName: () => Promise<String>;
  logo: <T = AttachmentPromise>() => T;
  name: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  timeSheetSettings: () => Promise<Json>;
  websiteURL: () => Promise<String>;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyMembers: <T = FragmentableArray<CompanyMember>>(args?: {
    where?: CompanyMemberWhereInput;
    orderBy?: CompanyMemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activePlan: <T = PlanPromise>() => T;
  stripeCustomerId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bankAccount: () => Promise<AsyncIterator<Json>>;
  businessType: () => Promise<AsyncIterator<BusinessType>>;
  country: () => Promise<AsyncIterator<Country>>;
  govNumber: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  HPIO: () => Promise<AsyncIterator<String>>;
  legalName: () => Promise<AsyncIterator<String>>;
  logo: <T = AttachmentSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  salesTax: () => Promise<AsyncIterator<Boolean>>;
  timeSheetSettings: () => Promise<AsyncIterator<Json>>;
  websiteURL: () => Promise<AsyncIterator<String>>;
  addresses: <T = Promise<AsyncIterator<AddressSubscription>>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyMembers: <
    T = Promise<AsyncIterator<CompanyMemberSubscription>>
  >(args?: {
    where?: CompanyMemberWhereInput;
    orderBy?: CompanyMemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activePlan: <T = PlanSubscription>() => T;
  stripeCustomerId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bankAccount: () => Promise<Json>;
  businessType: () => Promise<BusinessType>;
  country: () => Promise<Country>;
  govNumber: () => Promise<String>;
  currency: () => Promise<Currency>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  HPIO: () => Promise<String>;
  legalName: () => Promise<String>;
  logo: <T = AttachmentPromise>() => T;
  name: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  timeSheetSettings: () => Promise<Json>;
  websiteURL: () => Promise<String>;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  companyMembers: <T = FragmentableArray<CompanyMember>>(args?: {
    where?: CompanyMemberWhereInput;
    orderBy?: CompanyMemberOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  activePlan: <T = PlanPromise>() => T;
  stripeCustomerId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface PbsTPPEdge {
  node: PbsTPP;
  cursor: String;
}

export interface PbsTPPEdgePromise extends Promise<PbsTPPEdge>, Fragmentable {
  node: <T = PbsTPPPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PbsTPPEdgeSubscription
  extends Promise<AsyncIterator<PbsTPPEdge>>,
    Fragmentable {
  node: <T = PbsTPPSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerPreviousValues {
  id: ID_Output;
  description?: String;
  govNumber?: String;
  salesTax?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  name?: String;
  billingFrequency?: SupplierTermsOfPayment;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  govNumber: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  billingFrequency: () => Promise<SupplierTermsOfPayment>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  govNumber: () => Promise<AsyncIterator<String>>;
  salesTax: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  billingFrequency: () => Promise<AsyncIterator<SupplierTermsOfPayment>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Attachment {
  id: ID_Output;
  description?: String;
  fileName?: String;
  label?: String;
  url?: String;
  s3Bucket?: String;
  s3Key?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AttachmentPromise extends Promise<Attachment>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  fileName: () => Promise<String>;
  label: () => Promise<String>;
  url: () => Promise<String>;
  s3Bucket: () => Promise<String>;
  s3Key: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AttachmentSubscription
  extends Promise<AsyncIterator<Attachment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  fileName: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  s3Bucket: () => Promise<AsyncIterator<String>>;
  s3Key: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AttachmentNullablePromise
  extends Promise<Attachment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  fileName: () => Promise<String>;
  label: () => Promise<String>;
  url: () => Promise<String>;
  s3Bucket: () => Promise<String>;
  s3Key: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VaccineBrand {
  id: ID_Output;
  name?: String;
}

export interface VaccineBrandPromise
  extends Promise<VaccineBrand>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface VaccineBrandSubscription
  extends Promise<AsyncIterator<VaccineBrand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface VaccineBrandNullablePromise
  extends Promise<VaccineBrand | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AggregatePbsOrganisation {
  count: Int;
}

export interface AggregatePbsOrganisationPromise
  extends Promise<AggregatePbsOrganisation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePbsOrganisationSubscription
  extends Promise<AsyncIterator<AggregatePbsOrganisation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiseaseSubscriptionPayload {
  mutation: MutationType;
  node: Disease;
  updatedFields: String[];
  previousValues: DiseasePreviousValues;
}

export interface DiseaseSubscriptionPayloadPromise
  extends Promise<DiseaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiseasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiseasePreviousValuesPromise>() => T;
}

export interface DiseaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiseaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiseaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiseasePreviousValuesSubscription>() => T;
}

export interface PbsOrganisationConnection {
  pageInfo: PageInfo;
  edges: PbsOrganisationEdge[];
}

export interface PbsOrganisationConnectionPromise
  extends Promise<PbsOrganisationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PbsOrganisationEdge>>() => T;
  aggregate: <T = AggregatePbsOrganisationPromise>() => T;
}

export interface PbsOrganisationConnectionSubscription
  extends Promise<AsyncIterator<PbsOrganisationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PbsOrganisationEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePbsOrganisationSubscription>() => T;
}

export interface DiseasePreviousValues {
  id: ID_Output;
  name?: String;
}

export interface DiseasePreviousValuesPromise
  extends Promise<DiseasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DiseasePreviousValuesSubscription
  extends Promise<AsyncIterator<DiseasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PbsOrganisation {
  id: ID_Output;
  code?: String;
  title?: String;
  street?: String;
  city?: String;
  stateAddress?: String;
  postcode?: String;
  phone?: String;
  effectiveFrom?: DateTimeOutput;
  effectiveTo?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PbsOrganisationPromise
  extends Promise<PbsOrganisation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  stateAddress: () => Promise<String>;
  postcode: () => Promise<String>;
  phone: () => Promise<String>;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PbsOrganisationSubscription
  extends Promise<AsyncIterator<PbsOrganisation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  stateAddress: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  effectiveFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  effectiveTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PbsOrganisationNullablePromise
  extends Promise<PbsOrganisation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  stateAddress: () => Promise<String>;
  postcode: () => Promise<String>;
  phone: () => Promise<String>;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImmunisationSchedule {
  id: ID_Output;
  ageNumber?: Int;
  agePeriod?: PeriodUnit;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImmunisationSchedulePromise
  extends Promise<ImmunisationSchedule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ageNumber: () => Promise<Int>;
  agePeriod: () => Promise<PeriodUnit>;
  disease: <T = DiseasePromise>() => T;
  vaccineBrand: <T = VaccineBrandPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImmunisationScheduleSubscription
  extends Promise<AsyncIterator<ImmunisationSchedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ageNumber: () => Promise<AsyncIterator<Int>>;
  agePeriod: () => Promise<AsyncIterator<PeriodUnit>>;
  disease: <T = DiseaseSubscription>() => T;
  vaccineBrand: <T = VaccineBrandSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImmunisationScheduleNullablePromise
  extends Promise<ImmunisationSchedule | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ageNumber: () => Promise<Int>;
  agePeriod: () => Promise<PeriodUnit>;
  disease: <T = DiseasePromise>() => T;
  vaccineBrand: <T = VaccineBrandPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatientEdge {
  node: Patient;
  cursor: String;
}

export interface PatientEdgePromise extends Promise<PatientEdge>, Fragmentable {
  node: <T = PatientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PatientEdgeSubscription
  extends Promise<AsyncIterator<PatientEdge>>,
    Fragmentable {
  node: <T = PatientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HILogSubscriptionPayload {
  mutation: MutationType;
  node: HILog;
  updatedFields: String[];
  previousValues: HILogPreviousValues;
}

export interface HILogSubscriptionPayloadPromise
  extends Promise<HILogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HILogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HILogPreviousValuesPromise>() => T;
}

export interface HILogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HILogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HILogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HILogPreviousValuesSubscription>() => T;
}

export interface Patient {
  id: ID_Output;
  title?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  gender?: Gender;
  dvaCardType?: DVACardType;
  aboriginalStatus?: AboriginalStatus;
  pensionerConcession?: String;
  commonwealthSeniors?: String;
  healthcareConcession?: String;
  safetyNetConcession?: Float;
  medicareNumber?: String;
  DVA?: String;
  potentialDuplicate?: Boolean;
  oneName?: Boolean;
  ihi?: String;
  ihiValidatedDate?: DateTimeOutput;
  noOfBirths?: Int;
  deceasedDate?: DateTimeOutput;
  levelOfCare?: LevelOfCare;
  dateEnteredAgedCare?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatientPromise extends Promise<Patient>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  names: <T = FragmentableArray<Name>>(args?: {
    where?: NameWhereInput;
    orderBy?: NameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressPromise>() => T;
  birthAddress: <T = AddressPromise>() => T;
  dateOfBirth: () => Promise<DateTimeOutput>;
  customer: <T = CustomerPromise>() => T;
  gender: () => Promise<Gender>;
  dvaCardType: () => Promise<DVACardType>;
  aboriginalStatus: () => Promise<AboriginalStatus>;
  pensionerConcession: () => Promise<String>;
  commonwealthSeniors: () => Promise<String>;
  healthcareConcession: () => Promise<String>;
  safetyNetConcession: () => Promise<Float>;
  medicareNumber: () => Promise<String>;
  DVA: () => Promise<String>;
  potentialDuplicate: () => Promise<Boolean>;
  oneName: () => Promise<Boolean>;
  ihi: () => Promise<String>;
  ihiValidatedDate: () => Promise<DateTimeOutput>;
  noOfBirths: () => Promise<Int>;
  deceasedDate: () => Promise<DateTimeOutput>;
  basicDailyFee: <T = FragmentableArray<BasicDailyFee>>(args?: {
    where?: BasicDailyFeeWhereInput;
    orderBy?: BasicDailyFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  levelOfCare: () => Promise<LevelOfCare>;
  dateEnteredAgedCare: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatientSubscription
  extends Promise<AsyncIterator<Patient>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  names: <T = Promise<AsyncIterator<NameSubscription>>>(args?: {
    where?: NameWhereInput;
    orderBy?: NameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressSubscription>() => T;
  birthAddress: <T = AddressSubscription>() => T;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  customer: <T = CustomerSubscription>() => T;
  gender: () => Promise<AsyncIterator<Gender>>;
  dvaCardType: () => Promise<AsyncIterator<DVACardType>>;
  aboriginalStatus: () => Promise<AsyncIterator<AboriginalStatus>>;
  pensionerConcession: () => Promise<AsyncIterator<String>>;
  commonwealthSeniors: () => Promise<AsyncIterator<String>>;
  healthcareConcession: () => Promise<AsyncIterator<String>>;
  safetyNetConcession: () => Promise<AsyncIterator<Float>>;
  medicareNumber: () => Promise<AsyncIterator<String>>;
  DVA: () => Promise<AsyncIterator<String>>;
  potentialDuplicate: () => Promise<AsyncIterator<Boolean>>;
  oneName: () => Promise<AsyncIterator<Boolean>>;
  ihi: () => Promise<AsyncIterator<String>>;
  ihiValidatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  noOfBirths: () => Promise<AsyncIterator<Int>>;
  deceasedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  basicDailyFee: <
    T = Promise<AsyncIterator<BasicDailyFeeSubscription>>
  >(args?: {
    where?: BasicDailyFeeWhereInput;
    orderBy?: BasicDailyFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  levelOfCare: () => Promise<AsyncIterator<LevelOfCare>>;
  dateEnteredAgedCare: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatientNullablePromise
  extends Promise<Patient | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  names: <T = FragmentableArray<Name>>(args?: {
    where?: NameWhereInput;
    orderBy?: NameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressPromise>() => T;
  birthAddress: <T = AddressPromise>() => T;
  dateOfBirth: () => Promise<DateTimeOutput>;
  customer: <T = CustomerPromise>() => T;
  gender: () => Promise<Gender>;
  dvaCardType: () => Promise<DVACardType>;
  aboriginalStatus: () => Promise<AboriginalStatus>;
  pensionerConcession: () => Promise<String>;
  commonwealthSeniors: () => Promise<String>;
  healthcareConcession: () => Promise<String>;
  safetyNetConcession: () => Promise<Float>;
  medicareNumber: () => Promise<String>;
  DVA: () => Promise<String>;
  potentialDuplicate: () => Promise<Boolean>;
  oneName: () => Promise<Boolean>;
  ihi: () => Promise<String>;
  ihiValidatedDate: () => Promise<DateTimeOutput>;
  noOfBirths: () => Promise<Int>;
  deceasedDate: () => Promise<DateTimeOutput>;
  basicDailyFee: <T = FragmentableArray<BasicDailyFee>>(args?: {
    where?: BasicDailyFeeWhereInput;
    orderBy?: BasicDailyFeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  levelOfCare: () => Promise<LevelOfCare>;
  dateEnteredAgedCare: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HILogPreviousValues {
  id: ID_Output;
  hpio?: String;
  hpii?: String;
  ihi?: String;
  timeWaitedForSalus?: Int;
  csp?: String;
  hiWebServiceUsed?: String;
  hiWebServiceVersion?: String;
  hiNumberStatus?: HINumberStatus;
  recordStatus?: String;
  salusResponse?: SalusResponse;
  failureMessage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HILogPreviousValuesPromise
  extends Promise<HILogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hpio: () => Promise<String>;
  hpii: () => Promise<String>;
  ihi: () => Promise<String>;
  timeWaitedForSalus: () => Promise<Int>;
  csp: () => Promise<String>;
  hiWebServiceUsed: () => Promise<String>;
  hiWebServiceVersion: () => Promise<String>;
  hiNumberStatus: () => Promise<HINumberStatus>;
  recordStatus: () => Promise<String>;
  salusResponse: () => Promise<SalusResponse>;
  failureMessage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HILogPreviousValuesSubscription
  extends Promise<AsyncIterator<HILogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hpio: () => Promise<AsyncIterator<String>>;
  hpii: () => Promise<AsyncIterator<String>>;
  ihi: () => Promise<AsyncIterator<String>>;
  timeWaitedForSalus: () => Promise<AsyncIterator<Int>>;
  csp: () => Promise<AsyncIterator<String>>;
  hiWebServiceUsed: () => Promise<AsyncIterator<String>>;
  hiWebServiceVersion: () => Promise<AsyncIterator<String>>;
  hiNumberStatus: () => Promise<AsyncIterator<HINumberStatus>>;
  recordStatus: () => Promise<AsyncIterator<String>>;
  salusResponse: () => Promise<AsyncIterator<SalusResponse>>;
  failureMessage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NameEdge {
  node: Name;
  cursor: String;
}

export interface NameEdgePromise extends Promise<NameEdge>, Fragmentable {
  node: <T = NamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NameEdgeSubscription
  extends Promise<AsyncIterator<NameEdge>>,
    Fragmentable {
  node: <T = NameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHealthcareProvider {
  count: Int;
}

export interface AggregateHealthcareProviderPromise
  extends Promise<AggregateHealthcareProvider>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHealthcareProviderSubscription
  extends Promise<AsyncIterator<AggregateHealthcareProvider>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Name {
  id: ID_Output;
  name?: String;
  isPrimary?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NamePromise extends Promise<Name>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isPrimary: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NameSubscription
  extends Promise<AsyncIterator<Name>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NameNullablePromise
  extends Promise<Name | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isPrimary: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HealthcareProviderSubscriptionPayload {
  mutation: MutationType;
  node: HealthcareProvider;
  updatedFields: String[];
  previousValues: HealthcareProviderPreviousValues;
}

export interface HealthcareProviderSubscriptionPayloadPromise
  extends Promise<HealthcareProviderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HealthcareProviderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HealthcareProviderPreviousValuesPromise>() => T;
}

export interface HealthcareProviderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HealthcareProviderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HealthcareProviderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HealthcareProviderPreviousValuesSubscription>() => T;
}

export interface MedicareServiceEdge {
  node: MedicareService;
  cursor: String;
}

export interface MedicareServiceEdgePromise
  extends Promise<MedicareServiceEdge>,
    Fragmentable {
  node: <T = MedicareServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MedicareServiceEdgeSubscription
  extends Promise<AsyncIterator<MedicareServiceEdge>>,
    Fragmentable {
  node: <T = MedicareServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HealthcareProviderPreviousValues {
  id: ID_Output;
  occupation?: String;
  hpii?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  emailAddress?: String;
  gender?: Gender;
  ahpraNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HealthcareProviderPreviousValuesPromise
  extends Promise<HealthcareProviderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occupation: () => Promise<String>;
  hpii: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  emailAddress: () => Promise<String>;
  gender: () => Promise<Gender>;
  ahpraNumber: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HealthcareProviderPreviousValuesSubscription
  extends Promise<AsyncIterator<HealthcareProviderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  occupation: () => Promise<AsyncIterator<String>>;
  hpii: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  emailAddress: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  ahpraNumber: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBankTransaction {
  count: Int;
}

export interface AggregateBankTransactionPromise
  extends Promise<AggregateBankTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBankTransactionSubscription
  extends Promise<AsyncIterator<AggregateBankTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HealthcareProviderEdge {
  node: HealthcareProvider;
  cursor: String;
}

export interface HealthcareProviderEdgePromise
  extends Promise<HealthcareProviderEdge>,
    Fragmentable {
  node: <T = HealthcareProviderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HealthcareProviderEdgeSubscription
  extends Promise<AsyncIterator<HealthcareProviderEdge>>,
    Fragmentable {
  node: <T = HealthcareProviderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeansTestedFee {
  count: Int;
}

export interface AggregateMeansTestedFeePromise
  extends Promise<AggregateMeansTestedFee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeansTestedFeeSubscription
  extends Promise<AsyncIterator<AggregateMeansTestedFee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImmunisationScheduleSubscriptionPayload {
  mutation: MutationType;
  node: ImmunisationSchedule;
  updatedFields: String[];
  previousValues: ImmunisationSchedulePreviousValues;
}

export interface ImmunisationScheduleSubscriptionPayloadPromise
  extends Promise<ImmunisationScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImmunisationSchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImmunisationSchedulePreviousValuesPromise>() => T;
}

export interface ImmunisationScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImmunisationScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImmunisationScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImmunisationSchedulePreviousValuesSubscription>() => T;
}

export interface MeansTestedFeeConnection {
  pageInfo: PageInfo;
  edges: MeansTestedFeeEdge[];
}

export interface MeansTestedFeeConnectionPromise
  extends Promise<MeansTestedFeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeansTestedFeeEdge>>() => T;
  aggregate: <T = AggregateMeansTestedFeePromise>() => T;
}

export interface MeansTestedFeeConnectionSubscription
  extends Promise<AsyncIterator<MeansTestedFeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeansTestedFeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeansTestedFeeSubscription>() => T;
}

export interface ImmunisationSchedulePreviousValues {
  id: ID_Output;
  ageNumber?: Int;
  agePeriod?: PeriodUnit;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImmunisationSchedulePreviousValuesPromise
  extends Promise<ImmunisationSchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ageNumber: () => Promise<Int>;
  agePeriod: () => Promise<PeriodUnit>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImmunisationSchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<ImmunisationSchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ageNumber: () => Promise<AsyncIterator<Int>>;
  agePeriod: () => Promise<AsyncIterator<PeriodUnit>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeansTestLimitsEdge {
  node: MeansTestLimits;
  cursor: String;
}

export interface MeansTestLimitsEdgePromise
  extends Promise<MeansTestLimitsEdge>,
    Fragmentable {
  node: <T = MeansTestLimitsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeansTestLimitsEdgeSubscription
  extends Promise<AsyncIterator<MeansTestLimitsEdge>>,
    Fragmentable {
  node: <T = MeansTestLimitsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HealthcareProviderConnection {
  pageInfo: PageInfo;
  edges: HealthcareProviderEdge[];
}

export interface HealthcareProviderConnectionPromise
  extends Promise<HealthcareProviderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HealthcareProviderEdge>>() => T;
  aggregate: <T = AggregateHealthcareProviderPromise>() => T;
}

export interface HealthcareProviderConnectionSubscription
  extends Promise<AsyncIterator<HealthcareProviderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<HealthcareProviderEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateHealthcareProviderSubscription>() => T;
}

export interface CompanyMember {
  id: ID_Output;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  role?: CompanyMemberRole;
  status?: CompanyMemberStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CompanyMemberPromise
  extends Promise<CompanyMember>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  role: () => Promise<CompanyMemberRole>;
  status: () => Promise<CompanyMemberStatus>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CompanyMemberSubscription
  extends Promise<AsyncIterator<CompanyMember>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<CompanyMemberRole>>;
  status: () => Promise<AsyncIterator<CompanyMemberStatus>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanyMemberNullablePromise
  extends Promise<CompanyMember | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  role: () => Promise<CompanyMemberRole>;
  status: () => Promise<CompanyMemberStatus>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IntegrationSubscriptionPayload {
  mutation: MutationType;
  node: Integration;
  updatedFields: String[];
  previousValues: IntegrationPreviousValues;
}

export interface IntegrationSubscriptionPayloadPromise
  extends Promise<IntegrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IntegrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IntegrationPreviousValuesPromise>() => T;
}

export interface IntegrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IntegrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IntegrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IntegrationPreviousValuesSubscription>() => T;
}

export interface AggregateMainAccount {
  count: Int;
}

export interface AggregateMainAccountPromise
  extends Promise<AggregateMainAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMainAccountSubscription
  extends Promise<AsyncIterator<AggregateMainAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IntegrationPreviousValues {
  id: ID_Output;
  data?: Json;
  type?: IntegrationType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface IntegrationPreviousValuesPromise
  extends Promise<IntegrationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  data: () => Promise<Json>;
  type: () => Promise<IntegrationType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface IntegrationPreviousValuesSubscription
  extends Promise<AsyncIterator<IntegrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  data: () => Promise<AsyncIterator<Json>>;
  type: () => Promise<AsyncIterator<IntegrationType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MainAccountConnection {
  pageInfo: PageInfo;
  edges: MainAccountEdge[];
}

export interface MainAccountConnectionPromise
  extends Promise<MainAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MainAccountEdge>>() => T;
  aggregate: <T = AggregateMainAccountPromise>() => T;
}

export interface MainAccountConnectionSubscription
  extends Promise<AsyncIterator<MainAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MainAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMainAccountSubscription>() => T;
}

export interface Bank {
  id: ID_Output;
  name?: String;
  institution?: String;
  bsb?: String;
  accountNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BankPromise extends Promise<Bank>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  institution: () => Promise<String>;
  bsb: () => Promise<String>;
  accountNumber: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankSubscription
  extends Promise<AsyncIterator<Bank>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  institution: () => Promise<AsyncIterator<String>>;
  bsb: () => Promise<AsyncIterator<String>>;
  accountNumber: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BankNullablePromise
  extends Promise<Bank | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  institution: () => Promise<String>;
  bsb: () => Promise<String>;
  accountNumber: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateLedgerTransaction {
  count: Int;
}

export interface AggregateLedgerTransactionPromise
  extends Promise<AggregateLedgerTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLedgerTransactionSubscription
  extends Promise<AsyncIterator<AggregateLedgerTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface LedgerTransactionConnection {
  pageInfo: PageInfo;
  edges: LedgerTransactionEdge[];
}

export interface LedgerTransactionConnectionPromise
  extends Promise<LedgerTransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LedgerTransactionEdge>>() => T;
  aggregate: <T = AggregateLedgerTransactionPromise>() => T;
}

export interface LedgerTransactionConnectionSubscription
  extends Promise<AsyncIterator<LedgerTransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LedgerTransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLedgerTransactionSubscription>() => T;
}

export interface InventoryPreviousValues {
  id: ID_Output;
  name?: String;
  inventoryModel?: InventoryModel;
  uom?: UOM;
  price?: Float;
  SellingPrice?: Float;
  Barcode?: String;
  Taxable?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  inventoryModel: () => Promise<InventoryModel>;
  uom: () => Promise<UOM>;
  price: () => Promise<Float>;
  SellingPrice: () => Promise<Float>;
  Barcode: () => Promise<String>;
  Taxable: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  inventoryModel: () => Promise<AsyncIterator<InventoryModel>>;
  uom: () => Promise<AsyncIterator<UOM>>;
  price: () => Promise<AsyncIterator<Float>>;
  SellingPrice: () => Promise<AsyncIterator<Float>>;
  Barcode: () => Promise<AsyncIterator<String>>;
  Taxable: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateLedgerPosting {
  count: Int;
}

export interface AggregateLedgerPostingPromise
  extends Promise<AggregateLedgerPosting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLedgerPostingSubscription
  extends Promise<AsyncIterator<AggregateLedgerPosting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HealthcareProvider {
  id: ID_Output;
  occupation?: String;
  hpii?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  emailAddress?: String;
  gender?: Gender;
  ahpraNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HealthcareProviderPromise
  extends Promise<HealthcareProvider>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occupation: () => Promise<String>;
  hpii: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  emailAddress: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: <T = AddressPromise>() => T;
  company: <T = CompanyPromise>() => T;
  ahpraNumber: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HealthcareProviderSubscription
  extends Promise<AsyncIterator<HealthcareProvider>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  occupation: () => Promise<AsyncIterator<String>>;
  hpii: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  emailAddress: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  address: <T = AddressSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  ahpraNumber: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HealthcareProviderNullablePromise
  extends Promise<HealthcareProvider | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  occupation: () => Promise<String>;
  hpii: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  emailAddress: () => Promise<String>;
  gender: () => Promise<Gender>;
  address: <T = AddressPromise>() => T;
  company: <T = CompanyPromise>() => T;
  ahpraNumber: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerPostingConnection {
  pageInfo: PageInfo;
  edges: LedgerPostingEdge[];
}

export interface LedgerPostingConnectionPromise
  extends Promise<LedgerPostingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LedgerPostingEdge>>() => T;
  aggregate: <T = AggregateLedgerPostingPromise>() => T;
}

export interface LedgerPostingConnectionSubscription
  extends Promise<AsyncIterator<LedgerPostingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LedgerPostingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLedgerPostingSubscription>() => T;
}

export interface InventoryOnHandSubscriptionPayload {
  mutation: MutationType;
  node: InventoryOnHand;
  updatedFields: String[];
  previousValues: InventoryOnHandPreviousValues;
}

export interface InventoryOnHandSubscriptionPayloadPromise
  extends Promise<InventoryOnHandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryOnHandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryOnHandPreviousValuesPromise>() => T;
}

export interface InventoryOnHandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventoryOnHandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventoryOnHandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryOnHandPreviousValuesSubscription>() => T;
}

export interface LedgerPosting {
  id: ID_Output;
  postingType?: PostingType;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerPostingPromise
  extends Promise<LedgerPosting>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  postingType: () => Promise<PostingType>;
  mainAccount: <T = MainAccountPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerPostingSubscription
  extends Promise<AsyncIterator<LedgerPosting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  postingType: () => Promise<AsyncIterator<PostingType>>;
  mainAccount: <T = MainAccountSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerPostingNullablePromise
  extends Promise<LedgerPosting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  postingType: () => Promise<PostingType>;
  mainAccount: <T = MainAccountPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryOnHandPreviousValues {
  id: ID_Output;
  date?: DateTimeOutput;
  pbsDrug?: String;
  onHandQty?: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryOnHandPreviousValuesPromise
  extends Promise<InventoryOnHandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  pbsDrug: () => Promise<String>;
  onHandQty: () => Promise<Int>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryOnHandPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryOnHandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  pbsDrug: () => Promise<AsyncIterator<String>>;
  onHandQty: () => Promise<AsyncIterator<Int>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerJournalEdge {
  node: LedgerJournal;
  cursor: String;
}

export interface LedgerJournalEdgePromise
  extends Promise<LedgerJournalEdge>,
    Fragmentable {
  node: <T = LedgerJournalPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LedgerJournalEdgeSubscription
  extends Promise<AsyncIterator<LedgerJournalEdge>>,
    Fragmentable {
  node: <T = LedgerJournalSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHILog {
  count: Int;
}

export interface AggregateHILogPromise
  extends Promise<AggregateHILog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHILogSubscription
  extends Promise<AsyncIterator<AggregateHILog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ApInvoiceEdge {
  node: ApInvoice;
  cursor: String;
}

export interface ApInvoiceEdgePromise
  extends Promise<ApInvoiceEdge>,
    Fragmentable {
  node: <T = ApInvoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApInvoiceEdgeSubscription
  extends Promise<AsyncIterator<ApInvoiceEdge>>,
    Fragmentable {
  node: <T = ApInvoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InvoiceSubscriptionPayload {
  mutation: MutationType;
  node: Invoice;
  updatedFields: String[];
  previousValues: InvoicePreviousValues;
}

export interface InvoiceSubscriptionPayloadPromise
  extends Promise<InvoiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvoicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvoicePreviousValuesPromise>() => T;
}

export interface InvoiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvoiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvoiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvoicePreviousValuesSubscription>() => T;
}

export interface InvoiceItemEntryEdge {
  node: InvoiceItemEntry;
  cursor: String;
}

export interface InvoiceItemEntryEdgePromise
  extends Promise<InvoiceItemEntryEdge>,
    Fragmentable {
  node: <T = InvoiceItemEntryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvoiceItemEntryEdgeSubscription
  extends Promise<AsyncIterator<InvoiceItemEntryEdge>>,
    Fragmentable {
  node: <T = InvoiceItemEntrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InvoicePreviousValues {
  id: ID_Output;
  title?: String;
  number?: Int;
  description?: String;
  invoiceDate?: DateTimeOutput;
  dueDate?: DateTimeOutput;
  status?: InvoiceStatus;
  type?: InvoiceType;
  total?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoicePreviousValuesPromise
  extends Promise<InvoicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  description: () => Promise<String>;
  invoiceDate: () => Promise<DateTimeOutput>;
  dueDate: () => Promise<DateTimeOutput>;
  status: () => Promise<InvoiceStatus>;
  type: () => Promise<InvoiceType>;
  total: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoicePreviousValuesSubscription
  extends Promise<AsyncIterator<InvoicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  invoiceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<InvoiceStatus>>;
  type: () => Promise<AsyncIterator<InvoiceType>>;
  total: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInvoice {
  count: Int;
}

export interface AggregateInvoicePromise
  extends Promise<AggregateInvoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvoiceSubscription
  extends Promise<AsyncIterator<AggregateInvoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HILogEdge {
  node: HILog;
  cursor: String;
}

export interface HILogEdgePromise extends Promise<HILogEdge>, Fragmentable {
  node: <T = HILogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HILogEdgeSubscription
  extends Promise<AsyncIterator<HILogEdge>>,
    Fragmentable {
  node: <T = HILogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InvoiceConnection {
  pageInfo: PageInfo;
  edges: InvoiceEdge[];
}

export interface InvoiceConnectionPromise
  extends Promise<InvoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvoiceEdge>>() => T;
  aggregate: <T = AggregateInvoicePromise>() => T;
}

export interface InvoiceConnectionSubscription
  extends Promise<AsyncIterator<InvoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvoiceSubscription>() => T;
}

export interface InvoiceItemEntrySubscriptionPayload {
  mutation: MutationType;
  node: InvoiceItemEntry;
  updatedFields: String[];
  previousValues: InvoiceItemEntryPreviousValues;
}

export interface InvoiceItemEntrySubscriptionPayloadPromise
  extends Promise<InvoiceItemEntrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvoiceItemEntryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvoiceItemEntryPreviousValuesPromise>() => T;
}

export interface InvoiceItemEntrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvoiceItemEntrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvoiceItemEntrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvoiceItemEntryPreviousValuesSubscription>() => T;
}

export interface TimeSheet {
  id: ID_Output;
  endsAt?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  number?: Int;
  startsAt?: DateTimeOutput;
  status?: TimeSheetStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TimeSheetPromise extends Promise<TimeSheet>, Fragmentable {
  id: () => Promise<ID_Output>;
  attachments: <T = FragmentableArray<Attachment>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  company: <T = CompanyPromise>() => T;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  number: () => Promise<Int>;
  preview: <T = AttachmentPromise>() => T;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<TimeSheetStatus>;
  timeSheetEntries: <T = FragmentableArray<TimeSheetEntry>>(args?: {
    where?: TimeSheetEntryWhereInput;
    orderBy?: TimeSheetEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetSubscription
  extends Promise<AsyncIterator<TimeSheet>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  attachments: <T = Promise<AsyncIterator<AttachmentSubscription>>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  company: <T = CompanySubscription>() => T;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  number: () => Promise<AsyncIterator<Int>>;
  preview: <T = AttachmentSubscription>() => T;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<TimeSheetStatus>>;
  timeSheetEntries: <
    T = Promise<AsyncIterator<TimeSheetEntrySubscription>>
  >(args?: {
    where?: TimeSheetEntryWhereInput;
    orderBy?: TimeSheetEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TimeSheetNullablePromise
  extends Promise<TimeSheet | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  attachments: <T = FragmentableArray<Attachment>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  company: <T = CompanyPromise>() => T;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  number: () => Promise<Int>;
  preview: <T = AttachmentPromise>() => T;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<TimeSheetStatus>;
  timeSheetEntries: <T = FragmentableArray<TimeSheetEntry>>(args?: {
    where?: TimeSheetEntryWhereInput;
    orderBy?: TimeSheetEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoiceItemEntryPreviousValues {
  id: ID_Output;
  order?: Int;
  description?: String;
  name?: String;
  price?: Float;
  quantity?: Float;
  tax?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoiceItemEntryPreviousValuesPromise
  extends Promise<InvoiceItemEntryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  quantity: () => Promise<Float>;
  tax: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoiceItemEntryPreviousValuesSubscription
  extends Promise<AsyncIterator<InvoiceItemEntryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  tax: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Service {
  id: ID_Output;
  billingType: ServiceBillingType;
  includeConsTax: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isTemplate?: Boolean;
  name: String;
  timeBasedType?: TimeBasedType;
  totalAmount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  billingType: () => Promise<ServiceBillingType>;
  company: <T = CompanyPromise>() => T;
  includeConsTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isTemplate: () => Promise<Boolean>;
  name: () => Promise<String>;
  timeBasedType: () => Promise<TimeBasedType>;
  totalAmount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  billingType: () => Promise<AsyncIterator<ServiceBillingType>>;
  company: <T = CompanySubscription>() => T;
  includeConsTax: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isTemplate: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  timeBasedType: () => Promise<AsyncIterator<TimeBasedType>>;
  totalAmount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceNullablePromise
  extends Promise<Service | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  billingType: () => Promise<ServiceBillingType>;
  company: <T = CompanyPromise>() => T;
  includeConsTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isTemplate: () => Promise<Boolean>;
  name: () => Promise<String>;
  timeBasedType: () => Promise<TimeBasedType>;
  totalAmount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HILogConnection {
  pageInfo: PageInfo;
  edges: HILogEdge[];
}

export interface HILogConnectionPromise
  extends Promise<HILogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HILogEdge>>() => T;
  aggregate: <T = AggregateHILogPromise>() => T;
}

export interface HILogConnectionSubscription
  extends Promise<AsyncIterator<HILogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HILogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHILogSubscription>() => T;
}

export interface Asset {
  id: ID_Output;
  name?: String;
  dateOfAquisition?: DateTimeOutput;
  aquisitionPrice?: Float;
  netBookValue?: Float;
  depreciation?: Float;
  salvageValue?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AssetPromise extends Promise<Asset>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  assetGroup: <T = AssetGroupPromise>() => T;
  dateOfAquisition: () => Promise<DateTimeOutput>;
  aquisitionPrice: () => Promise<Float>;
  netBookValue: () => Promise<Float>;
  depreciation: () => Promise<Float>;
  salvageValue: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AssetSubscription
  extends Promise<AsyncIterator<Asset>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  assetGroup: <T = AssetGroupSubscription>() => T;
  dateOfAquisition: () => Promise<AsyncIterator<DateTimeOutput>>;
  aquisitionPrice: () => Promise<AsyncIterator<Float>>;
  netBookValue: () => Promise<AsyncIterator<Float>>;
  depreciation: () => Promise<AsyncIterator<Float>>;
  salvageValue: () => Promise<AsyncIterator<Float>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AssetNullablePromise
  extends Promise<Asset | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  assetGroup: <T = AssetGroupPromise>() => T;
  dateOfAquisition: () => Promise<DateTimeOutput>;
  aquisitionPrice: () => Promise<Float>;
  netBookValue: () => Promise<Float>;
  depreciation: () => Promise<Float>;
  salvageValue: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerJournalSubscriptionPayload {
  mutation: MutationType;
  node: LedgerJournal;
  updatedFields: String[];
  previousValues: LedgerJournalPreviousValues;
}

export interface LedgerJournalSubscriptionPayloadPromise
  extends Promise<LedgerJournalSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LedgerJournalPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LedgerJournalPreviousValuesPromise>() => T;
}

export interface LedgerJournalSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LedgerJournalSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LedgerJournalSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LedgerJournalPreviousValuesSubscription>() => T;
}

export interface AssetGroup {
  id: ID_Output;
  name?: String;
  depreciationType?: AssetGroupDepreciationType;
  usefulLife?: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AssetGroupPromise extends Promise<AssetGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  depreciationType: () => Promise<AssetGroupDepreciationType>;
  usefulLife: () => Promise<Int>;
  deprMainAccount: <T = MainAccountPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AssetGroupSubscription
  extends Promise<AsyncIterator<AssetGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  depreciationType: () => Promise<AsyncIterator<AssetGroupDepreciationType>>;
  usefulLife: () => Promise<AsyncIterator<Int>>;
  deprMainAccount: <T = MainAccountSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AssetGroupNullablePromise
  extends Promise<AssetGroup | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  depreciationType: () => Promise<AssetGroupDepreciationType>;
  usefulLife: () => Promise<Int>;
  deprMainAccount: <T = MainAccountPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerJournalPreviousValues {
  id: ID_Output;
  total?: Float;
  description?: String;
  currency: Currency;
  includeConsTax: Boolean;
  posted: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerJournalPreviousValuesPromise
  extends Promise<LedgerJournalPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  description: () => Promise<String>;
  currency: () => Promise<Currency>;
  includeConsTax: () => Promise<Boolean>;
  posted: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerJournalPreviousValuesSubscription
  extends Promise<AsyncIterator<LedgerJournalPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  includeConsTax: () => Promise<AsyncIterator<Boolean>>;
  posted: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvoiceItemEntry {
  id: ID_Output;
  order?: Int;
  description?: String;
  name?: String;
  price?: Float;
  quantity?: Float;
  tax?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoiceItemEntryPromise
  extends Promise<InvoiceItemEntry>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  quantity: () => Promise<Float>;
  tax: () => Promise<Float>;
  invoice: <T = InvoicePromise>() => T;
  project: <T = ProjectPromise>() => T;
  service: <T = ServicePromise>() => T;
  timeSheetEntry: <T = TimeSheetEntryPromise>() => T;
  timeSheet: <T = TimeSheetPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoiceItemEntrySubscription
  extends Promise<AsyncIterator<InvoiceItemEntry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  tax: () => Promise<AsyncIterator<Float>>;
  invoice: <T = InvoiceSubscription>() => T;
  project: <T = ProjectSubscription>() => T;
  service: <T = ServiceSubscription>() => T;
  timeSheetEntry: <T = TimeSheetEntrySubscription>() => T;
  timeSheet: <T = TimeSheetSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvoiceItemEntryNullablePromise
  extends Promise<InvoiceItemEntry | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  quantity: () => Promise<Float>;
  tax: () => Promise<Float>;
  invoice: <T = InvoicePromise>() => T;
  project: <T = ProjectPromise>() => T;
  service: <T = ServicePromise>() => T;
  timeSheetEntry: <T = TimeSheetEntryPromise>() => T;
  timeSheet: <T = TimeSheetPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankConnection {
  pageInfo: PageInfo;
  edges: BankEdge[];
}

export interface BankConnectionPromise
  extends Promise<BankConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BankEdge>>() => T;
  aggregate: <T = AggregateBankPromise>() => T;
}

export interface BankConnectionSubscription
  extends Promise<AsyncIterator<BankConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BankEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBankSubscription>() => T;
}

export interface AssetConnection {
  pageInfo: PageInfo;
  edges: AssetEdge[];
}

export interface AssetConnectionPromise
  extends Promise<AssetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AssetEdge>>() => T;
  aggregate: <T = AggregateAssetPromise>() => T;
}

export interface AssetConnectionSubscription
  extends Promise<AsyncIterator<AssetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AssetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAssetSubscription>() => T;
}

export interface LedgerPostingSubscriptionPayload {
  mutation: MutationType;
  node: LedgerPosting;
  updatedFields: String[];
  previousValues: LedgerPostingPreviousValues;
}

export interface LedgerPostingSubscriptionPayloadPromise
  extends Promise<LedgerPostingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LedgerPostingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LedgerPostingPreviousValuesPromise>() => T;
}

export interface LedgerPostingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LedgerPostingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LedgerPostingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LedgerPostingPreviousValuesSubscription>() => T;
}

export interface AggregateAsset {
  count: Int;
}

export interface AggregateAssetPromise
  extends Promise<AggregateAsset>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAssetSubscription
  extends Promise<AsyncIterator<AggregateAsset>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LedgerPostingPreviousValues {
  id: ID_Output;
  postingType?: PostingType;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerPostingPreviousValuesPromise
  extends Promise<LedgerPostingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  postingType: () => Promise<PostingType>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerPostingPreviousValuesSubscription
  extends Promise<AsyncIterator<LedgerPostingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  postingType: () => Promise<AsyncIterator<PostingType>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInventoryOnHand {
  count: Int;
}

export interface AggregateInventoryOnHandPromise
  extends Promise<AggregateInventoryOnHand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventoryOnHandSubscription
  extends Promise<AsyncIterator<AggregateInventoryOnHand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BankEdge {
  node: Bank;
  cursor: String;
}

export interface BankEdgePromise extends Promise<BankEdge>, Fragmentable {
  node: <T = BankPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BankEdgeSubscription
  extends Promise<AsyncIterator<BankEdge>>,
    Fragmentable {
  node: <T = BankSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryOnHandConnection {
  pageInfo: PageInfo;
  edges: InventoryOnHandEdge[];
}

export interface InventoryOnHandConnectionPromise
  extends Promise<InventoryOnHandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryOnHandEdge>>() => T;
  aggregate: <T = AggregateInventoryOnHandPromise>() => T;
}

export interface InventoryOnHandConnectionSubscription
  extends Promise<AsyncIterator<InventoryOnHandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryOnHandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventoryOnHandSubscription>() => T;
}

export interface LedgerTransactionSubscriptionPayload {
  mutation: MutationType;
  node: LedgerTransaction;
  updatedFields: String[];
  previousValues: LedgerTransactionPreviousValues;
}

export interface LedgerTransactionSubscriptionPayloadPromise
  extends Promise<LedgerTransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LedgerTransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LedgerTransactionPreviousValuesPromise>() => T;
}

export interface LedgerTransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LedgerTransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LedgerTransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LedgerTransactionPreviousValuesSubscription>() => T;
}

export interface WareHouse {
  id: ID_Output;
  name?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WareHousePromise extends Promise<WareHouse>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WareHouseSubscription
  extends Promise<AsyncIterator<WareHouse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WareHouseNullablePromise
  extends Promise<WareHouse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerTransactionPreviousValues {
  id: ID_Output;
  drcr: DrCr;
  amount: Float;
  currency: Currency;
  date: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerTransactionPreviousValuesPromise
  extends Promise<LedgerTransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  drcr: () => Promise<DrCr>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  date: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerTransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<LedgerTransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  drcr: () => Promise<AsyncIterator<DrCr>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VaccineBrandPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface VaccineBrandPreviousValuesPromise
  extends Promise<VaccineBrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface VaccineBrandPreviousValuesSubscription
  extends Promise<AsyncIterator<VaccineBrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBank {
  count: Int;
}

export interface AggregateBankPromise
  extends Promise<AggregateBank>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBankSubscription
  extends Promise<AsyncIterator<AggregateBank>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WareHouseEdge {
  node: WareHouse;
  cursor: String;
}

export interface WareHouseEdgePromise
  extends Promise<WareHouseEdge>,
    Fragmentable {
  node: <T = WareHousePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WareHouseEdgeSubscription
  extends Promise<AsyncIterator<WareHouseEdge>>,
    Fragmentable {
  node: <T = WareHouseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MainAccountSubscriptionPayload {
  mutation: MutationType;
  node: MainAccount;
  updatedFields: String[];
  previousValues: MainAccountPreviousValues;
}

export interface MainAccountSubscriptionPayloadPromise
  extends Promise<MainAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MainAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MainAccountPreviousValuesPromise>() => T;
}

export interface MainAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MainAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MainAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MainAccountPreviousValuesSubscription>() => T;
}

export interface VaccineBrandEdge {
  node: VaccineBrand;
  cursor: String;
}

export interface VaccineBrandEdgePromise
  extends Promise<VaccineBrandEdge>,
    Fragmentable {
  node: <T = VaccineBrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VaccineBrandEdgeSubscription
  extends Promise<AsyncIterator<VaccineBrandEdge>>,
    Fragmentable {
  node: <T = VaccineBrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MainAccountPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
  description?: String;
  type: MainAccountType;
  ConsTaxFree: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MainAccountPreviousValuesPromise
  extends Promise<MainAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<MainAccountType>;
  ConsTaxFree: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MainAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<MainAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MainAccountType>>;
  ConsTaxFree: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HILog {
  id: ID_Output;
  hpio?: String;
  hpii?: String;
  ihi?: String;
  timeWaitedForSalus?: Int;
  csp?: String;
  hiWebServiceUsed?: String;
  hiWebServiceVersion?: String;
  hiNumberStatus?: HINumberStatus;
  recordStatus?: String;
  salusResponse?: SalusResponse;
  failureMessage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HILogPromise extends Promise<HILog>, Fragmentable {
  id: () => Promise<ID_Output>;
  hpio: () => Promise<String>;
  hpii: () => Promise<String>;
  ihi: () => Promise<String>;
  timeWaitedForSalus: () => Promise<Int>;
  csp: () => Promise<String>;
  hiWebServiceUsed: () => Promise<String>;
  hiWebServiceVersion: () => Promise<String>;
  hiNumberStatus: () => Promise<HINumberStatus>;
  recordStatus: () => Promise<String>;
  salusResponse: () => Promise<SalusResponse>;
  failureMessage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HILogSubscription
  extends Promise<AsyncIterator<HILog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  hpio: () => Promise<AsyncIterator<String>>;
  hpii: () => Promise<AsyncIterator<String>>;
  ihi: () => Promise<AsyncIterator<String>>;
  timeWaitedForSalus: () => Promise<AsyncIterator<Int>>;
  csp: () => Promise<AsyncIterator<String>>;
  hiWebServiceUsed: () => Promise<AsyncIterator<String>>;
  hiWebServiceVersion: () => Promise<AsyncIterator<String>>;
  hiNumberStatus: () => Promise<AsyncIterator<HINumberStatus>>;
  recordStatus: () => Promise<AsyncIterator<String>>;
  salusResponse: () => Promise<AsyncIterator<SalusResponse>>;
  failureMessage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HILogNullablePromise
  extends Promise<HILog | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  hpio: () => Promise<String>;
  hpii: () => Promise<String>;
  ihi: () => Promise<String>;
  timeWaitedForSalus: () => Promise<Int>;
  csp: () => Promise<String>;
  hiWebServiceUsed: () => Promise<String>;
  hiWebServiceVersion: () => Promise<String>;
  hiNumberStatus: () => Promise<HINumberStatus>;
  recordStatus: () => Promise<String>;
  salusResponse: () => Promise<SalusResponse>;
  failureMessage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetEntryConnection {
  pageInfo: PageInfo;
  edges: TimeSheetEntryEdge[];
}

export interface TimeSheetEntryConnectionPromise
  extends Promise<TimeSheetEntryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeSheetEntryEdge>>() => T;
  aggregate: <T = AggregateTimeSheetEntryPromise>() => T;
}

export interface TimeSheetEntryConnectionSubscription
  extends Promise<AsyncIterator<TimeSheetEntryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeSheetEntryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeSheetEntrySubscription>() => T;
}

export interface MeansTestLimitsSubscriptionPayload {
  mutation: MutationType;
  node: MeansTestLimits;
  updatedFields: String[];
  previousValues: MeansTestLimitsPreviousValues;
}

export interface MeansTestLimitsSubscriptionPayloadPromise
  extends Promise<MeansTestLimitsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeansTestLimitsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeansTestLimitsPreviousValuesPromise>() => T;
}

export interface MeansTestLimitsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeansTestLimitsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeansTestLimitsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeansTestLimitsPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  contactNumber?: Json;
  email?: String;
  firstName?: String;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isRoot?: Boolean;
  jobTitle?: String;
  lastName?: String;
  password?: String;
  secondAuthEnabled?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  contactNumber: () => Promise<Json>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isRoot: () => Promise<Boolean>;
  jobTitle: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  secondAuthEnabled: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  contactNumber: () => Promise<AsyncIterator<Json>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  secondAuthEnabled: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeansTestLimitsPreviousValues {
  id: ID_Output;
  annual?: Float;
  lifetime?: Float;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
}

export interface MeansTestLimitsPreviousValuesPromise
  extends Promise<MeansTestLimitsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  annual: () => Promise<Float>;
  lifetime: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
}

export interface MeansTestLimitsPreviousValuesSubscription
  extends Promise<AsyncIterator<MeansTestLimitsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  annual: () => Promise<AsyncIterator<Float>>;
  lifetime: () => Promise<AsyncIterator<Float>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface AggregateDisease {
  count: Int;
}

export interface AggregateDiseasePromise
  extends Promise<AggregateDisease>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiseaseSubscription
  extends Promise<AsyncIterator<AggregateDisease>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalesOrderLineEdge {
  node: SalesOrderLine;
  cursor: String;
}

export interface SalesOrderLineEdgePromise
  extends Promise<SalesOrderLineEdge>,
    Fragmentable {
  node: <T = SalesOrderLinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalesOrderLineEdgeSubscription
  extends Promise<AsyncIterator<SalesOrderLineEdge>>,
    Fragmentable {
  node: <T = SalesOrderLineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MeansTestedFeeSubscriptionPayload {
  mutation: MutationType;
  node: MeansTestedFee;
  updatedFields: String[];
  previousValues: MeansTestedFeePreviousValues;
}

export interface MeansTestedFeeSubscriptionPayloadPromise
  extends Promise<MeansTestedFeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeansTestedFeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeansTestedFeePreviousValuesPromise>() => T;
}

export interface MeansTestedFeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeansTestedFeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeansTestedFeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeansTestedFeePreviousValuesSubscription>() => T;
}

export interface AggregateSalesOrder {
  count: Int;
}

export interface AggregateSalesOrderPromise
  extends Promise<AggregateSalesOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalesOrderSubscription
  extends Promise<AsyncIterator<AggregateSalesOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeansTestedFeePreviousValues {
  id: ID_Output;
  amount?: Float;
  currency?: Currency;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
}

export interface MeansTestedFeePreviousValuesPromise
  extends Promise<MeansTestedFeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
}

export interface MeansTestedFeePreviousValuesSubscription
  extends Promise<AsyncIterator<MeansTestedFeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SalesOrder {
  id: ID_Output;
  transactionDate?: DateTimeOutput;
  currency?: Currency;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesOrderPromise extends Promise<SalesOrder>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  transactionDate: () => Promise<DateTimeOutput>;
  currency: () => Promise<Currency>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesOrderSubscription
  extends Promise<AsyncIterator<SalesOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  transactionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SalesOrderNullablePromise
  extends Promise<SalesOrder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  transactionDate: () => Promise<DateTimeOutput>;
  currency: () => Promise<Currency>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiseaseEdge {
  node: Disease;
  cursor: String;
}

export interface DiseaseEdgePromise extends Promise<DiseaseEdge>, Fragmentable {
  node: <T = DiseasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiseaseEdgeSubscription
  extends Promise<AsyncIterator<DiseaseEdge>>,
    Fragmentable {
  node: <T = DiseaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PurchaseOrderLine {
  id: ID_Output;
  pbsDrug?: String;
  qty?: Int;
  unit?: UOM;
  unitPrice?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PurchaseOrderLinePromise
  extends Promise<PurchaseOrderLine>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  item: <T = InventoryPromise>() => T;
  pbsDrug: () => Promise<String>;
  qty: () => Promise<Int>;
  unit: () => Promise<UOM>;
  unitPrice: () => Promise<Float>;
  site: <T = WareHousePromise>() => T;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  poReceipt: <T = PoReceiptPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PurchaseOrderLineSubscription
  extends Promise<AsyncIterator<PurchaseOrderLine>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  item: <T = InventorySubscription>() => T;
  pbsDrug: () => Promise<AsyncIterator<String>>;
  qty: () => Promise<AsyncIterator<Int>>;
  unit: () => Promise<AsyncIterator<UOM>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  site: <T = WareHouseSubscription>() => T;
  purchaseOrder: <T = PurchaseOrderSubscription>() => T;
  poReceipt: <T = PoReceiptSubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseOrderLineNullablePromise
  extends Promise<PurchaseOrderLine | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  item: <T = InventoryPromise>() => T;
  pbsDrug: () => Promise<String>;
  qty: () => Promise<Int>;
  unit: () => Promise<UOM>;
  unitPrice: () => Promise<Float>;
  site: <T = WareHousePromise>() => T;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  poReceipt: <T = PoReceiptPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicareServiceSubscriptionPayload {
  mutation: MutationType;
  node: MedicareService;
  updatedFields: String[];
  previousValues: MedicareServicePreviousValues;
}

export interface MedicareServiceSubscriptionPayloadPromise
  extends Promise<MedicareServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MedicareServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MedicareServicePreviousValuesPromise>() => T;
}

export interface MedicareServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MedicareServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MedicareServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MedicareServicePreviousValuesSubscription>() => T;
}

export interface ApInvoice {
  id: ID_Output;
  status?: ApInvoiceStatus;
  invoiceNumber?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ApInvoicePromise extends Promise<ApInvoice>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ApInvoiceStatus>;
  invoiceNumber: () => Promise<String>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ApInvoiceSubscription
  extends Promise<AsyncIterator<ApInvoice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<ApInvoiceStatus>>;
  invoiceNumber: () => Promise<AsyncIterator<String>>;
  purchaseOrder: <T = PurchaseOrderSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ApInvoiceNullablePromise
  extends Promise<ApInvoice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<ApInvoiceStatus>;
  invoiceNumber: () => Promise<String>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicareServicePreviousValues {
  id: ID_Output;
  MBSScheduleFee?: Float;
  description?: String;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicareServicePreviousValuesPromise
  extends Promise<MedicareServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  MBSScheduleFee: () => Promise<Float>;
  description: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicareServicePreviousValuesSubscription
  extends Promise<AsyncIterator<MedicareServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  MBSScheduleFee: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateProjectService {
  count: Int;
}

export interface AggregateProjectServicePromise
  extends Promise<AggregateProjectService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectServiceSubscription
  extends Promise<AsyncIterator<AggregateProjectService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiseaseConnection {
  pageInfo: PageInfo;
  edges: DiseaseEdge[];
}

export interface DiseaseConnectionPromise
  extends Promise<DiseaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiseaseEdge>>() => T;
  aggregate: <T = AggregateDiseasePromise>() => T;
}

export interface DiseaseConnectionSubscription
  extends Promise<AsyncIterator<DiseaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiseaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiseaseSubscription>() => T;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NameSubscriptionPayload {
  mutation: MutationType;
  node: Name;
  updatedFields: String[];
  previousValues: NamePreviousValues;
}

export interface NameSubscriptionPayloadPromise
  extends Promise<NameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NamePreviousValuesPromise>() => T;
}

export interface NameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NamePreviousValuesSubscription>() => T;
}

export interface PredictedSalesValueByCompanyEdge {
  node: PredictedSalesValueByCompany;
  cursor: String;
}

export interface PredictedSalesValueByCompanyEdgePromise
  extends Promise<PredictedSalesValueByCompanyEdge>,
    Fragmentable {
  node: <T = PredictedSalesValueByCompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PredictedSalesValueByCompanyEdgeSubscription
  extends Promise<AsyncIterator<PredictedSalesValueByCompanyEdge>>,
    Fragmentable {
  node: <T = PredictedSalesValueByCompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NamePreviousValues {
  id: ID_Output;
  name?: String;
  isPrimary?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface NamePreviousValuesPromise
  extends Promise<NamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  isPrimary: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NamePreviousValuesSubscription
  extends Promise<AsyncIterator<NamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  isPrimary: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePredictedSalesQuantityOfItemsByCompany {
  count: Int;
}

export interface AggregatePredictedSalesQuantityOfItemsByCompanyPromise
  extends Promise<AggregatePredictedSalesQuantityOfItemsByCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePredictedSalesQuantityOfItemsByCompanySubscription
  extends Promise<
      AsyncIterator<AggregatePredictedSalesQuantityOfItemsByCompany>
    >,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Disease {
  id: ID_Output;
  name?: String;
}

export interface DiseasePromise extends Promise<Disease>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DiseaseSubscription
  extends Promise<AsyncIterator<Disease>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DiseaseNullablePromise
  extends Promise<Disease | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PredictedSalesQuantityOfItemsByCompany {
  id: ID_Output;
  datePredictionRun?: DateTimeOutput;
  predictedSalesValue?: Float;
  predictedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PredictedSalesQuantityOfItemsByCompanyPromise
  extends Promise<PredictedSalesQuantityOfItemsByCompany>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  inventory: <T = InventoryPromise>() => T;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PredictedSalesQuantityOfItemsByCompanySubscription
  extends Promise<AsyncIterator<PredictedSalesQuantityOfItemsByCompany>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datePredictionRun: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  inventory: <T = InventorySubscription>() => T;
  predictedSalesValue: () => Promise<AsyncIterator<Float>>;
  predictedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PredictedSalesQuantityOfItemsByCompanyNullablePromise
  extends Promise<PredictedSalesQuantityOfItemsByCompany | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  inventory: <T = InventoryPromise>() => T;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatientSubscriptionPayload {
  mutation: MutationType;
  node: Patient;
  updatedFields: String[];
  previousValues: PatientPreviousValues;
}

export interface PatientSubscriptionPayloadPromise
  extends Promise<PatientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PatientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PatientPreviousValuesPromise>() => T;
}

export interface PatientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PatientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PatientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PatientPreviousValuesSubscription>() => T;
}

export interface Supplier {
  id: ID_Output;
  name?: String;
  termsOfPayment?: SupplierTermsOfPayment;
  bankAccount?: Json;
  emailAddressForRemittance?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SupplierPromise extends Promise<Supplier>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  termsOfPayment: () => Promise<SupplierTermsOfPayment>;
  bankAccount: () => Promise<Json>;
  emailAddressForRemittance: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SupplierSubscription
  extends Promise<AsyncIterator<Supplier>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: <T = Promise<AsyncIterator<AddressSubscription>>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  termsOfPayment: () => Promise<AsyncIterator<SupplierTermsOfPayment>>;
  bankAccount: () => Promise<AsyncIterator<Json>>;
  emailAddressForRemittance: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SupplierNullablePromise
  extends Promise<Supplier | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  termsOfPayment: () => Promise<SupplierTermsOfPayment>;
  bankAccount: () => Promise<Json>;
  emailAddressForRemittance: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatientPreviousValues {
  id: ID_Output;
  title?: String;
  firstName?: String;
  lastName?: String;
  dateOfBirth?: DateTimeOutput;
  gender?: Gender;
  dvaCardType?: DVACardType;
  aboriginalStatus?: AboriginalStatus;
  pensionerConcession?: String;
  commonwealthSeniors?: String;
  healthcareConcession?: String;
  safetyNetConcession?: Float;
  medicareNumber?: String;
  DVA?: String;
  potentialDuplicate?: Boolean;
  oneName?: Boolean;
  ihi?: String;
  ihiValidatedDate?: DateTimeOutput;
  noOfBirths?: Int;
  deceasedDate?: DateTimeOutput;
  levelOfCare?: LevelOfCare;
  dateEnteredAgedCare?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PatientPreviousValuesPromise
  extends Promise<PatientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  gender: () => Promise<Gender>;
  dvaCardType: () => Promise<DVACardType>;
  aboriginalStatus: () => Promise<AboriginalStatus>;
  pensionerConcession: () => Promise<String>;
  commonwealthSeniors: () => Promise<String>;
  healthcareConcession: () => Promise<String>;
  safetyNetConcession: () => Promise<Float>;
  medicareNumber: () => Promise<String>;
  DVA: () => Promise<String>;
  potentialDuplicate: () => Promise<Boolean>;
  oneName: () => Promise<Boolean>;
  ihi: () => Promise<String>;
  ihiValidatedDate: () => Promise<DateTimeOutput>;
  noOfBirths: () => Promise<Int>;
  deceasedDate: () => Promise<DateTimeOutput>;
  levelOfCare: () => Promise<LevelOfCare>;
  dateEnteredAgedCare: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PatientPreviousValuesSubscription
  extends Promise<AsyncIterator<PatientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  dvaCardType: () => Promise<AsyncIterator<DVACardType>>;
  aboriginalStatus: () => Promise<AsyncIterator<AboriginalStatus>>;
  pensionerConcession: () => Promise<AsyncIterator<String>>;
  commonwealthSeniors: () => Promise<AsyncIterator<String>>;
  healthcareConcession: () => Promise<AsyncIterator<String>>;
  safetyNetConcession: () => Promise<AsyncIterator<Float>>;
  medicareNumber: () => Promise<AsyncIterator<String>>;
  DVA: () => Promise<AsyncIterator<String>>;
  potentialDuplicate: () => Promise<AsyncIterator<Boolean>>;
  oneName: () => Promise<AsyncIterator<Boolean>>;
  ihi: () => Promise<AsyncIterator<String>>;
  ihiValidatedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  noOfBirths: () => Promise<AsyncIterator<Int>>;
  deceasedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  levelOfCare: () => Promise<AsyncIterator<LevelOfCare>>;
  dateEnteredAgedCare: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanConnection {
  pageInfo: PageInfo;
  edges: PlanEdge[];
}

export interface PlanConnectionPromise
  extends Promise<PlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanEdge>>() => T;
  aggregate: <T = AggregatePlanPromise>() => T;
}

export interface PlanConnectionSubscription
  extends Promise<AsyncIterator<PlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanSubscription>() => T;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PbsTPPConnection {
  pageInfo: PageInfo;
  edges: PbsTPPEdge[];
}

export interface PbsTPPConnectionPromise
  extends Promise<PbsTPPConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PbsTPPEdge>>() => T;
  aggregate: <T = AggregatePbsTPPPromise>() => T;
}

export interface PbsTPPConnectionSubscription
  extends Promise<AsyncIterator<PbsTPPConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PbsTPPEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePbsTPPSubscription>() => T;
}

export interface PbsOrganisationSubscriptionPayload {
  mutation: MutationType;
  node: PbsOrganisation;
  updatedFields: String[];
  previousValues: PbsOrganisationPreviousValues;
}

export interface PbsOrganisationSubscriptionPayloadPromise
  extends Promise<PbsOrganisationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PbsOrganisationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PbsOrganisationPreviousValuesPromise>() => T;
}

export interface PbsOrganisationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PbsOrganisationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PbsOrganisationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PbsOrganisationPreviousValuesSubscription>() => T;
}

export interface PbsOrganisationEdge {
  node: PbsOrganisation;
  cursor: String;
}

export interface PbsOrganisationEdgePromise
  extends Promise<PbsOrganisationEdge>,
    Fragmentable {
  node: <T = PbsOrganisationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PbsOrganisationEdgeSubscription
  extends Promise<AsyncIterator<PbsOrganisationEdge>>,
    Fragmentable {
  node: <T = PbsOrganisationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PbsOrganisationPreviousValues {
  id: ID_Output;
  code?: String;
  title?: String;
  street?: String;
  city?: String;
  stateAddress?: String;
  postcode?: String;
  phone?: String;
  effectiveFrom?: DateTimeOutput;
  effectiveTo?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PbsOrganisationPreviousValuesPromise
  extends Promise<PbsOrganisationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  title: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  stateAddress: () => Promise<String>;
  postcode: () => Promise<String>;
  phone: () => Promise<String>;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PbsOrganisationPreviousValuesSubscription
  extends Promise<AsyncIterator<PbsOrganisationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  stateAddress: () => Promise<AsyncIterator<String>>;
  postcode: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  effectiveFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  effectiveTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePatient {
  count: Int;
}

export interface AggregatePatientPromise
  extends Promise<AggregatePatient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePatientSubscription
  extends Promise<AsyncIterator<AggregatePatient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateName {
  count: Int;
}

export interface AggregateNamePromise
  extends Promise<AggregateName>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNameSubscription
  extends Promise<AsyncIterator<AggregateName>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PbsTPPSubscriptionPayload {
  mutation: MutationType;
  node: PbsTPP;
  updatedFields: String[];
  previousValues: PbsTPPPreviousValues;
}

export interface PbsTPPSubscriptionPayloadPromise
  extends Promise<PbsTPPSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PbsTPPPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PbsTPPPreviousValuesPromise>() => T;
}

export interface PbsTPPSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PbsTPPSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PbsTPPSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PbsTPPPreviousValuesSubscription>() => T;
}

export interface AggregateMedicareService {
  count: Int;
}

export interface AggregateMedicareServicePromise
  extends Promise<AggregateMedicareService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMedicareServiceSubscription
  extends Promise<AsyncIterator<AggregateMedicareService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PbsTPPPreviousValues {
  id: ID_Output;
  snomedCode?: String;
  clinicalPreferredTerm?: String;
  packSize?: Int;
  brandName?: String;
  exManufacturerPrice?: Float;
  pricingModel?: PBSPricingModel;
  mpp_id?: String;
  effectiveFrom?: DateTimeOutput;
  effectiveTo?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PbsTPPPreviousValuesPromise
  extends Promise<PbsTPPPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  snomedCode: () => Promise<String>;
  clinicalPreferredTerm: () => Promise<String>;
  packSize: () => Promise<Int>;
  brandName: () => Promise<String>;
  exManufacturerPrice: () => Promise<Float>;
  pricingModel: () => Promise<PBSPricingModel>;
  mpp_id: () => Promise<String>;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PbsTPPPreviousValuesSubscription
  extends Promise<AsyncIterator<PbsTPPPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  snomedCode: () => Promise<AsyncIterator<String>>;
  clinicalPreferredTerm: () => Promise<AsyncIterator<String>>;
  packSize: () => Promise<AsyncIterator<Int>>;
  brandName: () => Promise<AsyncIterator<String>>;
  exManufacturerPrice: () => Promise<AsyncIterator<Float>>;
  pricingModel: () => Promise<AsyncIterator<PBSPricingModel>>;
  mpp_id: () => Promise<AsyncIterator<String>>;
  effectiveFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  effectiveTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MedicareService {
  id: ID_Output;
  MBSScheduleFee?: Float;
  description?: String;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MedicareServicePromise
  extends Promise<MedicareService>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  MBSScheduleFee: () => Promise<Float>;
  description: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MedicareServiceSubscription
  extends Promise<AsyncIterator<MedicareService>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  MBSScheduleFee: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MedicareServiceNullablePromise
  extends Promise<MedicareService | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  MBSScheduleFee: () => Promise<Float>;
  description: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface AggregateMeansTestLimits {
  count: Int;
}

export interface AggregateMeansTestLimitsPromise
  extends Promise<AggregateMeansTestLimits>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeansTestLimitsSubscription
  extends Promise<AsyncIterator<AggregateMeansTestLimits>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlanSubscriptionPayload {
  mutation: MutationType;
  node: Plan;
  updatedFields: String[];
  previousValues: PlanPreviousValues;
}

export interface PlanSubscriptionPayloadPromise
  extends Promise<PlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanPreviousValuesPromise>() => T;
}

export interface PlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanPreviousValuesSubscription>() => T;
}

export interface MeansTestLimits {
  id: ID_Output;
  annual?: Float;
  lifetime?: Float;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
}

export interface MeansTestLimitsPromise
  extends Promise<MeansTestLimits>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  annual: () => Promise<Float>;
  lifetime: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
}

export interface MeansTestLimitsSubscription
  extends Promise<AsyncIterator<MeansTestLimits>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  annual: () => Promise<AsyncIterator<Float>>;
  lifetime: () => Promise<AsyncIterator<Float>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MeansTestLimitsNullablePromise
  extends Promise<MeansTestLimits | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  annual: () => Promise<Float>;
  lifetime: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
}

export interface PlanPreviousValues {
  id: ID_Output;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  price?: Float;
  type?: PlanType;
  currency: Currency;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanPreviousValuesPromise
  extends Promise<PlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  price: () => Promise<Float>;
  type: () => Promise<PlanType>;
  currency: () => Promise<Currency>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  price: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<PlanType>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Plan {
  id: ID_Output;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  price?: Float;
  type?: PlanType;
  currency: Currency;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanPromise extends Promise<Plan>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  price: () => Promise<Float>;
  type: () => Promise<PlanType>;
  currency: () => Promise<Currency>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanSubscription
  extends Promise<AsyncIterator<Plan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  price: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<PlanType>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanNullablePromise
  extends Promise<Plan | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  price: () => Promise<Float>;
  type: () => Promise<PlanType>;
  currency: () => Promise<Currency>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankTransaction {
  id: ID_Output;
  transactionDate: DateTimeOutput;
  amount: Float;
  description?: String;
  posted: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BankTransactionPromise
  extends Promise<BankTransaction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transactionDate: () => Promise<DateTimeOutput>;
  amount: () => Promise<Float>;
  description: () => Promise<String>;
  posted: () => Promise<Boolean>;
  ledgerJournal: <T = LedgerJournalPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BankTransactionSubscription
  extends Promise<AsyncIterator<BankTransaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transactionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  posted: () => Promise<AsyncIterator<Boolean>>;
  ledgerJournal: <T = LedgerJournalSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BankTransactionNullablePromise
  extends Promise<BankTransaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transactionDate: () => Promise<DateTimeOutput>;
  amount: () => Promise<Float>;
  description: () => Promise<String>;
  posted: () => Promise<Boolean>;
  ledgerJournal: <T = LedgerJournalPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerTransaction {
  id: ID_Output;
  drcr: DrCr;
  amount: Float;
  currency: Currency;
  date: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerTransactionPromise
  extends Promise<LedgerTransaction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainAccount: <T = MainAccountPromise>() => T;
  ledgerJournal: <T = LedgerJournalPromise>() => T;
  drcr: () => Promise<DrCr>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  date: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerTransactionSubscription
  extends Promise<AsyncIterator<LedgerTransaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  mainAccount: <T = MainAccountSubscription>() => T;
  ledgerJournal: <T = LedgerJournalSubscription>() => T;
  drcr: () => Promise<AsyncIterator<DrCr>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerTransactionNullablePromise
  extends Promise<LedgerTransaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  mainAccount: <T = MainAccountPromise>() => T;
  ledgerJournal: <T = LedgerJournalPromise>() => T;
  drcr: () => Promise<DrCr>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  date: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PoReceiptSubscriptionPayload {
  mutation: MutationType;
  node: PoReceipt;
  updatedFields: String[];
  previousValues: PoReceiptPreviousValues;
}

export interface PoReceiptSubscriptionPayloadPromise
  extends Promise<PoReceiptSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PoReceiptPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PoReceiptPreviousValuesPromise>() => T;
}

export interface PoReceiptSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PoReceiptSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PoReceiptSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PoReceiptPreviousValuesSubscription>() => T;
}

export interface ApInvoiceConnection {
  pageInfo: PageInfo;
  edges: ApInvoiceEdge[];
}

export interface ApInvoiceConnectionPromise
  extends Promise<ApInvoiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApInvoiceEdge>>() => T;
  aggregate: <T = AggregateApInvoicePromise>() => T;
}

export interface ApInvoiceConnectionSubscription
  extends Promise<AsyncIterator<ApInvoiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApInvoiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApInvoiceSubscription>() => T;
}

export interface PoReceiptPreviousValues {
  id: ID_Output;
  receiptNumber?: String;
  receiptDate?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PoReceiptPreviousValuesPromise
  extends Promise<PoReceiptPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  receiptNumber: () => Promise<String>;
  receiptDate: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PoReceiptPreviousValuesSubscription
  extends Promise<AsyncIterator<PoReceiptPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  receiptNumber: () => Promise<AsyncIterator<String>>;
  receiptDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerJournalConnection {
  pageInfo: PageInfo;
  edges: LedgerJournalEdge[];
}

export interface LedgerJournalConnectionPromise
  extends Promise<LedgerJournalConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LedgerJournalEdge>>() => T;
  aggregate: <T = AggregateLedgerJournalPromise>() => T;
}

export interface LedgerJournalConnectionSubscription
  extends Promise<AsyncIterator<LedgerJournalConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LedgerJournalEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLedgerJournalSubscription>() => T;
}

export interface MeansTestedFee {
  id: ID_Output;
  amount?: Float;
  currency?: Currency;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
}

export interface MeansTestedFeePromise
  extends Promise<MeansTestedFee>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
}

export interface MeansTestedFeeSubscription
  extends Promise<AsyncIterator<MeansTestedFee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
}

export interface MeansTestedFeeNullablePromise
  extends Promise<MeansTestedFee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  currency: () => Promise<Currency>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
}

export interface InvoiceItemEntryConnection {
  pageInfo: PageInfo;
  edges: InvoiceItemEntryEdge[];
}

export interface InvoiceItemEntryConnectionPromise
  extends Promise<InvoiceItemEntryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvoiceItemEntryEdge>>() => T;
  aggregate: <T = AggregateInvoiceItemEntryPromise>() => T;
}

export interface InvoiceItemEntryConnectionSubscription
  extends Promise<AsyncIterator<InvoiceItemEntryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvoiceItemEntryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvoiceItemEntrySubscription>() => T;
}

export interface PredictedSalesQuantityOfItemsByCompanySubscriptionPayload {
  mutation: MutationType;
  node: PredictedSalesQuantityOfItemsByCompany;
  updatedFields: String[];
  previousValues: PredictedSalesQuantityOfItemsByCompanyPreviousValues;
}

export interface PredictedSalesQuantityOfItemsByCompanySubscriptionPayloadPromise
  extends Promise<PredictedSalesQuantityOfItemsByCompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PredictedSalesQuantityOfItemsByCompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = PredictedSalesQuantityOfItemsByCompanyPreviousValuesPromise
  >() => T;
}

export interface PredictedSalesQuantityOfItemsByCompanySubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<PredictedSalesQuantityOfItemsByCompanySubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PredictedSalesQuantityOfItemsByCompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = PredictedSalesQuantityOfItemsByCompanyPreviousValuesSubscription
  >() => T;
}

export interface AggregateApInvoice {
  count: Int;
}

export interface AggregateApInvoicePromise
  extends Promise<AggregateApInvoice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApInvoiceSubscription
  extends Promise<AsyncIterator<AggregateApInvoice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PredictedSalesQuantityOfItemsByCompanyPreviousValues {
  id: ID_Output;
  datePredictionRun?: DateTimeOutput;
  predictedSalesValue?: Float;
  predictedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PredictedSalesQuantityOfItemsByCompanyPreviousValuesPromise
  extends Promise<PredictedSalesQuantityOfItemsByCompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PredictedSalesQuantityOfItemsByCompanyPreviousValuesSubscription
  extends Promise<
      AsyncIterator<PredictedSalesQuantityOfItemsByCompanyPreviousValues>
    >,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datePredictionRun: () => Promise<AsyncIterator<DateTimeOutput>>;
  predictedSalesValue: () => Promise<AsyncIterator<Float>>;
  predictedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectServiceRule {
  id: ID_Output;
  amount?: Float;
  percent?: Float;
  type?: ProjectServiceRuleType;
  isPercent?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectServiceRulePromise
  extends Promise<ProjectServiceRule>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  projectService: <T = ProjectServicePromise>() => T;
  amount: () => Promise<Float>;
  percent: () => Promise<Float>;
  type: () => Promise<ProjectServiceRuleType>;
  isPercent: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServiceRuleSubscription
  extends Promise<AsyncIterator<ProjectServiceRule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  projectService: <T = ProjectServiceSubscription>() => T;
  amount: () => Promise<AsyncIterator<Float>>;
  percent: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<ProjectServiceRuleType>>;
  isPercent: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectServiceRuleNullablePromise
  extends Promise<ProjectServiceRule | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  projectService: <T = ProjectServicePromise>() => T;
  amount: () => Promise<Float>;
  percent: () => Promise<Float>;
  type: () => Promise<ProjectServiceRuleType>;
  isPercent: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Customer {
  id: ID_Output;
  description?: String;
  govNumber?: String;
  salesTax?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  name?: String;
  billingFrequency?: SupplierTermsOfPayment;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  description: () => Promise<String>;
  govNumber: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  billingFrequency: () => Promise<SupplierTermsOfPayment>;
  meansTestedFee: <T = MeansTestedFeePromise>() => T;
  basicDailyFee: <T = BasicDailyFeePromise>() => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  govNumber: () => Promise<AsyncIterator<String>>;
  salesTax: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  billingFrequency: () => Promise<AsyncIterator<SupplierTermsOfPayment>>;
  meansTestedFee: <T = MeansTestedFeeSubscription>() => T;
  basicDailyFee: <T = BasicDailyFeeSubscription>() => T;
  contacts: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = Promise<AsyncIterator<AddressSubscription>>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  description: () => Promise<String>;
  govNumber: () => Promise<String>;
  salesTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  billingFrequency: () => Promise<SupplierTermsOfPayment>;
  meansTestedFee: <T = MeansTestedFeePromise>() => T;
  basicDailyFee: <T = BasicDailyFeePromise>() => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addresses: <T = FragmentableArray<Address>>(args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Project {
  id: ID_Output;
  description?: String;
  endsAt?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  name?: String;
  startsAt?: DateTimeOutput;
  status?: ProjectStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  description: () => Promise<String>;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  projectService: <T = FragmentableArray<ProjectService>>(args?: {
    where?: ProjectServiceWhereInput;
    orderBy?: ProjectServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<ProjectStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  customer: <T = CustomerSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  projectService: <
    T = Promise<AsyncIterator<ProjectServiceSubscription>>
  >(args?: {
    where?: ProjectServiceWhereInput;
    orderBy?: ProjectServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<ProjectStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  customer: <T = CustomerPromise>() => T;
  description: () => Promise<String>;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  projectService: <T = FragmentableArray<ProjectService>>(args?: {
    where?: ProjectServiceWhereInput;
    orderBy?: ProjectServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<ProjectStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PredictedSalesValueByCompanySubscriptionPayload {
  mutation: MutationType;
  node: PredictedSalesValueByCompany;
  updatedFields: String[];
  previousValues: PredictedSalesValueByCompanyPreviousValues;
}

export interface PredictedSalesValueByCompanySubscriptionPayloadPromise
  extends Promise<PredictedSalesValueByCompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PredictedSalesValueByCompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <
    T = PredictedSalesValueByCompanyPreviousValuesPromise
  >() => T;
}

export interface PredictedSalesValueByCompanySubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<PredictedSalesValueByCompanySubscriptionPayload>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PredictedSalesValueByCompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = PredictedSalesValueByCompanyPreviousValuesSubscription
  >() => T;
}

export interface AssetEdge {
  node: Asset;
  cursor: String;
}

export interface AssetEdgePromise extends Promise<AssetEdge>, Fragmentable {
  node: <T = AssetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AssetEdgeSubscription
  extends Promise<AsyncIterator<AssetEdge>>,
    Fragmentable {
  node: <T = AssetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PredictedSalesValueByCompanyPreviousValues {
  id: ID_Output;
  datePredictionRun?: DateTimeOutput;
  predictedSalesValue?: Float;
  predictedDate?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PredictedSalesValueByCompanyPreviousValuesPromise
  extends Promise<PredictedSalesValueByCompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  datePredictionRun: () => Promise<DateTimeOutput>;
  predictedSalesValue: () => Promise<Float>;
  predictedDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PredictedSalesValueByCompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<PredictedSalesValueByCompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  datePredictionRun: () => Promise<AsyncIterator<DateTimeOutput>>;
  predictedSalesValue: () => Promise<AsyncIterator<Float>>;
  predictedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryOnHandEdge {
  node: InventoryOnHand;
  cursor: String;
}

export interface InventoryOnHandEdgePromise
  extends Promise<InventoryOnHandEdge>,
    Fragmentable {
  node: <T = InventoryOnHandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryOnHandEdgeSubscription
  extends Promise<AsyncIterator<InventoryOnHandEdge>>,
    Fragmentable {
  node: <T = InventoryOnHandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryOnHand {
  id: ID_Output;
  date?: DateTimeOutput;
  pbsDrug?: String;
  onHandQty?: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InventoryOnHandPromise
  extends Promise<InventoryOnHand>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  item: <T = InventoryPromise>() => T;
  pbsDrug: () => Promise<String>;
  onHandQty: () => Promise<Int>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  warehouse: <T = WareHousePromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryOnHandSubscription
  extends Promise<AsyncIterator<InventoryOnHand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  item: <T = InventorySubscription>() => T;
  pbsDrug: () => Promise<AsyncIterator<String>>;
  onHandQty: () => Promise<AsyncIterator<Int>>;
  purchaseOrder: <T = PurchaseOrderSubscription>() => T;
  warehouse: <T = WareHouseSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryOnHandNullablePromise
  extends Promise<InventoryOnHand | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  item: <T = InventoryPromise>() => T;
  pbsDrug: () => Promise<String>;
  onHandQty: () => Promise<Int>;
  purchaseOrder: <T = PurchaseOrderPromise>() => T;
  warehouse: <T = WareHousePromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface VaccineBrandSubscriptionPayload {
  mutation: MutationType;
  node: VaccineBrand;
  updatedFields: String[];
  previousValues: VaccineBrandPreviousValues;
}

export interface VaccineBrandSubscriptionPayloadPromise
  extends Promise<VaccineBrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VaccineBrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VaccineBrandPreviousValuesPromise>() => T;
}

export interface VaccineBrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VaccineBrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VaccineBrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VaccineBrandPreviousValuesSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  description?: String;
  endsAt?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  name?: String;
  startsAt?: DateTimeOutput;
  status?: ProjectStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  name: () => Promise<String>;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<ProjectStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<ProjectStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTimeSheetEntry {
  count: Int;
}

export interface AggregateTimeSheetEntryPromise
  extends Promise<AggregateTimeSheetEntry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeSheetEntrySubscription
  extends Promise<AsyncIterator<AggregateTimeSheetEntry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SupplierEdge {
  node: Supplier;
  cursor: String;
}

export interface SupplierEdgePromise
  extends Promise<SupplierEdge>,
    Fragmentable {
  node: <T = SupplierPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupplierEdgeSubscription
  extends Promise<AsyncIterator<SupplierEdge>>,
    Fragmentable {
  node: <T = SupplierSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectServiceSubscriptionPayload {
  mutation: MutationType;
  node: ProjectService;
  updatedFields: String[];
  previousValues: ProjectServicePreviousValues;
}

export interface ProjectServiceSubscriptionPayloadPromise
  extends Promise<ProjectServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectServicePreviousValuesPromise>() => T;
}

export interface ProjectServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectServicePreviousValuesSubscription>() => T;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectServicePreviousValues {
  id: ID_Output;
  amount?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectServicePreviousValuesPromise
  extends Promise<ProjectServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseOrderLineEdge {
  node: PurchaseOrderLine;
  cursor: String;
}

export interface PurchaseOrderLineEdgePromise
  extends Promise<PurchaseOrderLineEdge>,
    Fragmentable {
  node: <T = PurchaseOrderLinePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseOrderLineEdgeSubscription
  extends Promise<AsyncIterator<PurchaseOrderLineEdge>>,
    Fragmentable {
  node: <T = PurchaseOrderLineSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface ProjectServiceRuleEdge {
  node: ProjectServiceRule;
  cursor: String;
}

export interface ProjectServiceRuleEdgePromise
  extends Promise<ProjectServiceRuleEdge>,
    Fragmentable {
  node: <T = ProjectServiceRulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectServiceRuleEdgeSubscription
  extends Promise<AsyncIterator<ProjectServiceRuleEdge>>,
    Fragmentable {
  node: <T = ProjectServiceRuleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectServiceRuleSubscriptionPayload {
  mutation: MutationType;
  node: ProjectServiceRule;
  updatedFields: String[];
  previousValues: ProjectServiceRulePreviousValues;
}

export interface ProjectServiceRuleSubscriptionPayloadPromise
  extends Promise<ProjectServiceRuleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectServiceRulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectServiceRulePreviousValuesPromise>() => T;
}

export interface ProjectServiceRuleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectServiceRuleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectServiceRuleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectServiceRulePreviousValuesSubscription>() => T;
}

export interface PurchaseOrder {
  id: ID_Output;
  pbsOrganisation?: String;
  date?: DateTimeOutput;
  status?: PoStatus;
  isPbsPO?: Boolean;
  poNumber: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PurchaseOrderPromise
  extends Promise<PurchaseOrder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pbsOrganisation: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  orderer: <T = UserPromise>() => T;
  status: () => Promise<PoStatus>;
  supplier: <T = SupplierPromise>() => T;
  isPbsPO: () => Promise<Boolean>;
  poNumber: () => Promise<Int>;
  preview: <T = AttachmentPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PurchaseOrderSubscription
  extends Promise<AsyncIterator<PurchaseOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pbsOrganisation: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  orderer: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<PoStatus>>;
  supplier: <T = SupplierSubscription>() => T;
  isPbsPO: () => Promise<AsyncIterator<Boolean>>;
  poNumber: () => Promise<AsyncIterator<Int>>;
  preview: <T = AttachmentSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseOrderNullablePromise
  extends Promise<PurchaseOrder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pbsOrganisation: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  orderer: <T = UserPromise>() => T;
  status: () => Promise<PoStatus>;
  supplier: <T = SupplierPromise>() => T;
  isPbsPO: () => Promise<Boolean>;
  poNumber: () => Promise<Int>;
  preview: <T = AttachmentPromise>() => T;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServiceRulePreviousValues {
  id: ID_Output;
  amount?: Float;
  percent?: Float;
  type?: ProjectServiceRuleType;
  isPercent?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectServiceRulePreviousValuesPromise
  extends Promise<ProjectServiceRulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  percent: () => Promise<Float>;
  type: () => Promise<ProjectServiceRuleType>;
  isPercent: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServiceRulePreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectServiceRulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  percent: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<ProjectServiceRuleType>>;
  isPercent: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PredictedSalesQuantityOfItemsByCompanyConnection {
  pageInfo: PageInfo;
  edges: PredictedSalesQuantityOfItemsByCompanyEdge[];
}

export interface PredictedSalesQuantityOfItemsByCompanyConnectionPromise
  extends Promise<PredictedSalesQuantityOfItemsByCompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <
    T = FragmentableArray<PredictedSalesQuantityOfItemsByCompanyEdge>
  >() => T;
  aggregate: <
    T = AggregatePredictedSalesQuantityOfItemsByCompanyPromise
  >() => T;
}

export interface PredictedSalesQuantityOfItemsByCompanyConnectionSubscription
  extends Promise<
      AsyncIterator<PredictedSalesQuantityOfItemsByCompanyConnection>
    >,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<
      AsyncIterator<PredictedSalesQuantityOfItemsByCompanyEdgeSubscription>
    >
  >() => T;
  aggregate: <
    T = AggregatePredictedSalesQuantityOfItemsByCompanySubscription
  >() => T;
}

export interface AggregateCompanyMember {
  count: Int;
}

export interface AggregateCompanyMemberPromise
  extends Promise<AggregateCompanyMember>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanyMemberSubscription
  extends Promise<AsyncIterator<AggregateCompanyMember>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePlan {
  count: Int;
}

export interface AggregatePlanPromise
  extends Promise<AggregatePlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanSubscription
  extends Promise<AsyncIterator<AggregatePlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PurchaseOrderSubscriptionPayload {
  mutation: MutationType;
  node: PurchaseOrder;
  updatedFields: String[];
  previousValues: PurchaseOrderPreviousValues;
}

export interface PurchaseOrderSubscriptionPayloadPromise
  extends Promise<PurchaseOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchaseOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchaseOrderPreviousValuesPromise>() => T;
}

export interface PurchaseOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchaseOrderPreviousValuesSubscription>() => T;
}

export interface PbsTPP {
  id: ID_Output;
  snomedCode?: String;
  clinicalPreferredTerm?: String;
  packSize?: Int;
  brandName?: String;
  exManufacturerPrice?: Float;
  pricingModel?: PBSPricingModel;
  mpp_id?: String;
  effectiveFrom?: DateTimeOutput;
  effectiveTo?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PbsTPPPromise extends Promise<PbsTPP>, Fragmentable {
  id: () => Promise<ID_Output>;
  snomedCode: () => Promise<String>;
  clinicalPreferredTerm: () => Promise<String>;
  packSize: () => Promise<Int>;
  brandName: () => Promise<String>;
  exManufacturerPrice: () => Promise<Float>;
  pricingModel: () => Promise<PBSPricingModel>;
  mpp_id: () => Promise<String>;
  organisation_id: <T = PbsOrganisationPromise>() => T;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PbsTPPSubscription
  extends Promise<AsyncIterator<PbsTPP>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  snomedCode: () => Promise<AsyncIterator<String>>;
  clinicalPreferredTerm: () => Promise<AsyncIterator<String>>;
  packSize: () => Promise<AsyncIterator<Int>>;
  brandName: () => Promise<AsyncIterator<String>>;
  exManufacturerPrice: () => Promise<AsyncIterator<Float>>;
  pricingModel: () => Promise<AsyncIterator<PBSPricingModel>>;
  mpp_id: () => Promise<AsyncIterator<String>>;
  organisation_id: <T = PbsOrganisationSubscription>() => T;
  effectiveFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  effectiveTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PbsTPPNullablePromise
  extends Promise<PbsTPP | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  snomedCode: () => Promise<String>;
  clinicalPreferredTerm: () => Promise<String>;
  packSize: () => Promise<Int>;
  brandName: () => Promise<String>;
  exManufacturerPrice: () => Promise<Float>;
  pricingModel: () => Promise<PBSPricingModel>;
  mpp_id: () => Promise<String>;
  organisation_id: <T = PbsOrganisationPromise>() => T;
  effectiveFrom: () => Promise<DateTimeOutput>;
  effectiveTo: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PurchaseOrderPreviousValues {
  id: ID_Output;
  pbsOrganisation?: String;
  date?: DateTimeOutput;
  status?: PoStatus;
  isPbsPO?: Boolean;
  poNumber: Int;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PurchaseOrderPreviousValuesPromise
  extends Promise<PurchaseOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pbsOrganisation: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  status: () => Promise<PoStatus>;
  isPbsPO: () => Promise<Boolean>;
  poNumber: () => Promise<Int>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PurchaseOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<PurchaseOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pbsOrganisation: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<PoStatus>>;
  isPbsPO: () => Promise<AsyncIterator<Boolean>>;
  poNumber: () => Promise<AsyncIterator<Int>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PatientConnection {
  pageInfo: PageInfo;
  edges: PatientEdge[];
}

export interface PatientConnectionPromise
  extends Promise<PatientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PatientEdge>>() => T;
  aggregate: <T = AggregatePatientPromise>() => T;
}

export interface PatientConnectionSubscription
  extends Promise<AsyncIterator<PatientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PatientEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePatientSubscription>() => T;
}

export interface CompanyMemberEdge {
  node: CompanyMember;
  cursor: String;
}

export interface CompanyMemberEdgePromise
  extends Promise<CompanyMemberEdge>,
    Fragmentable {
  node: <T = CompanyMemberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyMemberEdgeSubscription
  extends Promise<AsyncIterator<CompanyMemberEdge>>,
    Fragmentable {
  node: <T = CompanyMemberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MedicareServiceConnection {
  pageInfo: PageInfo;
  edges: MedicareServiceEdge[];
}

export interface MedicareServiceConnectionPromise
  extends Promise<MedicareServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MedicareServiceEdge>>() => T;
  aggregate: <T = AggregateMedicareServicePromise>() => T;
}

export interface MedicareServiceConnectionSubscription
  extends Promise<AsyncIterator<MedicareServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MedicareServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMedicareServiceSubscription>() => T;
}

export interface PurchaseOrderLineSubscriptionPayload {
  mutation: MutationType;
  node: PurchaseOrderLine;
  updatedFields: String[];
  previousValues: PurchaseOrderLinePreviousValues;
}

export interface PurchaseOrderLineSubscriptionPayloadPromise
  extends Promise<PurchaseOrderLineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchaseOrderLinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchaseOrderLinePreviousValuesPromise>() => T;
}

export interface PurchaseOrderLineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseOrderLineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseOrderLineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchaseOrderLinePreviousValuesSubscription>() => T;
}

export interface MeansTestLimitsConnection {
  pageInfo: PageInfo;
  edges: MeansTestLimitsEdge[];
}

export interface MeansTestLimitsConnectionPromise
  extends Promise<MeansTestLimitsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeansTestLimitsEdge>>() => T;
  aggregate: <T = AggregateMeansTestLimitsPromise>() => T;
}

export interface MeansTestLimitsConnectionSubscription
  extends Promise<AsyncIterator<MeansTestLimitsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeansTestLimitsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeansTestLimitsSubscription>() => T;
}

export interface PurchaseOrderLinePreviousValues {
  id: ID_Output;
  pbsDrug?: String;
  qty?: Int;
  unit?: UOM;
  unitPrice?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PurchaseOrderLinePreviousValuesPromise
  extends Promise<PurchaseOrderLinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  pbsDrug: () => Promise<String>;
  qty: () => Promise<Int>;
  unit: () => Promise<UOM>;
  unitPrice: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PurchaseOrderLinePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchaseOrderLinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pbsDrug: () => Promise<AsyncIterator<String>>;
  qty: () => Promise<AsyncIterator<Int>>;
  unit: () => Promise<AsyncIterator<UOM>>;
  unitPrice: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerTransactionEdge {
  node: LedgerTransaction;
  cursor: String;
}

export interface LedgerTransactionEdgePromise
  extends Promise<LedgerTransactionEdge>,
    Fragmentable {
  node: <T = LedgerTransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LedgerTransactionEdgeSubscription
  extends Promise<AsyncIterator<LedgerTransactionEdge>>,
    Fragmentable {
  node: <T = LedgerTransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyMemberConnection {
  pageInfo: PageInfo;
  edges: CompanyMemberEdge[];
}

export interface CompanyMemberConnectionPromise
  extends Promise<CompanyMemberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyMemberEdge>>() => T;
  aggregate: <T = AggregateCompanyMemberPromise>() => T;
}

export interface CompanyMemberConnectionSubscription
  extends Promise<AsyncIterator<CompanyMemberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyMemberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanyMemberSubscription>() => T;
}

export interface AggregateLedgerJournal {
  count: Int;
}

export interface AggregateLedgerJournalPromise
  extends Promise<AggregateLedgerJournal>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLedgerJournalSubscription
  extends Promise<AsyncIterator<AggregateLedgerJournal>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalesOrderSubscriptionPayload {
  mutation: MutationType;
  node: SalesOrder;
  updatedFields: String[];
  previousValues: SalesOrderPreviousValues;
}

export interface SalesOrderSubscriptionPayloadPromise
  extends Promise<SalesOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalesOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalesOrderPreviousValuesPromise>() => T;
}

export interface SalesOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalesOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalesOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalesOrderPreviousValuesSubscription>() => T;
}

export interface InvoiceEdge {
  node: Invoice;
  cursor: String;
}

export interface InvoiceEdgePromise extends Promise<InvoiceEdge>, Fragmentable {
  node: <T = InvoicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvoiceEdgeSubscription
  extends Promise<AsyncIterator<InvoiceEdge>>,
    Fragmentable {
  node: <T = InvoiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SalesOrderPreviousValues {
  id: ID_Output;
  transactionDate?: DateTimeOutput;
  currency?: Currency;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesOrderPreviousValuesPromise
  extends Promise<SalesOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  transactionDate: () => Promise<DateTimeOutput>;
  currency: () => Promise<Currency>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<SalesOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  transactionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectService {
  id: ID_Output;
  amount?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectServicePromise
  extends Promise<ProjectService>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  project: <T = ProjectPromise>() => T;
  rules: <T = FragmentableArray<ProjectServiceRule>>(args?: {
    where?: ProjectServiceRuleWhereInput;
    orderBy?: ProjectServiceRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = ServicePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectServiceSubscription
  extends Promise<AsyncIterator<ProjectService>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  project: <T = ProjectSubscription>() => T;
  rules: <T = Promise<AsyncIterator<ProjectServiceRuleSubscription>>>(args?: {
    where?: ProjectServiceRuleWhereInput;
    orderBy?: ProjectServiceRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = ServiceSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectServiceNullablePromise
  extends Promise<ProjectService | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  project: <T = ProjectPromise>() => T;
  rules: <T = FragmentableArray<ProjectServiceRule>>(args?: {
    where?: ProjectServiceRuleWhereInput;
    orderBy?: ProjectServiceRuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  service: <T = ServicePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Invoice {
  id: ID_Output;
  title?: String;
  number?: Int;
  description?: String;
  invoiceDate?: DateTimeOutput;
  dueDate?: DateTimeOutput;
  status?: InvoiceStatus;
  type?: InvoiceType;
  total?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvoicePromise extends Promise<Invoice>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  attachments: <T = FragmentableArray<Attachment>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyer: <T = CustomerPromise>() => T;
  number: () => Promise<Int>;
  description: () => Promise<String>;
  invoiceDate: () => Promise<DateTimeOutput>;
  dueDate: () => Promise<DateTimeOutput>;
  preview: <T = AttachmentPromise>() => T;
  items: <T = FragmentableArray<InvoiceItemEntry>>(args?: {
    where?: InvoiceItemEntryWhereInput;
    orderBy?: InvoiceItemEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seller: <T = CompanyPromise>() => T;
  status: () => Promise<InvoiceStatus>;
  type: () => Promise<InvoiceType>;
  total: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvoiceSubscription
  extends Promise<AsyncIterator<Invoice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  attachments: <T = Promise<AsyncIterator<AttachmentSubscription>>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyer: <T = CustomerSubscription>() => T;
  number: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
  invoiceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  dueDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  preview: <T = AttachmentSubscription>() => T;
  items: <T = Promise<AsyncIterator<InvoiceItemEntrySubscription>>>(args?: {
    where?: InvoiceItemEntryWhereInput;
    orderBy?: InvoiceItemEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seller: <T = CompanySubscription>() => T;
  status: () => Promise<AsyncIterator<InvoiceStatus>>;
  type: () => Promise<AsyncIterator<InvoiceType>>;
  total: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvoiceNullablePromise
  extends Promise<Invoice | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  attachments: <T = FragmentableArray<Attachment>>(args?: {
    where?: AttachmentWhereInput;
    orderBy?: AttachmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  buyer: <T = CustomerPromise>() => T;
  number: () => Promise<Int>;
  description: () => Promise<String>;
  invoiceDate: () => Promise<DateTimeOutput>;
  dueDate: () => Promise<DateTimeOutput>;
  preview: <T = AttachmentPromise>() => T;
  items: <T = FragmentableArray<InvoiceItemEntry>>(args?: {
    where?: InvoiceItemEntryWhereInput;
    orderBy?: InvoiceItemEntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  seller: <T = CompanyPromise>() => T;
  status: () => Promise<InvoiceStatus>;
  type: () => Promise<InvoiceType>;
  total: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesOrderLineSubscriptionPayload {
  mutation: MutationType;
  node: SalesOrderLine;
  updatedFields: String[];
  previousValues: SalesOrderLinePreviousValues;
}

export interface SalesOrderLineSubscriptionPayloadPromise
  extends Promise<SalesOrderLineSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalesOrderLinePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalesOrderLinePreviousValuesPromise>() => T;
}

export interface SalesOrderLineSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalesOrderLineSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalesOrderLineSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalesOrderLinePreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface SalesOrderLinePreviousValues {
  id: ID_Output;
  qty?: Int;
  price?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SalesOrderLinePreviousValuesPromise
  extends Promise<SalesOrderLinePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  qty: () => Promise<Int>;
  price: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SalesOrderLinePreviousValuesSubscription
  extends Promise<AsyncIterator<SalesOrderLinePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  qty: () => Promise<AsyncIterator<Int>>;
  price: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TimeSheetEdge {
  node: TimeSheet;
  cursor: String;
}

export interface TimeSheetEdgePromise
  extends Promise<TimeSheetEdge>,
    Fragmentable {
  node: <T = TimeSheetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeSheetEdgeSubscription
  extends Promise<AsyncIterator<TimeSheetEdge>>,
    Fragmentable {
  node: <T = TimeSheetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SalesOrderConnection {
  pageInfo: PageInfo;
  edges: SalesOrderEdge[];
}

export interface SalesOrderConnectionPromise
  extends Promise<SalesOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalesOrderEdge>>() => T;
  aggregate: <T = AggregateSalesOrderPromise>() => T;
}

export interface SalesOrderConnectionSubscription
  extends Promise<AsyncIterator<SalesOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalesOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalesOrderSubscription>() => T;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ProjectServiceConnection {
  pageInfo: PageInfo;
  edges: ProjectServiceEdge[];
}

export interface ProjectServiceConnectionPromise
  extends Promise<ProjectServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectServiceEdge>>() => T;
  aggregate: <T = AggregateProjectServicePromise>() => T;
}

export interface ProjectServiceConnectionSubscription
  extends Promise<AsyncIterator<ProjectServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectServiceSubscription>() => T;
}

export interface ServicePreviousValues {
  id: ID_Output;
  billingType: ServiceBillingType;
  includeConsTax: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isTemplate?: Boolean;
  name: String;
  timeBasedType?: TimeBasedType;
  totalAmount: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  billingType: () => Promise<ServiceBillingType>;
  includeConsTax: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isTemplate: () => Promise<Boolean>;
  name: () => Promise<String>;
  timeBasedType: () => Promise<TimeBasedType>;
  totalAmount: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  billingType: () => Promise<AsyncIterator<ServiceBillingType>>;
  includeConsTax: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isTemplate: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  timeBasedType: () => Promise<AsyncIterator<TimeBasedType>>;
  totalAmount: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PoReceiptEdge {
  node: PoReceipt;
  cursor: String;
}

export interface PoReceiptEdgePromise
  extends Promise<PoReceiptEdge>,
    Fragmentable {
  node: <T = PoReceiptPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PoReceiptEdgeSubscription
  extends Promise<AsyncIterator<PoReceiptEdge>>,
    Fragmentable {
  node: <T = PoReceiptSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface Contact {
  id: ID_Output;
  name?: String;
  surname?: String;
  email?: String;
  mobileCode?: String;
  mobileNumber?: String;
  landlineCode?: String;
  landlineNumber?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
  email: () => Promise<String>;
  mobileCode: () => Promise<String>;
  mobileNumber: () => Promise<String>;
  landlineCode: () => Promise<String>;
  landlineNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  surname: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobileCode: () => Promise<AsyncIterator<String>>;
  mobileNumber: () => Promise<AsyncIterator<String>>;
  landlineCode: () => Promise<AsyncIterator<String>>;
  landlineNumber: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  surname: () => Promise<String>;
  email: () => Promise<String>;
  mobileCode: () => Promise<String>;
  mobileNumber: () => Promise<String>;
  landlineCode: () => Promise<String>;
  landlineNumber: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface MeansTestedFeeEdge {
  node: MeansTestedFee;
  cursor: String;
}

export interface MeansTestedFeeEdgePromise
  extends Promise<MeansTestedFeeEdge>,
    Fragmentable {
  node: <T = MeansTestedFeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeansTestedFeeEdgeSubscription
  extends Promise<AsyncIterator<MeansTestedFeeEdge>>,
    Fragmentable {
  node: <T = MeansTestedFeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SessionPreviousValues {
  id: ID_Output;
  expires_at?: DateTimeOutput;
  is_active?: Boolean;
  is_archived?: Boolean;
  is_deleted?: Boolean;
  signed_at?: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expires_at: () => Promise<DateTimeOutput>;
  is_active: () => Promise<Boolean>;
  is_archived: () => Promise<Boolean>;
  is_deleted: () => Promise<Boolean>;
  signed_at: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expires_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  is_active: () => Promise<AsyncIterator<Boolean>>;
  is_archived: () => Promise<AsyncIterator<Boolean>>;
  is_deleted: () => Promise<AsyncIterator<Boolean>>;
  signed_at: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerPostingEdge {
  node: LedgerPosting;
  cursor: String;
}

export interface LedgerPostingEdgePromise
  extends Promise<LedgerPostingEdge>,
    Fragmentable {
  node: <T = LedgerPostingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LedgerPostingEdgeSubscription
  extends Promise<AsyncIterator<LedgerPostingEdge>>,
    Fragmentable {
  node: <T = LedgerPostingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LedgerJournal {
  id: ID_Output;
  total?: Float;
  description?: String;
  currency: Currency;
  includeConsTax: Boolean;
  posted: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface LedgerJournalPromise
  extends Promise<LedgerJournal>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  description: () => Promise<String>;
  currency: () => Promise<Currency>;
  includeConsTax: () => Promise<Boolean>;
  posted: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LedgerJournalSubscription
  extends Promise<AsyncIterator<LedgerJournal>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  includeConsTax: () => Promise<AsyncIterator<Boolean>>;
  posted: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LedgerJournalNullablePromise
  extends Promise<LedgerJournal | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  description: () => Promise<String>;
  currency: () => Promise<Currency>;
  includeConsTax: () => Promise<Boolean>;
  posted: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetEntry {
  id: ID_Output;
  date?: DateTimeOutput;
  duration?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isInvoiced?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TimeSheetEntryPromise
  extends Promise<TimeSheetEntry>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  duration: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isInvoiced: () => Promise<Boolean>;
  project: <T = ProjectPromise>() => T;
  service: <T = ServicePromise>() => T;
  timeSheet: <T = TimeSheetPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetEntrySubscription
  extends Promise<AsyncIterator<TimeSheetEntry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer: <T = CustomerSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isInvoiced: () => Promise<AsyncIterator<Boolean>>;
  project: <T = ProjectSubscription>() => T;
  service: <T = ServiceSubscription>() => T;
  timeSheet: <T = TimeSheetSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TimeSheetEntryNullablePromise
  extends Promise<TimeSheetEntry | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer: <T = CustomerPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  duration: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isInvoiced: () => Promise<Boolean>;
  project: <T = ProjectPromise>() => T;
  service: <T = ServicePromise>() => T;
  timeSheet: <T = TimeSheetPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SupplierSubscriptionPayload {
  mutation: MutationType;
  node: Supplier;
  updatedFields: String[];
  previousValues: SupplierPreviousValues;
}

export interface SupplierSubscriptionPayloadPromise
  extends Promise<SupplierSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupplierPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupplierPreviousValuesPromise>() => T;
}

export interface SupplierSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupplierSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupplierSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupplierPreviousValuesSubscription>() => T;
}

export interface AssetGroupConnection {
  pageInfo: PageInfo;
  edges: AssetGroupEdge[];
}

export interface AssetGroupConnectionPromise
  extends Promise<AssetGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AssetGroupEdge>>() => T;
  aggregate: <T = AggregateAssetGroupPromise>() => T;
}

export interface AssetGroupConnectionSubscription
  extends Promise<AsyncIterator<AssetGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AssetGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAssetGroupSubscription>() => T;
}

export interface SupplierPreviousValues {
  id: ID_Output;
  name?: String;
  termsOfPayment?: SupplierTermsOfPayment;
  bankAccount?: Json;
  emailAddressForRemittance?: String;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SupplierPreviousValuesPromise
  extends Promise<SupplierPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  termsOfPayment: () => Promise<SupplierTermsOfPayment>;
  bankAccount: () => Promise<Json>;
  emailAddressForRemittance: () => Promise<String>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SupplierPreviousValuesSubscription
  extends Promise<AsyncIterator<SupplierPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  termsOfPayment: () => Promise<AsyncIterator<SupplierTermsOfPayment>>;
  bankAccount: () => Promise<AsyncIterator<Json>>;
  emailAddressForRemittance: () => Promise<AsyncIterator<String>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBasicDailyFee {
  count: Int;
}

export interface AggregateBasicDailyFeePromise
  extends Promise<AggregateBasicDailyFee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBasicDailyFeeSubscription
  extends Promise<AsyncIterator<AggregateBasicDailyFee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  contactNumber?: Json;
  email?: String;
  firstName?: String;
  isActive?: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isRoot?: Boolean;
  jobTitle?: String;
  lastName?: String;
  password?: String;
  secondAuthEnabled?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  contactNumber: () => Promise<Json>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isRoot: () => Promise<Boolean>;
  jobTitle: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  secondAuthEnabled: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  contactNumber: () => Promise<AsyncIterator<Json>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isRoot: () => Promise<AsyncIterator<Boolean>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  secondAuthEnabled: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  contactNumber: () => Promise<Json>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  isActive: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isRoot: () => Promise<Boolean>;
  jobTitle: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  secondAuthEnabled: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetSubscriptionPayload {
  mutation: MutationType;
  node: TimeSheet;
  updatedFields: String[];
  previousValues: TimeSheetPreviousValues;
}

export interface TimeSheetSubscriptionPayloadPromise
  extends Promise<TimeSheetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeSheetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeSheetPreviousValuesPromise>() => T;
}

export interface TimeSheetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeSheetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeSheetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeSheetPreviousValuesSubscription>() => T;
}

export interface NameConnection {
  pageInfo: PageInfo;
  edges: NameEdge[];
}

export interface NameConnectionPromise
  extends Promise<NameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NameEdge>>() => T;
  aggregate: <T = AggregateNamePromise>() => T;
}

export interface NameConnectionSubscription
  extends Promise<AsyncIterator<NameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNameSubscription>() => T;
}

export interface TimeSheetPreviousValues {
  id: ID_Output;
  endsAt?: DateTimeOutput;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  number?: Int;
  startsAt?: DateTimeOutput;
  status?: TimeSheetStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TimeSheetPreviousValuesPromise
  extends Promise<TimeSheetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  endsAt: () => Promise<DateTimeOutput>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  number: () => Promise<Int>;
  startsAt: () => Promise<DateTimeOutput>;
  status: () => Promise<TimeSheetStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetPreviousValuesSubscription
  extends Promise<AsyncIterator<TimeSheetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  endsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  number: () => Promise<AsyncIterator<Int>>;
  startsAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<TimeSheetStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInvoiceItemEntry {
  count: Int;
}

export interface AggregateInvoiceItemEntryPromise
  extends Promise<AggregateInvoiceItemEntry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvoiceItemEntrySubscription
  extends Promise<AsyncIterator<AggregateInvoiceItemEntry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BasicDailyFee {
  id: ID_Output;
  level?: LevelOfCare;
  rate?: Float;
  dateFrom?: DateTimeOutput;
  dateTo?: DateTimeOutput;
  rechargeable?: Float;
}

export interface BasicDailyFeePromise
  extends Promise<BasicDailyFee>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  level: () => Promise<LevelOfCare>;
  rate: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
  rechargeable: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
}

export interface BasicDailyFeeSubscription
  extends Promise<AsyncIterator<BasicDailyFee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  level: () => Promise<AsyncIterator<LevelOfCare>>;
  rate: () => Promise<AsyncIterator<Float>>;
  dateFrom: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateTo: () => Promise<AsyncIterator<DateTimeOutput>>;
  rechargeable: () => Promise<AsyncIterator<Float>>;
  company: <T = CompanySubscription>() => T;
}

export interface BasicDailyFeeNullablePromise
  extends Promise<BasicDailyFee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  level: () => Promise<LevelOfCare>;
  rate: () => Promise<Float>;
  dateFrom: () => Promise<DateTimeOutput>;
  dateTo: () => Promise<DateTimeOutput>;
  rechargeable: () => Promise<Float>;
  company: <T = CompanyPromise>() => T;
}

export interface BasicDailyFeeConnection {
  pageInfo: PageInfo;
  edges: BasicDailyFeeEdge[];
}

export interface BasicDailyFeeConnectionPromise
  extends Promise<BasicDailyFeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BasicDailyFeeEdge>>() => T;
  aggregate: <T = AggregateBasicDailyFeePromise>() => T;
}

export interface BasicDailyFeeConnectionSubscription
  extends Promise<AsyncIterator<BasicDailyFeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BasicDailyFeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBasicDailyFeeSubscription>() => T;
}

export interface TimeSheetEntryPreviousValues {
  id: ID_Output;
  date?: DateTimeOutput;
  duration?: Float;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  isInvoiced?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TimeSheetEntryPreviousValuesPromise
  extends Promise<TimeSheetEntryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  duration: () => Promise<Float>;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  isInvoiced: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TimeSheetEntryPreviousValuesSubscription
  extends Promise<AsyncIterator<TimeSheetEntryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  duration: () => Promise<AsyncIterator<Float>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  isInvoiced: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TimeSheetEntrySubscriptionPayload {
  mutation: MutationType;
  node: TimeSheetEntry;
  updatedFields: String[];
  previousValues: TimeSheetEntryPreviousValues;
}

export interface TimeSheetEntrySubscriptionPayloadPromise
  extends Promise<TimeSheetEntrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeSheetEntryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeSheetEntryPreviousValuesPromise>() => T;
}

export interface TimeSheetEntrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeSheetEntrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeSheetEntrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeSheetEntryPreviousValuesSubscription>() => T;
}

export interface BasicDailyFeeEdge {
  node: BasicDailyFee;
  cursor: String;
}

export interface BasicDailyFeeEdgePromise
  extends Promise<BasicDailyFeeEdge>,
    Fragmentable {
  node: <T = BasicDailyFeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BasicDailyFeeEdgeSubscription
  extends Promise<AsyncIterator<BasicDailyFeeEdge>>,
    Fragmentable {
  node: <T = BasicDailyFeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PurchaseOrderEdge {
  node: PurchaseOrder;
  cursor: String;
}

export interface PurchaseOrderEdgePromise
  extends Promise<PurchaseOrderEdge>,
    Fragmentable {
  node: <T = PurchaseOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseOrderEdgeSubscription
  extends Promise<AsyncIterator<PurchaseOrderEdge>>,
    Fragmentable {
  node: <T = PurchaseOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MainAccount {
  id: ID_Output;
  code: String;
  name: String;
  description?: String;
  type: MainAccountType;
  ConsTaxFree: Boolean;
  isArchived?: Boolean;
  isDeleted?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MainAccountPromise extends Promise<MainAccount>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<MainAccountType>;
  ConsTaxFree: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MainAccountSubscription
  extends Promise<AsyncIterator<MainAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MainAccountType>>;
  ConsTaxFree: () => Promise<AsyncIterator<Boolean>>;
  company: <T = CompanySubscription>() => T;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDeleted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MainAccountNullablePromise
  extends Promise<MainAccount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<MainAccountType>;
  ConsTaxFree: () => Promise<Boolean>;
  company: <T = CompanyPromise>() => T;
  isArchived: () => Promise<Boolean>;
  isDeleted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MainAccountEdge {
  node: MainAccount;
  cursor: String;
}

export interface MainAccountEdgePromise
  extends Promise<MainAccountEdge>,
    Fragmentable {
  node: <T = MainAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MainAccountEdgeSubscription
  extends Promise<AsyncIterator<MainAccountEdge>>,
    Fragmentable {
  node: <T = MainAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePbsTPP {
  count: Int;
}

export interface AggregatePbsTPPPromise
  extends Promise<AggregatePbsTPP>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePbsTPPSubscription
  extends Promise<AsyncIterator<AggregatePbsTPP>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "CompanyMember",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Integration",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "ProjectService",
    embedded: false
  },
  {
    name: "ProjectServiceRule",
    embedded: false
  },
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "TimeSheet",
    embedded: false
  },
  {
    name: "Attachment",
    embedded: false
  },
  {
    name: "TimeSheetEntry",
    embedded: false
  },
  {
    name: "InvoiceItemEntry",
    embedded: false
  },
  {
    name: "Invoice",
    embedded: false
  },
  {
    name: "MainAccount",
    embedded: false
  },
  {
    name: "LedgerJournal",
    embedded: false
  },
  {
    name: "LedgerTransaction",
    embedded: false
  },
  {
    name: "LedgerPosting",
    embedded: false
  },
  {
    name: "Bank",
    embedded: false
  },
  {
    name: "BankTransaction",
    embedded: false
  },
  {
    name: "WareHouse",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "Supplier",
    embedded: false
  },
  {
    name: "AssetGroup",
    embedded: false
  },
  {
    name: "Asset",
    embedded: false
  },
  {
    name: "PurchaseOrder",
    embedded: false
  },
  {
    name: "PoReceipt",
    embedded: false
  },
  {
    name: "InventoryOnHand",
    embedded: false
  },
  {
    name: "PurchaseOrderLine",
    embedded: false
  },
  {
    name: "ApInvoice",
    embedded: false
  },
  {
    name: "SalesOrder",
    embedded: false
  },
  {
    name: "SalesOrderLine",
    embedded: false
  },
  {
    name: "PredictedSalesValueByCompany",
    embedded: false
  },
  {
    name: "PredictedSalesQuantityOfItemsByCompany",
    embedded: false
  },
  {
    name: "MedicareService",
    embedded: false
  },
  {
    name: "Patient",
    embedded: false
  },
  {
    name: "Name",
    embedded: false
  },
  {
    name: "HealthcareProvider",
    embedded: false
  },
  {
    name: "ImmunisationSchedule",
    embedded: false
  },
  {
    name: "VaccineBrand",
    embedded: false
  },
  {
    name: "Disease",
    embedded: false
  },
  {
    name: "HILog",
    embedded: false
  },
  {
    name: "PbsOrganisation",
    embedded: false
  },
  {
    name: "PbsTPP",
    embedded: false
  },
  {
    name: "MeansTestedFee",
    embedded: false
  },
  {
    name: "MeansTestLimits",
    embedded: false
  },
  {
    name: "BasicDailyFee",
    embedded: false
  },
  {
    name: "procurementType",
    embedded: false
  },
  {
    name: "inventoryTracking",
    embedded: false
  },
  {
    name: "inventoryStorage",
    embedded: false
  },
  {
    name: "LevelOfCare",
    embedded: false
  },
  {
    name: "PeriodUnit",
    embedded: false
  },
  {
    name: "AboriginalStatus",
    embedded: false
  },
  {
    name: "DVACardType",
    embedded: false
  },
  {
    name: "HINumberStatus",
    embedded: false
  },
  {
    name: "SalusResponse",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "BusinessType",
    embedded: false
  },
  {
    name: "CompanyMemberRole",
    embedded: false
  },
  {
    name: "CompanyMemberStatus",
    embedded: false
  },
  {
    name: "IntegrationType",
    embedded: false
  },
  {
    name: "ProjectStatus",
    embedded: false
  },
  {
    name: "ProjectServiceRuleType",
    embedded: false
  },
  {
    name: "TimeBasedType",
    embedded: false
  },
  {
    name: "ServiceBillingType",
    embedded: false
  },
  {
    name: "TimeSheetStatus",
    embedded: false
  },
  {
    name: "InvoiceType",
    embedded: false
  },
  {
    name: "InvoiceStatus",
    embedded: false
  },
  {
    name: "PostingType",
    embedded: false
  },
  {
    name: "MainAccountType",
    embedded: false
  },
  {
    name: "DrCr",
    embedded: false
  },
  {
    name: "PoStatus",
    embedded: false
  },
  {
    name: "InventoryModel",
    embedded: false
  },
  {
    name: "UOM",
    embedded: false
  },
  {
    name: "SupplierTermsOfPayment",
    embedded: false
  },
  {
    name: "AssetGroupDepreciationType",
    embedded: false
  },
  {
    name: "PBSPricingModel",
    embedded: false
  },
  {
    name: "ApInvoiceStatus",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  },
  {
    name: "PlanType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
